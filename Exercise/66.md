## 1. 問題タイトル

66 本目：被写界深度（DOF: Depth of Field）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `BokehPass` の使用方法
- ピント（焦点）の概念
- 映画のようなボケ味の表現

## 3. 新しい概念の解説

**Depth of Field (DOF / 被写界深度)**
カメラのレンズにおける「ピント（焦点）が合う範囲」のことです。
現実のカメラでは、ピント位置から離れるほど像がぼやけます。
CG でこれをシミュレートすることで、ミニチュア風に見せたり、注目させたい物体に視線を誘導したりする映画的な演出が可能になります。

```javascript
import { BokehPass } from 'three/examples/jsm/postprocessing/BokehPass';

const bokehPass = new BokehPass(scene, camera, {
  focus: 10.0,      // ピントが合う距離
  aperture: 0.0001, // 絞り（値が大きいほどボケが強くなる）
  maxblur: 0.01     // 最大ボケ量
});
composer.addPass(bokehPass);
```

## 4. 課題の説明

カメラのピントが合っている場所はくっきり見え、それ以外（手前や奥）がボケて見える「被写界深度（DOF）」エフェクトを追加してください。
たくさんのキューブを奥行き方向に並べ、特定の距離にあるキューブだけにピントを合わせます。

## 5. 必須要件

以下の機能を実装してください。

- **シーン構築**:
  100個以上のパーティクルやボックスを、カメラから見て手前（Z=20）から奥（Z=-50）まで広範囲に散らして配置します。

- **BokehPass の設定**:
  `three/examples/jsm/postprocessing/BokehPass` をインポートし、Composerに追加します。
  初期パラメータとして以下を設定します。
  - `focus`: 10.0（ピントが合う距離）
  - `aperture`: 0.0001〜0.001（絞り、ボケ具合）
  - `maxblur`: 0.01（最大ボケ率）

- **確認**:
  シーンの中央付近（focus距離）にある物体はくっきり見え、手前や奥にある物体がボケていることを確認します。
  `focus` 値を変更してピント位置が変わるかテストします。

## 6. ヒント

- **ヒント 1（必要なクラスのインポート）**:
  `BokehPass` を使用します。
  `three/examples/jsm/postprocessing/BokehPass`
  からインポートしてください。
- **ヒント 2（パスの初期化）**:
  `new BokehPass(scene, camera, { ... })`
  第 1 引数にシーン、第 2 引数にカメラを渡す必要があります（深度を計算するため）。
- **ヒント 3（focusパラメータ）**:
  `focus` は「ピントが合う距離」です。
  カメラからの距離（Depth）を指定します。
- **ヒント 4（apertureパラメータ）**:
  `aperture`（絞り）はボケの強さに影響します。
  値が大きいほど被写界深度が浅くなり、ピントが合う範囲が狭く（ボケが強く）なります。
  非常に小さな値（例: 0.0001〜0.01）で調整することが多いです。
- **ヒント 5（maxblurパラメータ）**:
  `maxblur` は最大ボケ量を制限します。
  大きくしすぎると描画負荷が高まったり、不自然に見えたりすることがあるため、0.01 程度が適当です。

## 7. スターターコード

```javascript
import * as THREE from "three";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass";
// import { BokehPass } ...

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// キューブを散らす
for (let i = 0; i < 100; i++) {
  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(1, 1, 1),
    new THREE.MeshNormalMaterial()
  );
  mesh.position.set(
    (Math.random() - 0.5) * 20,
    (Math.random() - 0.5) * 20,
    (Math.random() - 0.5) * 20 - 10
  );
  scene.add(mesh);
}

// --- ComposerとBokehPass ---

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  // composer.render();
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass";
import { BokehPass } from "three/examples/jsm/postprocessing/BokehPass";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

for (let i = 0; i < 100; i++) {
  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(1, 1, 1),
    new THREE.MeshNormalMaterial()
  );
  mesh.position.set(
    (Math.random() - 0.5) * 30,
    (Math.random() - 0.5) * 30,
    (Math.random() - 0.5) * 30
  );
  scene.add(mesh);
}

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const bokehPass = new BokehPass(scene, camera, {
  focus: 10.0, // ピントを合わせる距離
  aperture: 0.0001, // 絞り（値が大きいほどボケやすい）
  maxblur: 0.01, // 最大ボケ量
  width: window.innerWidth,
  height: window.innerHeight,
});
composer.addPass(bokehPass);

camera.position.z = 20;

function animate() {
  requestAnimationFrame(animate);

  // マウス操作などでfocusを変えると面白い
  // bokehPass.uniforms['focus'].value = ...;

  composer.render();
}
animate();
```
