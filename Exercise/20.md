## 1. 問題タイトル

20 本目：グループ化して複数オブジェクトを管理

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `THREE.Group` を使ったオブジェクトの階層化
- 親オブジェクトの回転・移動による子オブジェクトの一括制御
- ローカル座標とワールド座標の関係

## 3. 新しい概念の解説

**Group（グループ）**
複数のオブジェクトをまとめて管理するための「空の箱」のようなオブジェクトです。
グループ自体を回転・移動させると、その中に入っているすべての子オブジェクトも一緒に動きます。

```javascript
const group = new THREE.Group();
scene.add(group);
// メッシュをグループに追加
group.add(mesh1);
group.add(mesh2);
```

**Hierarchy（階層構造）**
オブジェクトに親子関係（`parent.add(child)`）を作ることで、複雑な動きを簡単に管理できます。
例えば「太陽の周りを回る地球、その周りを回る月」といった動きは、階層構造を使うと計算が非常に楽になります。

```javascript
// グループ（親）を回転させると、子要素も連動して動く
group.rotation.y += 0.01;
```

## 4. 課題の説明

「太陽」と「地球」のような関係を作ります。
中央のオブジェクト（太陽）の周りを、別のオブジェクト（地球）が公転するように実装してください。
これを実現するために、`THREE.Group` を使って回転の中心軸を作ると簡単です。

## 5. 必須要件

以下の機能を実装してください。

- **グループの作成**:
  `const group = new THREE.Group()` を作成し、シーンに追加します。

- **太陽（中心）**:
  大きな球体を作成し、直接シーン（またはグループの中心）に追加します。

- **地球（衛星）**:
  小さな球体を作成し、**グループに追加**します。
  `earth.position.x = 3` のように、中心から離れた位置に配置します。

- **公転アニメーション**:
  `animate` ループ内で `group.rotation.y += 0.01` を実行し、**グループごと**回転させます。
  これによって、地球が太陽の周りを回る「公転」が再現できます。

## 6. ヒント

- **ヒント 1（グループの役割）**:
  `THREE.Group` は、目に見えない透明なコンテナです。これ自体を回転・移動させることで、中身全体を一括コントロールできます。
- **ヒント 2（座標の仕組み）**:
  地球を `earthGroup.add(earth)` すると、地球の `position` は「グループの中心からの相対座標」になります。
  `earth.position.x = 4` とすれば、グループの中心から右に 4 離れた場所に配置されます。
- **ヒント 3（公転の原理）**:
  地球の位置はそのままで、親である `earthGroup` を Y 軸回転させます。
  すると、腕を伸ばして回転しているかのように、地球が中心周りを大きく回ります。
- **ヒント 4（自転の原理）**:
  地球自身の `earth.rotation.y` を回せば、公転しながら自転する動きも同時に表現できます。
- **ヒント 5（階層の深さ）**:
  さらに「月グループ」を地球に追加すれば、孫要素として「月」を回すことも可能です。Three.js ではこの階層構造（Scene Graph）が非常に重要です。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 太陽（中央）
const sunGeo = new THREE.SphereGeometry(1, 32, 16);
const sunMat = new THREE.MeshBasicMaterial({
  color: 0xff0000,
  wireframe: true,
});
const sun = new THREE.Mesh(sunGeo, sunMat);
scene.add(sun);

// --- ここでグループと地球を作成してください ---

camera.position.z = 10;

function animate() {
  requestAnimationFrame(animate);

  // --- ここでグループを回転させてください ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 1. 太陽（中央）
const sunGeo = new THREE.SphereGeometry(1, 32, 16);
const sunMat = new THREE.MeshBasicMaterial({
  color: 0xff0000,
  wireframe: true,
});
const sun = new THREE.Mesh(sunGeo, sunMat);
scene.add(sun);

// 2. グループの作成（公転軌道の中心）
const earthGroup = new THREE.Group();
scene.add(earthGroup);

// 3. 地球の作成
const earthGeo = new THREE.SphereGeometry(0.5, 32, 16);
const earthMat = new THREE.MeshBasicMaterial({
  color: 0x0000ff,
  wireframe: true,
});
const earth = new THREE.Mesh(earthGeo, earthMat);

// 地球をグループに追加し、位置をずらす
earth.position.x = 4;
earthGroup.add(earth);

camera.position.z = 10;

function animate() {
  requestAnimationFrame(animate);

  // 太陽の自転
  sun.rotation.y += 0.005;

  // グループを回転させると、子要素である地球が原点の周りを回る（公転）
  earthGroup.rotation.y += 0.02;

  // 地球の自転
  earth.rotation.y += 0.05;

  renderer.render(scene, camera);
}
animate();
```
