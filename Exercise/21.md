## 1. 問題タイトル

21 本目：マウスクリックでオブジェクトの色変更

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `Raycaster` を使ったオブジェクトの選択（ピッキング）
- マウス座標の正規化（-1 〜 +1 への変換）
- クリックイベントと Three.js の連携

## 3. 新しい概念の解説

**Raycaster（レイキャスター）**
カメラの位置から、マウスカーソルの方向に「見えない光線（Ray）」を飛ばし、その光線に当たったオブジェクトを検出する仕組みです。
3D 空間でのクリック判定（ピッキング）には必須の技術です。

**Normalized Coordinates（正規化座標）**
画面左上を(0,0)、右下を(width,height)とするピクセル座標ではなく、中心を(0,0)、左端を-1、右端を+1、上端を+1、下端を-1とする座標系です。
Raycaster はこの正規化された座標（-1 〜 +1）を必要とします。

```javascript
// マウス座標の正規化(-1 to +1)
mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

// レイキャスターで交差判定
raycaster.setFromCamera(mouse, camera);
const intersects = raycaster.intersectObjects(scene.children);

if (intersects.length > 0) {
    // 一番手前のオブジェクトの色を変える
    intersects[0].object.material.color.set(0xff0000);
}
```

## 4. 課題の説明

画面上のキューブをクリックしたら、そのキューブの色がランダムに変わるようにしてください。
これは 3D 空間でのインタラクション（UI 操作）の基本技術です。

## 5. 必須要件

以下の機能を実装してください。

- **Raycasterの準備**:
  `const raycaster = new THREE.Raycaster()` と `const mouse = new THREE.Vector2()` を作成します。

- **クリック座標の取得と変換**:
  `window` に `click` イベントリスナーを追加します。
  クリックされたピクセル座標（`clientX`, `clientY`）を、Three.js で使える正規化デバイス座標（-1〜+1）に変換します。
  `x = (clientX / width) * 2 - 1`
  `y = -(clientY / height) * 2 + 1`

- **交差判定**:
  `raycaster.setFromCamera(mouse, camera)` で光線をセットします。
  `raycaster.intersectObjects(scene.children)` で交差するオブジェクトのリストを取得します。

- **色変更**:
  交差リストが空でない場合、一番手前（インデックス0）のオブジェクトのマテリアルの色をランダムに変更します。

## 6. ヒント

- **ヒント 1（準備）**:
  判定を行うには `raycaster = new THREE.Raycaster()` と `mouse = new THREE.Vector2()` の 2 つが必要です。
- **ヒント 2（座標の正規化）**:
  マウス座標を「左上が(-1, 1)、右下が(1, -1)」になるように変換します。
  `x = (clientX / w) * 2 - 1`
  `y = -(clientY / h) * 2 + 1`
  この公式は暗記するか、スニペットとして持っておきましょう。
- **ヒント 3（交差判定）**:
  `raycaster.intersectObjects(scene.children)` を実行すると、光線に当たった全てのオブジェクトが「手前から順に」配列で返ってきます。
- **ヒント 4（取得）**:
  配列の先頭 `intersects[0]` が一番手前にあるオブジェクトです。その中の `.object` プロパティに実際のメッシュが入っています。
- **ヒント 5（ランダム色）**:
  `Math.random() * 0xffffff` でランダムな整数（色コード）を生成できます。それを `material.color.set()` に渡せば OK です。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);

camera.position.z = 5;

// --- ここでRaycasterなどの準備 ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("click", (event) => {
  // --- ここでクリック判定処理を記述 ---
});

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);

camera.position.z = 5;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("click", (event) => {
  // 1. マウス座標の正規化 (-1 から +1 の範囲に変換)
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // 2. カメラからマウス位置に向けて光線をセット
  raycaster.setFromCamera(mouse, camera);

  // 3. シーン内のオブジェクトとの交差判定
  const intersects = raycaster.intersectObjects(scene.children);

  if (intersects.length > 0) {
    // 交差した最初のオブジェクト（一番手前）を取得
    const object = intersects[0].object;

    // 色をランダムに変更
    object.material.color.set(Math.random() * 0xffffff);
  }
});

function animate() {
  requestAnimationFrame(animate);

  // 少し回転させておく
  cube.rotation.x += 0.005;
  cube.rotation.y += 0.005;

  renderer.render(scene, camera);
}
animate();
```
