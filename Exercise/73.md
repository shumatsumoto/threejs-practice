## 1. 問題タイトル

73 本目：リフレクション（Reflector）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `Reflector` クラスの使用方法
- 平面鏡の作成
- 床面への映り込み表現

## 3. 新しい概念の解説

**Planar Reflection (平面反射)**
床や鏡のような「平らな面」での反射には、`Reflector` クラスを使うのが効率的です。
`CubeCamera` のように6方向をレンダリングするのではなく、鏡像変換行列を使って「鏡の中の世界」を一度だけレンダリングするため、比較的高速で綺麗な反射が得られます。

```javascript
import { Reflector } from 'three/examples/jsm/objects/Reflector';

const mirror = new Reflector(new THREE.PlaneGeometry(10, 10), {
  clipBias: 0.003,
  textureWidth: window.innerWidth * window.devicePixelRatio,
  textureHeight: window.innerHeight * window.devicePixelRatio,
  color: 0x888888 // 反射の色味（少し暗くするとリアル）
});

scene.add(mirror);
```

## 4. 課題の説明

床面に鏡面反射（リフレクション）を追加し、上に置かれた物体が床に映り込むようにしてください。
`CubeCamera` は全方向ですが、`Reflector` は平面専用の軽量な反射実装です。

## 5. 必須要件

以下の機能を実装してください。

- **Reflector のインポート**:
  `three/examples/jsm/objects/Reflector` からインポートします。

- **鏡の作成**:
  `PlaneGeometry(10, 10)` を用意し、オプション設定（`clipBias: 0.003`, `textureWidth`, `height` 等）と共に `new Reflector(geom, options)` を作成します。
  `reflection.rotation.x = -Math.PI / 2` で床のように水平に配置します。
  色は `0x888888` 程度にしておくと反射が見やすくなります。

- **シーン構築**:
  鏡の上に適当なオブジェクト（回転するボックスなど）を浮かせて配置し、床に鏡像が映ることを確認します。

## 6. ヒント

- **ヒント 1（必要なクラスのインポート）**:
  `Reflector` を使用します。
  `three/examples/jsm/objects/Reflector` からインポートしてください。
- **ヒント 2（ジオメトリ）**:
  鏡面反射は平面で行うため、必ず `PlaneGeometry` を使用します。
  `BoxGeometry` などでは正しく動作しません。
- **ヒント 3（オプション設定）**:
  `new Reflector(geometry, options)` の `options` で画質や色を調整できます。
  `textureWidth`, `textureHeight` は `window.innerWidth * window.devicePixelRatio` などにして画面解像度に合わせると綺麗です。
- **ヒント 4（クリップバイアス）**:
  `clipBias: 0.003` 程度を設定すると、面が重なった時のチラつき（Zファイティング）やアーティファクトを防げます。
- **ヒント 5（配置）**:
  デフォルトでは XY 平面に立ち上がった状態で作られるため、床にするには `rotation.x = -Math.PI / 2` で寝かせる必要があります。

## 7. スターターコード

```javascript
import * as THREE from "three";
// import { Reflector } ...

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const box = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
box.position.y = 1;
scene.add(box);

// --- ここでReflectorを作成 ---
// const mirror = new Reflector(geometry, options);
// mirror.rotation.x = -Math.PI / 2;
// scene.add(mirror);

camera.position.set(0, 3, 5);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  box.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { Reflector } from "three/examples/jsm/objects/Reflector";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 物体
const box = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
box.position.y = 1;
scene.add(box);

// 鏡の床
const geometry = new THREE.PlaneGeometry(10, 10);
const mirror = new Reflector(geometry, {
  clipBias: 0.003,
  textureWidth: window.innerWidth * window.devicePixelRatio,
  textureHeight: window.innerHeight * window.devicePixelRatio,
  color: 0x888888, // 少し暗くして反射っぽくする
});

mirror.rotation.x = -Math.PI / 2;
mirror.position.y = -0.5;
scene.add(mirror);

camera.position.set(0, 3, 5);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  box.rotation.y += 0.01;
  box.rotation.x += 0.01;

  renderer.render(scene, camera);
}
animate();
```
