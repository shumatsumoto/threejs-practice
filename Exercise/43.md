## 1. 問題タイトル

43 本目：BufferGeometry の使用（大量のパーティクル）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `BufferGeometry` を使った大量の点の描画
- `Points` と `PointsMaterial` の組み合わせ
- ランダムな座標生成

## 3. 新しい概念の解説

**Particle System（パーティクルシステム）**
`Sprite` などのオブジェクトを個別に作成すると、数が 1000 個を超えたあたりで処理落ちし始めます。
`BufferGeometry` に全ての頂点を詰め込み、`Points` として 1 回で描画することで、数万〜数十万個のパーティクルを高速に表示できます。

```javascript
const count = 1000;
const positions = new Float32Array(count * 3);

// ランダムな位置を生成
for (let i = 0; i < count * 3; i++) {
  positions[i] = (Math.random() - 0.5) * 10;
}
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

// Pointsとして描画
const particles = new THREE.Points(
  geometry,
  new THREE.PointsMaterial({ size: 0.1, color: 0xffffff })
);
```

## 4. 課題の説明

1000 個の点をランダムな位置に配置し、星空のようなパーティクルシステムを作成してください。
`Sprite` を 1000 個作るのではなく、1 つの `BufferGeometry` に 1000 個分の頂点データを格納して描画する、パフォーマンスに優れた方法を使います。

## 5. 必須要件

以下の機能を実装してください。

- **大量の頂点生成**:
  `BufferGeometry` を作成し、1000個以上の頂点データを格納できる `Float32Array` を用意します（サイズは 個数 * 3）。
  ループ処理でランダムな座標（範囲 -10 〜 10 など）を代入します。

- **Points オブジェクト**:
  `Mesh` ではなく、`THREE.Points` クラスを使用してインスタンス化します。

- **マテリアル設定**:
  `THREE.PointsMaterial` を使用し、`size` プロパティでドットの大きさを調整します。
  `sizeAttenuation: true`（デフォルト）により、遠近感のある表示にします。

- **描画確認**:
  シーン内に大量の点が星空や粉塵のように散らばって表示されることを確認します。

## 6. ヒント

- **ヒント 1（Pointsクラス）**:
  `Mesh` は三角形の集合体を表示するものですが、頂点（点）そのものを表示するには `THREE.Points` を使います。
- **ヒント 2（PointsMaterial）**:
  点用のマテリアルです。`size` プロパティで点の大きさを制御できます。
  `sizeAttenuation: true`（デフォルト）にすると、遠くの点は小さく表示され、遠近感が生まれます。
- **ヒント 3（配列のサイズ）**:
  1000 個の点を作るなら、配列の長さは `1000 * 3`（XYZ 成分）= 3000 になります。
- **ヒント 4（ランダム配置）**:
  `(Math.random() - 0.5) * 範囲` を使うと、原点を中心にプラスマイナス均等に散らばらせることができます。
- **ヒント 5（ジオメトリ）**:
  三角形の面を作る必要はないので、`index`（頂点インデックス）の設定は不要です。`position` 属性だけで描画できます。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- ここでジオメトリとパーティクルを作成 ---
// const geometry = new THREE.BufferGeometry();
// const count = 1000;
// const positions = new Float32Array(count * 3);
// ...

camera.position.z = 15;

function animate() {
  requestAnimationFrame(animate);
  // 回転させると綺麗
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BufferGeometry();
const count = 1000;
const positions = new Float32Array(count * 3);

for (let i = 0; i < count * 3; i++) {
  // -10 から 10 の範囲でランダム
  positions[i] = (Math.random() - 0.5) * 20;
}

geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

const material = new THREE.PointsMaterial({
  color: 0xffffff,
  size: 0.1,
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

camera.position.z = 15;

function animate() {
  requestAnimationFrame(animate);

  particles.rotation.y += 0.002;
  particles.rotation.x += 0.001;

  renderer.render(scene, camera);
}
animate();
```
