## 1. 問題タイトル

98 本目：マルチプレイヤーの準備（同期の概念）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 状態（State）と描画（View）の分離
- プレイヤーデータの管理
- サーバーからのデータ受信を想定した更新処理

## 3. 新しい概念の解説

**State Sync (状態同期)**
マルチプレイヤーゲームでは、サーバーから送られてくる「現在のゲーム状態（各プレイヤーの位置など）」をクライアント側（Three.js）に反映させる処理が必要です。
「サーバーにある ID がクライアントに無ければ生成」「あれば位置更新」「サーバーから消えていれば削除」という CRUD（Create, Read, Update, Delete）的なロジックを毎フレーム（またはデータ受信時）に行うことで、画面上の表示を同期させます。

```javascript
const meshes = {}; // IDとメッシュの対応表

function update(serverData) {
  // 1. 作成と更新
  for (const id in serverData) {
    if (!meshes[id]) {
      // 新規作成
      meshes[id] = createPlayerMesh();
      scene.add(meshes[id]);
    }
    // 位置同期
    meshes[id].position.copy(serverData[id].position);
  }

  // 2. 削除
  for (const id in meshes) {
    if (!serverData[id]) {
      // サーバーに無いなら消す
      scene.remove(meshes[id]);
      delete meshes[id];
    }
  }
}
```

## 4. 課題の説明

実際にサーバーとは通信しませんが、マルチプレイヤーゲームのように「他のプレイヤーの情報」を受け取って画面に表示する仕組みを作成してください。
`players` というオブジェクト（辞書）に、ID をキーとして位置情報などが格納されていると仮定し、それを元に 3D キャラクターを生成・移動・削除します。

## 5. 必須要件

以下の機能を実装してください。

- **プレイヤー管理用変数**:
  現在表示されているメッシュを管理するためのオブジェクト `playerMeshes = {}` を用意します。

- **同期関数 `updatePlayers(serverData)` の実装**:
  この関数は「サーバーから送られてきたデータ（IDと座標）」を受け取り、画面を同期させます。
  1. **作成と更新**: `serverData` の各 ID についてループします。
     - `playerMeshes[id]` が存在しない場合 → 新規メッシュを作成し、`scene.add` して `playerMeshes` に登録します。
     - 現在の座標データを使って、メッシュの位置（`mesh.position`）を更新します。
  2. **削除**: `playerMeshes` の各 ID についてループします。
     - `serverData[id]` が存在しない（サーバー側から消えた）場合 → `scene.remove` し、`playerMeshes` からも削除します。

- **動作テスト**:
  `setInterval` を使って、擬似的なサーバーデータ（ランダムに動く座標を持つオブジェクト）を定期的（100ms毎など）に生成し、`updatePlayers` に渡して動きを確認します。

## 6. ヒント

- **ヒント 1（データ構造）**:
  プレイヤー管理は配列よりもオブジェクト（辞書型）が便利です。
  `players[id] = mesh;` のように ID で直感的にアクセスできます。
- **ヒント 2（更新ロジック）**:
  1. サーバーデータのキーをループして、`create` or `update`。
  2. ローカルデータのキーをループして、サーバーに存在しなければ `delete`。
  この 2 パスで行うのが確実です。
- **ヒント 3（切断検出）**:
  `if (!serverData.hasOwnProperty(localId)) { remove... }`
  サーバーから送られてこなくなった ID は、切断されたプレイヤーとみなして削除します。
- **ヒント 4（補間）**:
  `mesh.position.set(x, 0, z)` で瞬時に移動させるとカクカクします。
  本番では `mesh.position.lerp(targetPos, 0.1)` のように少し遅れて滑らかに移動させる技術が使われます。
- **ヒント 5（一意なキー）**:
  今回はランダム ID ですが、本来は `socket.id` などのユニークな識別子を使います。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const playerMeshes = {}; // ID -> Mesh

function updatePlayers(serverData) {
  // 1. 新規作成 & 更新
  // 2. 削除判定
}

// 疑似サーバーデータ更新
setInterval(() => {
  const mockData = {
    p1: { x: Math.random(), z: Math.random() },
    p2: { x: Math.random(), z: Math.random() },
  };
  updatePlayers(mockData);
}, 100);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const playerMeshes = {}; // 現在表示中のメッシュ管理

function updatePlayers(serverData) {
  // サーバーデータにあるIDを処理
  for (const id in serverData) {
    const data = serverData[id];

    if (!playerMeshes[id]) {
      // 新規プレイヤー
      const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      const material = new THREE.MeshNormalMaterial();
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);
      playerMeshes[id] = mesh;
    }

    // 位置更新
    const mesh = playerMeshes[id];
    mesh.position.set(data.x, 0, data.z);
  }

  // サーバーデータにないIDを削除
  for (const id in playerMeshes) {
    if (!serverData[id]) {
      scene.remove(playerMeshes[id]);
      delete playerMeshes[id];
    }
  }
}

// 疑似サーバー
let mockData = {
  user1: { x: 0, z: 0 },
  user2: { x: 2, z: 0 },
};

setInterval(() => {
  // ランダムに動かす
  for (const id in mockData) {
    mockData[id].x += (Math.random() - 0.5) * 0.5;
    mockData[id].z += (Math.random() - 0.5) * 0.5;
  }

  // たまに増減させる
  if (Math.random() < 0.05) {
    const newId = "user" + Math.floor(Math.random() * 1000);
    mockData[newId] = { x: 0, z: 0 };
  }
  if (Math.random() < 0.05) {
    const ids = Object.keys(mockData);
    if (ids.length > 0) delete mockData[ids[0]];
  }

  updatePlayers(mockData);
}, 100);

camera.position.set(0, 5, 10);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```
