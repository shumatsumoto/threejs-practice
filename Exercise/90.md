## 1. 問題タイトル

90 本目：インベントリシステムの UI（HTML 連携）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- HTML/CSS による UI オーバーレイ
- 3D アイテムのアイコン化（または 3D 表示）
- ドラッグ＆ドロップによるアイテム操作の概念

## 3. 新しい概念の解説

**3D to 2D Interaction (3Dと2Dの連携)**
3D 空間（Canvas）と 2D UI（HTML DOM）を連携させる演習です。
`Raycaster` でのクリックイベントをトリガーとして、3D オブジェクトの状態（表示・非表示など）を変更し、同時に HTML 要素（アイコンなど）を生成・削除・更新することで、インベントリシステムや HUD（Head-Up Display）を構築します。

```javascript
// 3Dアイテムをクリックした時の処理
if (intersects.length > 0) {
  const obj = intersects[0].object;
  obj.visible = false; // シーンから消す
  
  // HTML側（インベントリ）に要素を追加
  const uiItem = document.createElement('div');
  uiItem.innerText = obj.userData.name;
  uiItem.onclick = () => {
    // 戻すロジック
    obj.visible = true;
    inventory.removeChild(uiItem);
  };
  inventory.appendChild(uiItem);
}
```

## 4. 課題の説明

画面下部に「インベントリ（アイテム欄）」を表示し、3D 空間内のアイテムをクリックすると、そのアイテムがインベントリに追加されるシステムを作成してください。
今回は簡易的に、クリックされた 3D オブジェクトを非表示にし、HTML 側にアイコン（または名前）を追加します。

## 5. 必須要件

以下の機能を実装してください。

- **UI作成**:
  HTML でインベントリ用の領域を作成し、画面下部に配置します（CSS `position: absolute`）。

- **アイテム配置**:
  シーン内に「拾えるアイテム」として複数のメッシュを配置し、それぞれに `userData: { name: "Item A" }` などの情報を持たせます。

- **ピッキング（拾う処理）**:
  クリックイベント時に `Raycaster` でアイテムを判定します。
  ヒットしたら、そのアイテムを `visible = false` にして隠します。
  同時に、`document.createElement('div')` で UI 要素を作成し、インベントリ領域に追加します。

- **ドロップ（戻す処理）**:
  インベントリ内の UI 要素がクリックされたら、対応するアイテムを `visible = true` に戻し、プレイヤーの目の前などに再配置して、UI 要素を削除します。
  これを実現するために、UI 要素の `onclick` 関数内でアイテムの参照を保持しておきます（クロージャ）。

## 6. ヒント

- **ヒント 1（HTML構成）**:
  `canvas` 要素の上に UI を乗せるため、UI のコンテナには `position: absolute`、`pointer-events: none`（全体）、ボタンなどのクリック要素には `pointer-events: auto` を設定すると、誤操作を防ぎやすいです。
- **ヒント 2（状態管理）**:
  3D オブジェクト自体を消去（dispose）してしまうと、戻す時に再生成が必要です。
  `visible = false` にして隠すだけにするのが最も簡単な「インベントリ格納」の実装です。
- **ヒント 3（関連付け）**:
  HTML のアイコン要素（`div`）の `onclick` ハンドラ内で、隠しておいた元々の 3D オブジェクト（`mesh`）を参照できるように、クロージャ（関数スコープ）を利用します。
- **ヒント 4（Raycasterの貫通）**:
  UI 上をクリックした時にも Raycaster が反応してしまうことがあります。
  `if (event.target !== renderer.domElement) return;` のように、イベント発生元をチェックして弾きましょう。
- **ヒント 5（アイコン生成）**:
  `document.createElement('img')` で画像を表示したり、Canvas で描画したサムネイルを使うとより本格的になります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// UI作成
const ui = document.createElement("div");
ui.style.position = "absolute";
ui.style.bottom = "0";
ui.style.width = "100%";
ui.style.height = "100px";
ui.style.backgroundColor = "rgba(0,0,0,0.5)";
ui.style.display = "flex";
document.body.appendChild(ui);

// アイテム配置
const items = [];
// ...

// クリックイベント
window.addEventListener("click", (e) => {
  // Raycaster判定
  // ...
  // addToInventory(object);
});

function addToInventory(obj) {
  obj.visible = false;
  const icon = document.createElement("div");
  icon.innerText = "Item";
  icon.style.color = "white";
  icon.style.margin = "10px";
  icon.onclick = () => {
    // 戻す処理
  };
  ui.appendChild(icon);
}

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// UI
const inventory = document.createElement("div");
inventory.style.position = "absolute";
inventory.style.bottom = "10px";
inventory.style.left = "50%";
inventory.style.transform = "translateX(-50%)";
inventory.style.width = "80%";
inventory.style.height = "80px";
inventory.style.backgroundColor = "rgba(50, 50, 50, 0.8)";
inventory.style.display = "flex";
inventory.style.alignItems = "center";
inventory.style.justifyContent = "center";
inventory.style.border = "2px solid white";
document.body.appendChild(inventory);

// アイテム
const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
const material = new THREE.MeshNormalMaterial();
const items = [];

for (let i = 0; i < 3; i++) {
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.x = (i - 1) * 2;
  mesh.userData = { id: i, name: `Box ${i + 1}` };
  scene.add(mesh);
  items.push(mesh);
}

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("click", (event) => {
  // UI上のクリックは無視（簡易実装）
  if (event.target !== renderer.domElement) return;

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(items);

  if (intersects.length > 0) {
    const obj = intersects[0].object;
    if (obj.visible) {
      addToInventory(obj);
    }
  }
});

function addToInventory(obj) {
  obj.visible = false;

  const slot = document.createElement("div");
  slot.innerText = obj.userData.name;
  slot.style.width = "60px";
  slot.style.height = "60px";
  slot.style.backgroundColor = "#888";
  slot.style.margin = "5px";
  slot.style.display = "flex";
  slot.style.alignItems = "center";
  slot.style.justifyContent = "center";
  slot.style.cursor = "pointer";
  slot.style.color = "white";

  slot.onclick = () => {
    obj.visible = true;
    obj.position.set(0, 0, 2); // 手前に出現
    inventory.removeChild(slot);
  };

  inventory.appendChild(slot);
}

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  items.forEach((item) => {
    if (item.visible) {
      item.rotation.x += 0.01;
      item.rotation.y += 0.01;
    }
  });
  renderer.render(scene, camera);
}
animate();
```
