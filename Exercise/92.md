## 1. 問題タイトル

92 本目：衝突判定システム（自作）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- AABB（軸平行境界ボックス）による衝突判定
- `Box3` クラスの使用方法
- 物理エンジンを使わない簡易的な当たり判定

## 3. 新しい概念の解説

**AABB Collision Detection (AABB衝突判定)**
AABB (Axis-Aligned Bounding Box) は、「軸に平行な境界ボックス」のことです。
回転を考慮しないため計算が非常に高速で、`Box3` クラスを使って簡単に利用できます。
「移動する前に、移動先の位置で衝突するかどうか」を事前にチェック（投機的実行）することで、壁にめり込むのを防ぐことができます。

```javascript
/* moveVector 分だけ移動しようとした時の未来の位置で判定 */

// プレイヤーの現在のボックスを取得
const playerBox = new THREE.Box3().setFromObject(player);

// ボックスだけ先に移動させる（投機的移動）
playerBox.translate(moveVector);

// 壁のボックス
const wallBox = new THREE.Box3().setFromObject(wall);

// 交差判定
if (playerBox.intersectsBox(wallBox)) {
  // 衝突するので移動をキャンセル
  console.log("Hit!");
} else {
  // 衝突しないので実際に移動
  player.position.add(moveVector);
}
```

## 4. 課題の説明

物理エンジンを使わずに、プレイヤー（キューブ）が壁（キューブ）にぶつかったらそれ以上進めなくなる処理を実装してください。
Three.js の `Box3` を使うと、オブジェクトの境界ボックス（バウンディングボックス）を簡単に取得し、交差判定を行えます。

## 5. 必須要件

以下の機能を実装してください。

- **オブジェクトの配置**:
  - `player`: `BoxGeometry(1, 1, 1)` のメッシュを作成。（操作キャラ）
  - `wall`: `BoxGeometry(2, 2, 2)` のメッシュを作成し、少し離れた位置（例: x=3）に配置。（障害物）
  - `BoxHelper` を使って両方の AABB（当たり判定ボックス）を可視化する（任意だが推奨）。

- **キーボード入力の監視**:
  `keydown`, `keyup` イベントを使って、矢印キーが押されている間フラグ（`keys['ArrowUp'] = true` など）を管理します。

- **投機的な衝突判定（重要）**:
  アニメーションループ内で移動処理を行う際、いきなり `player.position` を更新してはいけません。
  1. 移動量（`dx`, `dz`）を計算する。
  2. `tempBox`（判定用ボックス）を作成し、`player` からコピーする（`setFromObject`）。
  3. `tempBox` だけを**仮想的に移動**させる（`translate`）。
  4. `wallBox`（壁のボックス）を作成し、`wall` からコピーする。
  5. `tempBox.intersectsBox(wallBox)` が `true` かどうか確認する。

- **移動の確定**:
  衝突判定が `false`（ぶつからない）だった場合のみ、実際に `player.position` に移動量を加算して移動させます。
  `true` だった場合は移動を行いません（壁の手前で止まる）。

## 6. ヒント

- **ヒント 1（投機的実行）**:
  「動かしてから戻す」のではなく、「動かす前に仮想ボックスで判定する」のがコツです。
  `const tempBox = new THREE.Box3().setFromObject(player);`
  `tempBox.translate(velocity);`
- **ヒント 2（Box3の仕様）**:
  `setFromObject` は現在のワールド座標における境界ボックスを計算します。
  回転した箱の場合、AABB はそれを包み込む大きな箱になるため、斜めの壁などの判定には不向きです（隙間ができる）。
- **ヒント 3（デバッグ表示）**:
  `new THREE.BoxHelper(object, color)` をシーンに追加すると、実際に判定されているボックスが可視化され、デバッグが圧倒的に楽になります。
- **ヒント 4（交差判定）**:
  `boxA.intersectsBox(boxB)` は、少しでも重なっていれば `true` を返します。
  今回は `true` なら移動しない、というロジックで壁ずりを行わず単純に停止させます。
- **ヒント 5（パフォーマンス）**:
  `setFromObject` は頂点を全走査するため少し重いです。
  頻繁に形状が変わらないなら、初期化時にサイズを測っておき、位置だけ更新する方が高速です。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const player = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
scene.add(player);

const wall = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshBasicMaterial({ color: 0xff0000 })
);
wall.position.set(3, 0, 0);
scene.add(wall);

const keys = {};
document.addEventListener("keydown", (e) => (keys[e.code] = true));
document.addEventListener("keyup", (e) => (keys[e.code] = false));

camera.position.set(0, 5, 5);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  // --- 移動と衝突判定 ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const player = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
scene.add(player);

const wall = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshBasicMaterial({ color: 0xff0000 })
);
wall.position.set(3, 0, 0);
scene.add(wall);

// 境界ボックスのヘルパー（可視化用）
const playerBoxHelper = new THREE.BoxHelper(player, 0xffff00);
scene.add(playerBoxHelper);
const wallBoxHelper = new THREE.BoxHelper(wall, 0xff00ff);
scene.add(wallBoxHelper);

const keys = {};
document.addEventListener("keydown", (e) => (keys[e.code] = true));
document.addEventListener("keyup", (e) => (keys[e.code] = false));

camera.position.set(0, 10, 0);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  let dx = 0;
  let dz = 0;
  if (keys["ArrowUp"]) dz = -0.1;
  if (keys["ArrowDown"]) dz = 0.1;
  if (keys["ArrowLeft"]) dx = -0.1;
  if (keys["ArrowRight"]) dx = 0.1;

  if (dx !== 0 || dz !== 0) {
    // 移動後の位置を計算（実際にはまだ動かさない）
    const nextPosition = player.position
      .clone()
      .add(new THREE.Vector3(dx, 0, dz));

    // 移動後のボックスを作成
    const tempBox = new THREE.Box3().setFromObject(player);
    // Box3はワールド座標系なので、移動分を適用する
    tempBox.translate(new THREE.Vector3(dx, 0, dz));

    // 壁のボックス
    const wallBox = new THREE.Box3().setFromObject(wall);

    // 衝突判定
    if (!tempBox.intersectsBox(wallBox)) {
      // 衝突しないなら移動
      player.position.copy(nextPosition);
    } else {
      // 衝突！
      console.log("Hit!");
    }
  }

  playerBoxHelper.update();

  renderer.render(scene, camera);
}
animate();
```
