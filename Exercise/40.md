## 1. 問題タイトル

40 本目：動的な Canvas テクスチャ（アニメーション）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- Canvas の内容をリアルタイムに更新する方法
- `texture.needsUpdate = true` の重要性
- 3D 空間に「動く 2D 情報（時計など）」を表示する技術

## 3. 新しい概念の解説

**Dynamic Texture Update（動的な更新）**
CanvasTexture は、作成後も中身を書き換えることができます。
ただし、Three.js はパフォーマンスのために自動更新を行いません。
Canvas の内容を変更した後は、必ず `texture.needsUpdate = true` というフラグを立てて、GPU に「テクスチャが変わったから再読み込みしてね」と伝える必要があります。

```javascript
function animate() {
  requestAnimationFrame(animate);

  // Canvasの中身を書き換え
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, 256, 256);
  ctx.fillStyle = 'black';
  ctx.fillText(Date.now(), 100, 100);

  // 【重要】更新フラグを立てる
  texture.needsUpdate = true;

  renderer.render(scene, camera);
}
```

## 4. 課題の説明

演習 39 の応用です。
Canvas に現在の時刻（秒数など）を描画し続け、それがリアルタイムに反映される「デジタル時計のようなキューブ」を作成してください。
テクスチャは一度作ったら終わりではなく、中身を書き換えて更新することができます。

## 5. 必須要件

以下の機能を実装してください。

- **Canvasの更新関数**:
  現在の時刻（`new Date()`）を取得し、一度 `clearRect` または `fillRect` で画面をクリアしてから、新しい時間を描画する関数を作成します。

- **アニメーションループ内での呼び出し**:
  `animate` 関数の中で上記の更新関数を呼び出します。

- **テクスチャの更新**:
  Canvas への描画が終わった直後に、必ず `texture.needsUpdate = true` を設定します。

- **動作確認**:
  キューブの表面に表示された時刻が、毎秒（または毎フレーム）更新されて動いていることを確認します。

## 6. ヒント

- **ヒント 1（needsUpdate）**:
  これが最も重要です。
  `texture.needsUpdate = true;` を設定したフレームでのみ、GPU へのテクスチャ再転送が行われます。これを忘れると表示が変わりません。
- **ヒント 2（背景クリア）**:
  毎回 `ctx.fillRect()` で背景全体を塗りつぶしてください。
  これを行わないと、前のフレームの文字が残ったまま新しい文字が上書きされ、真っ黒な塊になってしまいます。
- **ヒント 3（更新頻度）**:
  毎フレーム更新（60fps）は結構重い処理です。
  時計レベルなら「1秒に1回だけ更新する」ように制御すると、パフォーマンスが向上します（今回は毎フレームでOK）。
- **ヒント 4（時刻取得）**:
  `new Date()` で現在時刻オブジェクトを取得し、`.getHours()` `.getMinutes()` `.getSeconds()` で数値を取り出せます。
- **ヒント 5（ちらつき）**:
  もし描画がチラつく場合は、Canvas のサイズが 2 の累乗（256, 512, 1024）になっているか確認すると良いでしょう（Mipmap 生成のため）。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Canvas作成
const canvas = document.createElement("canvas");
canvas.width = 256;
canvas.height = 256;
const ctx = canvas.getContext("2d");

const texture = new THREE.CanvasTexture(canvas);
const cube = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshBasicMaterial({ map: texture })
);
scene.add(cube);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // --- ここでCanvasを更新 ---
  // 1. 背景クリア
  // 2. 文字描画（Date.now()など）
  // 3. texture.needsUpdate = true;

  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const canvas = document.createElement("canvas");
canvas.width = 256;
canvas.height = 256;
const ctx = canvas.getContext("2d");

const texture = new THREE.CanvasTexture(canvas);
const cube = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshBasicMaterial({ map: texture })
);
scene.add(cube);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // 1. 背景をリセット（塗りつぶし）
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, 0, 256, 256);

  // 2. 現在時刻を描画
  const date = new Date();
  const timeStr =
    date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();

  ctx.font = "bold 40px Arial";
  ctx.fillStyle = "#ff0000";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(timeStr, 128, 128);

  // 3. テクスチャの更新フラグを立てる（必須！）
  texture.needsUpdate = true;

  // キューブを回転
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;

  renderer.render(scene, camera);
}
animate();
```
