## 1. 問題タイトル

55 本目：時間変化するシェーダー（点滅・変色）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 三角関数（sin, cos）を使った周期的な変化
- 色の成分ごとの操作
- ゲーミング PC のような虹色変化の実装

## 3. 新しい概念の解説

**Trigonometric Cycles（三角関数の周期変化）**
`sin(time)` を使うと、-1.0 から 1.0 の間で値が滑らかに行き来します。
これを `0.5 + 0.5 * sin(time)` のように加工して 0.0〜1.0 の範囲にし、色の成分（RGB）に割り当てることで、点滅や虹色変化のような周期的なアニメーションを作れます。

```javascript
const fShader = `
  uniform float uTime;
  void main() {
    // 時間によって色が変化するゲーミングカラー
    float r = 0.5 + 0.5 * sin(uTime);
    float g = 0.5 + 0.5 * sin(uTime + 2.0); // 位相をずらす
    float b = 0.5 + 0.5 * sin(uTime + 4.0);
    gl_FragColor = vec4(r, g, b, 1.0);
  }
`;
```

## 4. 課題の説明

キューブの色が時間とともに滑らかに変化する（赤 → 緑 → 青 → 赤...）シェーダーを作成してください。
`uTime` を使い、RGB の各成分を位相をずらしたサイン波で制御します。

## 5. 必須要件

以下の機能を実装してください。

- **周期計算**:
  フラグメントシェーダーで `uTime` を受け取ります。
  RGB それぞれの成分に対して、位相をずらしたサイン波を計算します。
  - `r = sin(uTime)`
  - `g = sin(uTime + 2.0)`
  - `b = sin(uTime + 4.0)`

- **正規化と出力**:
  `sin` の結果は -1〜1 なので、`val * 0.5 + 0.5` で 0〜1 に変換します。
  これを `gl_FragColor` に設定し、色がスムースに循環する虹色エフェクトを作る。

## 6. ヒント

- **ヒント 1（波の加工）**:
  `sin(t)` は -1.0 〜 1.0 の値を返しますが、色は 0.0 〜 1.0 である必要があります。
  `sin(t) * 0.5 + 0.5` という計算式を使うと、-0.5〜0.5 になり、さらに 0.5 足されることで 0.0〜1.0 の範囲に綺麗に収まります。
- **ヒント 2（位相のズレ）**:
  RGB すべてに同じ `sin(uTime)` を使うと、単に明滅するグレーになります。
  `sin(uTime + 2.0)` や `sin(uTime + 4.0)` のように入力値（時間）を少しずらすことで、R・G・B のピークがずれて虹色に見えます。
- **ヒント 3（ベクトルの計算）**:
  GLSL では `vec3(0.5) + vec3(0.5) * cos(uTime + vec3(0, 2, 4))` のように、ベクトル単位でまとめて計算することもできます（上級者向け）。
- **ヒント 4（デバッグ）**:
  もし色が真っ黒のまま変わらない場合は、JS 側で `material.uniforms.uTime.value` を更新し忘れているか、ユニフォーム名のスペルミス（`time` vs `uTime`）の可能性が高いです。
- **ヒント 5（速度調整）**:
  点滅が速すぎる場合は `sin(uTime * 0.5)` のように時間を掛け算で小さくして減速させます。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

const fShader = `
    uniform float uTime;
    void main() {
        // --- ここで色を計算 ---
        
        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }
`;

const uniforms = { uTime: { value: 0.0 } };
const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  uniforms: uniforms,
});

const cube = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), material);
scene.add(cube);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  material.uniforms.uTime.value += 0.05;
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

const fShader = `
    uniform float uTime;
    void main() {
        // 0.5 + 0.5 * sin(...) で 0〜1 の範囲にする
        float r = 0.5 + 0.5 * sin(uTime);
        float g = 0.5 + 0.5 * sin(uTime + 2.0); // 位相をずらす
        float b = 0.5 + 0.5 * sin(uTime + 4.0);
        
        gl_FragColor = vec4(r, g, b, 1.0);
    }
`;

const uniforms = { uTime: { value: 0.0 } };
const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  uniforms: uniforms,
});

const cube = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), material);
scene.add(cube);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  material.uniforms.uTime.value += 0.05;
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```
