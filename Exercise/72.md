## 1. 問題タイトル

72 本目：反射プローブ（CubeCamera）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `CubeCamera` の使用方法
- リアルタイム反射（動的な環境マップ）
- 鏡のような物体の作成

## 3. 新しい概念の解説

**CubeCamera & Dynamic Reflections（キューブカメラと動的反射）**
静的な環境マップ（画像）ではなく、「シーン内の今の状況」をリアルタイムに映り込ませたい場合に使われます。
`CubeCamera` は前後左右上下の6方向を撮影し、それをテクスチャとしてマテリアルに適用することで、動く物体も正しく反射させることができます。
計算負荷が高いため、使用には注意が必要です。

```javascript
// レンダーターゲットとカメラの作成
const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
scene.add(cubeCamera);

// マテリアルのenvMapに動的テクスチャを設定
const material = new THREE.MeshStandardMaterial({
  envMap: cubeRenderTarget.texture,
  metalness: 1.0,
  roughness: 0.0
});

function animate() {
  // 撮影時は自分自身（鏡）を消すことで、無限反射などのバグを防ぐ
  sphere.visible = false;
  
  // カメラ位置をオブジェクトに合わせて更新
  cubeCamera.position.copy(sphere.position);
  cubeCamera.update(renderer, scene);
  
  sphere.visible = true;
  renderer.render(scene, camera);
}
```

## 4. 課題の説明

シーン内の他の物体をリアルタイムに映し込む「鏡の球体」を作成してください。
静的な環境マップではなく、`CubeCamera` を使って周囲の状況を毎フレーム撮影し、それをマテリアルの `envMap` として使用します。

## 5. 必須要件

以下の機能を実装してください。

- **CubeCamera のセットアップ**:
  1. `WebGLCubeRenderTarget(256)` を作成。（サイズは任意）
  2. `new THREE.CubeCamera(0.1, 1000, renderTarget)` を作成し、シーンに追加。

- **反射オブジェクト（鏡）**:
  球体を作成し、マテリアル (`MeshStandardMaterial` or `Basic`) の `envMap` に `renderTarget.texture` を設定します。
  金属感を出すために `roughness: 0`, `metalness: 1` に設定します。

- **更新ループ**:
  `animate` 関数内で以下を実行します。
  1. 反射オブジェクト自体を `visible = false` に隠す（自画撮り防止）。
  2. `cubeCamera.position.copy(sphere.position)` でカメラ位置を合わせる。
  3. `cubeCamera.update(renderer, scene)` で周囲を撮影。
  4. `visible = true` に戻す。

- **動く物体の配置**:
  鏡の周りを回るボックスなどを配置し、リアルタイムに映り込むことを確認します。

## 6. ヒント

- **ヒント 1（CubeCameraの仕組み）**:
  `WebGLCubeRenderTarget` にシーンの 6 方向の映像を描画し、それをテクスチャとして利用します。
  `cubeCamera.update(renderer, scene)` を呼ぶと撮影が行われます。
- **ヒント 2（自分自身の隠蔽）**:
  カメラが球体の中心にあるため、自分自身（球体）が映り込んで視界を遮らないよう、`sphere.visible = false` にしてから撮影し、すぐに `true` に戻します。
- **ヒント 3（マテリアル設定）**:
  `envMap` に `cubeRenderTarget.texture` を設定します。
  `roughness: 0`, `metalness: 1` の完全な金属設定にすると、鏡のように綺麗に反射します。
- **ヒント 4（解像度）**:
  `WebGLCubeRenderTarget(256)` などでサイズを指定します。
  大きくすると綺麗ですが、毎フレーム 6 回レンダリングするため負荷が高くなります。
- **ヒント 5（オブジェクトの位置合わせ）**:
  動く鏡を作る場合は、`cubeCamera.position.copy(mesh.position)` のように、常にカメラをオブジェクトと同じ位置に移動させる必要があります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 周囲の物体
const box = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
box.position.set(3, 0, 0);
scene.add(box);

// --- CubeCamera設定 ---
// const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
// const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
// scene.add(cubeCamera);

// 鏡の球体
// const material = new THREE.MeshStandardMaterial({ envMap: cubeRenderTarget.texture, ... });

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // 周囲の物体を動かす
  box.position.x = Math.sin(Date.now() * 0.001) * 3;
  box.position.z = Math.cos(Date.now() * 0.001) * 3;

  // --- ここでCubeCamera更新 ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 背景
scene.background = new THREE.Color(0x222222);

// 周囲を回る物体
const box = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
scene.add(box);

// 1. RenderTarget作成
const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256); // 解像度

// 2. CubeCamera作成
const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
scene.add(cubeCamera);

// 3. 鏡の球体
const material = new THREE.MeshStandardMaterial({
  envMap: cubeRenderTarget.texture,
  roughness: 0,
  metalness: 1,
});
const sphere = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 32), material);
scene.add(sphere);

camera.position.z = 5;
camera.position.y = 2;
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  // 周囲の物体を動かす
  const time = Date.now() * 0.001;
  box.position.x = Math.sin(time) * 3;
  box.position.z = Math.cos(time) * 3;
  box.rotation.x += 0.01;

  // 4. 反射の更新
  sphere.visible = false; // 自分自身は映らないように消す
  cubeCamera.position.copy(sphere.position); // カメラを球体の位置へ
  cubeCamera.update(renderer, scene); // 撮影
  sphere.visible = true; // 元に戻す

  renderer.render(scene, camera);
}
animate();
```
