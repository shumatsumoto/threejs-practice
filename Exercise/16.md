## 1. 問題タイトル

16 本目：テクスチャをキューブに貼り付け

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 立体物（BoxGeometry）へのテクスチャマッピング
- UV マッピング（画像がどう立体に貼り付くか）の基本理解

## 3. 新しい概念の解説

**UV Mapping（UVマッピング）**
3D モデルの表面に 2D 画像（テクスチャ）を貼り付ける際、「画像のどの部分を、モデルのどの面に貼るか」という対応関係のことです。
`BoxGeometry` などの標準ジオメトリには、最初から綺麗な UV 座標が設定されているので、簡単にてくすちゃを貼ることができます。

```javascript
// BoxGeometryはデフォルトで適切なUVを持っています
const geometry = new THREE.BoxGeometry(1, 1, 1);
// そのため、mapにテクスチャを指定するだけで綺麗に表示されます
const material = new THREE.MeshBasicMaterial({ map: texture });
```

## 4. 課題の説明

演習 15 で読み込んだテクスチャを、平面ではなく「回転するキューブ」に貼り付けてください。
木箱のような見た目のオブジェクトを作成します。

## 5. 必須要件

以下の機能を実装してください。

- **テクスチャ読み込み**:
  `TextureLoader` で木箱などの画像を読み込みます。

- **キューブ作成**:
  平面ではなく `BoxGeometry` を作成します。

- **マッピング**:
  マテリアルの `map` プロパティにテクスチャを設定します。

- **確認**:
  キューブを回転させ、6つの面すべてに同じ画像が貼り付けられていることを確認します（これがThree.jsのデフォルトの挙動です）。

## 6. ヒント

- **ヒント 1（UVマッピング）**:
  BoxGeometry はデフォルトで、6 つの面それぞれに画像全体がフィットするように設定されています。
  サイコロのように、各面に同じ画像が表示されます。
- **ヒント 2（汎用性）**:
  コード自体は Plane の時とほとんど変わりません。`geometry` を差し替えるだけでテクスチャが適用されるのが Three.js の便利な点です。
- **ヒント 3（ライトとの併用）**:
  `MeshStandardMaterial` を使い、`map: texture` を設定すれば、「陰影のあるテクスチャ付きボックス」になります。リアルな表現の第一歩です。
- **ヒント 4（画質設定）**:
  小さな画像を大きく拡大したり、逆に縮小表示した場合の「ぼやけ方」や「ドット感」は `magFilter` / `minFilter` プロパティで調整できます（今回はデフォルトでOK）。
- **ヒント 5（ジオメトリのサイズ）**:
  `BoxGeometry(1, 1, 1)` は 1単位のサイズですが、画像は自動的に引き伸ばされてフィットします。サイズを変えても画像配置は崩れません。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- テクスチャ読み込み ---
const loader = new THREE.TextureLoader();
const texture = loader.load("https://threejs.org/examples/textures/crate.gif");

// --- ここでキューブを作成し、テクスチャを貼ってください ---

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // --- 回転処理 ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const loader = new THREE.TextureLoader();
const texture = loader.load("https://threejs.org/examples/textures/crate.gif");

// BoxGeometryにテクスチャを貼る
const geometry = new THREE.BoxGeometry(2, 2, 2);
const material = new THREE.MeshBasicMaterial({ map: texture });
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // 回転させて全方向から確認
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;

  renderer.render(scene, camera);
}
animate();
```
