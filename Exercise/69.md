## 1. 問題タイトル

69 本目：トゥーンシェーディング（ToonMaterial）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `MeshToonMaterial` の使用方法
- `gradientMap`（階調マップ）による色の段階化
- アニメ調のレンダリング

## 3. 新しい概念の解説

**Toon Shading / Cel Shading（トゥーンシェーディング・セルルック）**
3D モデルを、アニメや手書きイラストのように見せるレンダリング手法です。
光の強さ（濃淡）を「滑らかなグラデーション」ではなく「段階的な色（明るい・普通・暗い）」に置き換えることで、セル画のようなパキッとした陰影を作ります。
`MeshToonMaterial` と段階的なテクスチャ（Gradient Map）を使います。

```javascript
// 3階調のテクスチャを作成（画像をロードしてもOK）
const texture = new THREE.CanvasTexture(canvas);

// 色を補間しない設定（重要：これがないとぼやける）
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;

const material = new THREE.MeshToonMaterial({
  color: 0x00aaff,
  gradientMap: texture // 階調マップを適用
});
```

## 4. 課題の説明

3D モデルをアニメのような「セル画調（トゥーンレンダリング）」で表示してください。
Three.js には標準で `MeshToonMaterial` が用意されていますが、綺麗な階調を出すには `gradientMap`（グラデーションテクスチャ）の設定が重要です。

## 5. 必須要件

以下の機能を実装してください。

- **階調テクスチャの作成**:
  Canvas API、または `Uint8Array` データテクスチャを使って、幅3〜4px・高さ1px の小さな階調画像（暗・中・明のグレー）を作成します。
  **重要**: `texture.minFilter` と `magFilter` を `THREE.NearestFilter` に設定します（補間無効化）。

- **Toonマテリアル**:
  `new THREE.MeshToonMaterial({ color: 0x55aaff, gradientMap: texture })` を作成し、トーラスノットなどの曲面メッシュに適用します。

- **ライティング**:
  陰影をはっきりさせるため、`DirectionalLight` を配置します（AmbientLightだけだとトゥーンになりません）。
  光の当たり方によって色が「パキッ」と切り替わるアニメ調の見た目になることを確認します。

## 6. ヒント

- **ヒント 1（マテリアル）**:
  `MeshToonMaterial` を使用します。
  これ単体でもライトへの反応が多少違いますが、真価を発揮するには階調マップが必要です。
- **ヒント 2（階調マップの作成）**:
  数ピクセル幅（例：`width=3, height=1`）の小さな画像を `CanvasTexture` で作るのが簡単です。
  3〜4 色のグレー（暗い〜明るい）を塗り分けます。
- **ヒント 3（テクスチャ設定の重要点）**:
  作成したテクスチャの `minFilter` と `magFilter` を必ず `THREE.NearestFilter` に設定してください。
  デフォルトの `LinearFilter` だと色が滑らかに補間されてしまい、パキッとしたアニメ塗りになりません。
- **ヒント 4（ライト）**:
  トゥーンシェーディングは「光と影」の境界をはっきりさせる表現なので、指向性ライト（`DirectionalLight`）など、はっきりした光源がないと効果が見えにくいです。
- **ヒント 5（アウトラインとの併用）**:
  前問の `OutlinePass` や、裏面法線方式（背面カリングを利用して黒い一回り大きなメッシュを描画する手法）と組み合わせると、より高品質なアニメ調表現になります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(1, 1, 1);
scene.add(light);

// --- ここでグラデーションマップを作成 ---
// const texture = ...
// texture.minFilter = THREE.NearestFilter;
// texture.magFilter = THREE.NearestFilter;

// --- ToonMaterial作成 ---
// const material = new THREE.MeshToonMaterial({ gradientMap: texture, color: ... });

const mesh = new THREE.Mesh(
  new THREE.TorusKnotGeometry(1, 0.3, 100, 16),
  material
);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  mesh.rotation.x += 0.01;
  mesh.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(1, 1, 1);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

// 3階調のテクスチャをCanvasで作る
const canvas = document.createElement("canvas");
canvas.width = 4;
canvas.height = 1;
const ctx = canvas.getContext("2d");
const colors = ["#555555", "#888888", "#bbbbbb", "#ffffff"];
colors.forEach((c, i) => {
  ctx.fillStyle = c;
  ctx.fillRect(i, 0, 1, 1);
});

const texture = new THREE.CanvasTexture(canvas);
// 補間しない（重要）
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;

const material = new THREE.MeshToonMaterial({
  color: 0x00aaff,
  gradientMap: texture,
});

const mesh = new THREE.Mesh(
  new THREE.TorusKnotGeometry(1, 0.3, 100, 16),
  material
);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  mesh.rotation.x += 0.01;
  mesh.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```
