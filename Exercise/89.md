## 1. 問題タイトル

89 本目：サードパーソンカメラ（TPS 視点）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- カメラのオフセット位置計算
- `camera.lookAt` によるターゲット追従
- マウスによるカメラ回転（オービット制御の自作）

## 3. 新しい概念の解説

**Spherical Coordinates (球座標システム)**
カメラをターゲット（プレイヤー）の周囲で回転させるには、「球座標（半径 r, 水平角 θ, 垂直角 φ）」を使うと直感的です。
プレイヤーの位置を原点とし、そこから計算したオフセット（x, y, z）をカメラ位置に加算することで、常に一定距離を保ちながら周囲を回るカメラワークが作れます。

```javascript
/*
  theta: 水平回転角
  phi: 垂直回転角（0は真上）
  radius: カメラ距離
*/
const ox = radius * Math.sin(phi) * Math.sin(theta);
const oy = radius * Math.cos(phi);
const oz = radius * Math.sin(phi) * Math.cos(theta);

// プレイヤー位置にオフセットを足すことで追従
camera.position.set(
  player.position.x + ox,
  player.position.y + oy,
  player.position.z + oz
);
camera.lookAt(player.position);
```

## 4. 課題の説明

キャラクターの背後から追従する「サードパーソン（三人称）カメラ」を実装してください。
キャラクターが移動しても、カメラは常に一定の距離と角度を保ってついていきます。
さらに、マウス操作でカメラをキャラクターの周りで回転できるようにします。

## 5. 必須要件

以下の機能を実装してください。

- **プレイヤー移動**:
  キーボードで動くキャラクターを用意します（前回のを流用可）。

- **球座標パラメータ**:
  カメラ制御用の変数 `radius`（距離）、`theta`（水平角）、`phi`（垂直角）を用意します。

- **マウス操作**:
  `mousemove` イベントで、ドラッグ中に `theta` と `phi` を変化させます。
  `phi` は真上・真下に行き過ぎないよう `Math.max` / `Math.min` で制限します。

- **カメラ位置の更新（追従）**:
  アニメーションループ内で、球座標から直交座標への変換式を使ってカメラ位置（オフセット）を計算します。
  `x = r * sin(phi) * sin(theta)`
  `y = r * cos(phi)`
  `z = r * sin(phi) * cos(theta)`
  これを `player.position` に加算した位置にカメラを置き、最後に `camera.lookAt(player.position)` を呼びます。

## 6. ヒント

- **ヒント 1（球座標変換）**:
  半径 `r`、垂直角 `phi`、水平角 `theta` から直交座標 `(x, y, z)` を求める公式を使います。
  Three.js の Y-up 座標系では `y = r * cos(phi)` となります。
- **ヒント 2（LookAtのタイミング）**:
  カメラの位置を更新した直後に `camera.lookAt(player.position)` を呼ぶことで、常にプレイヤーを中心に捉え続けます。
- **ヒント 3（角度制限）**:
  垂直角 `phi` が 0 や 180 度（真上・真下）になると計算が不安定になったり（ジンバルロック的な挙動）、地面にめり込んだりします。
  `Math.max(0.1, Math.min(Math.PI - 0.1, phi))` のように制限値を設けると安定します。
- **ヒント 4（マウス操作）**:
  `mousemove` イベントの `movementX`, `movementY` を使って角度を加算します。
  ドラッグ中のみ反応させるため、`mousedown/mouseup` でフラグ管理します。
- **ヒント 5（スムーズな追従）**:
  余裕があれば、カメラ位置の更新にも `lerp` を使うと、プレイヤーが動いた後に少し遅れてついてくる、映画のようなカメラワークになります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const player = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
scene.add(player);

// カメラ操作用変数
let cameraAngle = 0;
let cameraHeight = 5;
let cameraDistance = 10;

// マウス移動イベント
document.addEventListener("mousemove", (e) => {
  // cameraAngle を更新
});

function animate() {
  requestAnimationFrame(animate);

  // プレイヤー移動（省略）

  // カメラ位置更新
  // camera.position.x = player.position.x + ...
  // camera.position.z = player.position.z + ...
  // camera.lookAt(player.position);

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.GridHelper(20, 20));

const player = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
scene.add(player);

let theta = 0; // 水平角度
let phi = 60 * (Math.PI / 180); // 垂直角度
const radius = 10;

let isDragging = false;
let prevMouse = { x: 0, y: 0 };

document.addEventListener("mousedown", (e) => {
  isDragging = true;
  prevMouse = { x: e.clientX, y: e.clientY };
});

document.addEventListener("mouseup", () => (isDragging = false));

document.addEventListener("mousemove", (e) => {
  if (isDragging) {
    const deltaX = e.clientX - prevMouse.x;
    const deltaY = e.clientY - prevMouse.y;

    theta -= deltaX * 0.01;
    phi -= deltaY * 0.01;

    // 制限
    phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

    prevMouse = { x: e.clientX, y: e.clientY };
  }
});

function animate() {
  requestAnimationFrame(animate);

  // プレイヤーが勝手に動くデモ
  player.position.x = Math.sin(Date.now() * 0.001) * 5;

  // カメラ位置計算（球座標）
  // プレイヤー位置を基準にする
  const ox = radius * Math.sin(phi) * Math.sin(theta);
  const oy = radius * Math.cos(phi);
  const oz = radius * Math.sin(phi) * Math.cos(theta);

  camera.position.set(
    player.position.x + ox,
    player.position.y + oy,
    player.position.z + oz
  );

  camera.lookAt(player.position);

  renderer.render(scene, camera);
}
animate();
```
