## 1. 問題タイトル

14 本目：影の設定

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 影（Shadow Map）の有効化手順
- `castShadow`（影を落とす）と `receiveShadow`（影を受ける）の設定
- レンダラーのシャドウマップ設定

## 3. 新しい概念の解説

**Shadow（影）**
3D グラフィックスにおいて、影の計算は非常に重い処理です。そのため、Three.js ではデフォルトでオフになっています。
影を表示するには以下の3ステップが必要です：
1. **Renderer**: `shadowMap.enabled = true`
2. **Light**: `light.castShadow = true`（影を作る光源）
3. **Mesh**: `mesh.castShadow = true`（影を落とす物体）と `mesh.receiveShadow = true`（影が映る物体）

```javascript
// 1. レンダラー設定
renderer.shadowMap.enabled = true;

// 2. ライト設定
light.castShadow = true;

// 3. メッシュ設定
cube.castShadow = true;      // 影を落とす
floor.receiveShadow = true;  // 影を受ける
```

## 4. 課題の説明

キューブの下に「床」となる平面を配置し、ライトによってキューブの影が床に落ちるように設定してください。
Three.js では影は自動的には描画されず、明示的な設定が必要です。

## 5. 必須要件

以下の機能を実装してください。

- **レンダラーの設定**:
  `renderer.shadowMap.enabled = true` を設定して影を有効化します。

- **ライトの設定**:
  `DirectionalLight` を作成し、`castShadow = true` を設定します。

- **影を落とす物体（Cast）**:
  キューブを作成し、`castShadow = true` を設定します。マテリアルは `MeshStandardMaterial` です。

- **影を受ける床（Receive）**:
  `PlaneGeometry` で床を作り、`receiveShadow = true` を設定します。
  キューブの下（`y = -1` など）に配置し、水平に回転させます。

- **確認**:
  床の上にキューブの影が落ちていることを確認します。

## 6. ヒント

- **ヒント 1（3 段階の設定）**:
  影を出すには、「レンダラー」「ライト」「メッシュ」の 3 箇所すべてで設定が必要です。
  1箇所でも忘れると影は出ません。
- **ヒント 2（パフォーマンス）**:
  影の計算（シャドウマップ）は非常に重い処理です。
  すべてのライトや物体でむやみにオンにせず、主要なライトと物体だけに限定するのがコツです。
- **ヒント 3（シャドウマップの種類）**:
  デフォルトの影が粗い場合、`renderer.shadowMap.type = THREE.PCFSoftShadowMap` を設定すると、少し滑らかになります（今回は任意）。
- **ヒント 4（床の重要性）**:
  影は「落ちる場所」がないと見えません。
  `receiveShadow = true` に設定した床（PlaneGeometry）を、物体の下に配置することを忘れないでください。
- **ヒント 5（ライトの位置）**:
  ライトの位置によっては、影が画面外に落ちて見えないことがあります。
  影が見えないときは `CameraHelper`（シャドウカメラ用）などで範囲を確認することがあります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
// --- ここでレンダラーの影を有効にしてください ---
document.body.appendChild(renderer.domElement);

// ライト
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 5, 5);
// --- ここでライトの影を有効にしてください ---
scene.add(light);

// キューブ
const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);
// --- ここでキューブが影を落とすように設定してください ---
scene.add(cube);

// 床
const planeGeo = new THREE.PlaneGeometry(10, 10);
const planeMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
const plane = new THREE.Mesh(planeGeo, planeMat);
plane.rotation.x = -Math.PI / 2; // 水平にする
plane.position.y = -1; // キューブの下へ
// --- ここで床が影を受けるように設定してください ---
scene.add(plane);

camera.position.z = 5;
camera.position.y = 2;
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);

// 1. レンダラーの影設定を有効化
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// 2. ライトの設定
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 5, 5);
light.castShadow = true; // ライトが影を生成するようにする
scene.add(light);

// 3. キューブの設定（影を落とす側）
const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);
cube.castShadow = true; // 影を落とす
scene.add(cube);

// 4. 床の設定（影を受ける側）
const planeGeo = new THREE.PlaneGeometry(10, 10);
const planeMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
const plane = new THREE.Mesh(planeGeo, planeMat);
plane.rotation.x = -Math.PI / 2;
plane.position.y = -1;
plane.receiveShadow = true; // 影を受ける
scene.add(plane);

camera.position.set(0, 2, 5);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```
