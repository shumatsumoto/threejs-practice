## 1. 問題タイトル

85 本目：ジャンプゲーム（重力の実装）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 重力加速度のシミュレーション
- ジャンプのロジック
- 地面との当たり判定（簡易版）

## 3. 新しい概念の解説

**Gravity & Jump Logic（重力とジャンプのロジック）**
重力とは、毎フレーム下向きにかかり続ける加速度のことです。
`velocityY`（垂直方向の速度）から毎フレーム一定値を引き算し、その `velocityY` を位置に加算することで、放物線を描くジャンプや落下を表現します。
地面との衝突判定（着地）も不可欠な要素です。

```javascript
// 重力適用（下向きの加速度）
velocityY -= 0.01;
player.position.y += velocityY;

// 地面との当たり判定
if (player.position.y <= 0) {
  player.position.y = 0; // めり込み補正
  velocityY = 0;
  isJumping = false;
}

// ジャンプ（上向きの初速を与える）
if (keys['Space'] && !isJumping) {
  velocityY = 0.3;
  isJumping = true;
}
```

## 4. 課題の説明

スペースキーを押すとキャラクター（キューブ）がジャンプする機能を作成してください。
空中にいる間は重力によって下に引かれ、地面に着くと止まります。

## 5. 必須要件

以下の機能を実装してください。

- **変数の準備**:
  `velocityY`（垂直速度、初期値0）、`gravity`（0.01程度）、`jumpStrength`（0.3程度）、`isGrounded`（接地フラグ）を用意します。

- **入力処理**:
  `keydown` イベントでスペースキーを監視し、`isGrounded` が `true` の場合のみ `velocityY = jumpStrength` に設定してジャンプさせます。

- **物理ループ（animate内）**:
  1. **重力適用**: `velocityY -= gravity`。
  2. **位置更新**: `player.position.y += velocityY`。
  3. **接地判定（着地）**:
     - `player.position.y` が地面の高さ（例：0.5）以下になったら、
     - `player.position.y = 0.5`（埋まり防止）
     - `velocityY = 0`（停止）
     - `isGrounded = true`
     - それ以外は `isGrounded = false`。

## 6. ヒント

- **ヒント 1（重力の実装）**:
  重力は位置ではなく「速度」に影響します。
  毎フレーム `velocityY -= gravity` することで、放物線を描く自然な落下になります。
- **ヒント 2（着地判定）**:
  `player.position.y` が地面の高さ（例：0 か、プレイヤーサイズの半分）を下回ったら、位置を修正し、`velocityY = 0` にリセットします。
  同時に「着地フラグ」を ON にします。
- **ヒント 3（ジャンプ制限）**:
  空中でさらにジャンプできないよう、「着地中のときだけ」スペースキー入力を受け付けるようにします。
- **ヒント 4（めり込み補正）**:
  高速で落下すると、1フレームで地面を大きく突き抜けることがあります。
  衝突時は必ず `player.position.y = 地面の高さ` に強制移動させるのがバグ防止のコツです。
- **ヒント 5（可視化）**:
  高さが分かりにくい場合は、プレイヤーの真下に影（丸い板ポリゴン）を表示したり、グリッドヘルパーを置くと距離感が掴みやすくなります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const player = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
player.position.y = 0.5; // 半分埋まらないように
scene.add(player);

// 地面
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(10, 10),
  new THREE.MeshBasicMaterial({ color: 0x555555 })
);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

let velocityY = 0;
const gravity = 0.01;
const jumpPower = 0.2;
let isJumping = false;

document.addEventListener("keydown", (e) => {
  if (e.code === "Space" && !isJumping) {
    velocityY = jumpPower;
    isJumping = true;
  }
});

camera.position.set(0, 2, 5);

function animate() {
  requestAnimationFrame(animate);

  // --- ここで物理演算 ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const player = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
player.position.y = 0.5;
scene.add(player);

const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.MeshBasicMaterial({ color: 0x555555 })
);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

let velocityY = 0;
const gravity = 0.01;
const jumpPower = 0.3;
let onGround = true;

document.addEventListener("keydown", (e) => {
  if (e.code === "Space" && onGround) {
    velocityY = jumpPower;
    onGround = false;
  }
});

camera.position.set(0, 5, 10);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  // 重力適用
  velocityY -= gravity;
  player.position.y += velocityY;

  // 接地判定
  if (player.position.y <= 0.5) {
    player.position.y = 0.5;
    velocityY = 0;
    onGround = true;
  } else {
    onGround = false;
  }

  renderer.render(scene, camera);
}
animate();
```
