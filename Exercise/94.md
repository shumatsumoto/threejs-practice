## 1. 問題タイトル

94 本目：データビジュアライゼーション（棒グラフ）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 数値データに基づいた 3D オブジェクトの生成
- スケール（高さ）の動的な設定
- 色による情報の可視化

## 3. 新しい概念の解説

**Data Visualization (データ可視化)**
JSON や配列などの数値データを 3D オブジェクトのプロパティ（位置、スケール、色）にマッピングすることで、直感的なグラフやチャートを作成できます。
特に 3D の棒グラフでは、底面の位置を固定しつつ高さを変えるために、ジオメトリの原点を工夫（translate）するか、ポジション計算を調整する必要があります。
色の正規化（データ値を 0〜1 に変換して色相に割り当て）も重要なテクニックです。

```javascript
const data = [10, 50, 80, 20];

data.forEach((value, index) => {
  const bar = new THREE.Mesh(geometry, material);
  
  // 高さをデータ値に合わせる
  bar.scale.y = value;
  
  // 底面を揃える（中心から延びるため、高さの半分だけ上にずらす）
  bar.position.y = value / 2;
  bar.position.x = index * 2;
  
  // 値に応じて色を変える（0〜100 を 0.0〜1.0 に正規化）
  // HSL: 色相(Hue)を変化させると虹色になる
  const hue = (100 - value) / 100 * 0.7; // 青(0.7) -> 赤(0.0)
  bar.material.color.setHSL(hue, 1.0, 0.5);
  
  scene.add(bar);
});
```

## 4. 課題の説明

配列データ（例：`[10, 50, 30, 80, 20]`）に基づいて、3D の棒グラフを作成してください。
数値が大きいほど棒が高くなり、色も変化するようにします（例：低いと青、高いと赤）。

## 5. 必須要件

以下の機能を実装してください。

- **データの用意**:
  グラフ化したい数値データ配列（例: `[10, 50, 30, 80]`）を用意します。

- **基準ジオメトリの調整（重要）**:
  `BoxGeometry(1, 1, 1)`（または適切な幅）を作成します。
  `geometry.translate(0, 0.5, 0)` を実行し、原点が「底面」に来るようにジオメトリ自体をずらしておきます（これが無いとスケーリング時に上下両方に伸びてしまいます）。

- **グラフの生成**:
  `forEach` でデータをループし、棒（Mesh）を作成します。
  1. **位置**: X 座標を `index` に基づいてずらす（`mesh.position.x = index * gap`）。
  2. **高さ**: データ値に基づいて Y スケールを設定する（`mesh.scale.y = value * scaleFactor`）。
  3. **色**: 値の大きさに応じて色を変える。`value` を 0〜1 に正規化し、`color.setHSL()` で色相を変化させる（例：低い＝青、高い＝赤）。

- **シーンへの追加**:
  生成した棒をシーンに追加し、全体が見渡せるようにカメラ位置を調整します。

## 6. ヒント

- **ヒント 1（底面の固定テクニック）**:
  通常 `scale.y` を変えると上下に伸びてしまいます。
  `geometry.translate(0, 0.5, 0)` を一度実行しておくと、以後のスケーリングは「下を基準に上に伸びる」挙動になります。これで位置計算が楽になります。
- **ヒント 2（色のマッピング）**:
  `value` が 0〜100 の時、`value / 100` で 0.0〜1.0 に正規化します。
  `color.setHSL(0.7 * (1.0 - normalized), 1.0, 0.5)` とすると、値が小さい時は青(0.7)、大きい時は赤(0.0)になります。
- **ヒント 3（データの配置）**:
  X 軸方向に `index * gap` だけずらして配置します。
  Z 軸方向にもデータを並べれば 3D のヒートマップになります。
- **ヒント 4（インタラクション）**:
  演習 81（Raycaster）と組み合わせれば、「マウスオーバーで数値を表示する」機能も追加できます。
- **ヒント 5（更新）**:
  データが変わった時は、既存のメッシュを破棄（dispose）して再生成するか、プールしておいたメッシュの scale を更新して対応します。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const data = [10, 50, 30, 80, 20, 90, 40, 60];

// --- ここでグラフ作成 ---
// data.forEach((val, i) => { ... });

camera.position.set(5, 10, 20);
camera.lookAt(5, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const data = [10, 50, 30, 80, 20, 90, 40, 60, 100, 10];

// 基準となるジオメトリ（高さ1）
// 底面を原点に合わせるためにY方向に0.5ずらす
const geometry = new THREE.BoxGeometry(0.8, 1, 0.8);
geometry.translate(0, 0.5, 0);

data.forEach((value, index) => {
  // 値に応じて色を変える（0〜100を0〜1に正規化してHSLで設定）
  const color = new THREE.Color();
  const normalized = value / 100;
  color.setHSL(0.7 - normalized * 0.7, 1.0, 0.5); // 青(0.7) -> 赤(0.0)

  const material = new THREE.MeshBasicMaterial({ color: color });
  const bar = new THREE.Mesh(geometry, material);

  // 位置
  bar.position.x = index * 1.2;

  // 高さ（スケール）
  bar.scale.y = value * 0.1; // 見やすい大きさに調整

  scene.add(bar);
});

// グリッド
scene.add(new THREE.GridHelper(20, 20));

camera.position.set(5, 10, 15);
camera.lookAt(5, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```
