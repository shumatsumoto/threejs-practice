## 1. 問題タイトル

57 本目：リムライティング（逆光表現）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- ライトの方向と法線の関係
- フレネル効果の応用
- キャラクターや物体のシルエットを際立たせる手法

## 3. 新しい概念の解説

**Rim Lighting（リムライティング）**
被写体の背後から強い光を当てて、輪郭を際立たせる照明技法です。
映画や写真撮影だけでなく、ゲームグラフィックスでもキャラクターのシルエットを強調するために頻繁に使われます。
フレネル効果と似ていますが、リムライトは「光源の位置」を考慮する点が異なります。

```javascript
/*
  ベースカラーにリムライトを加算合成する例
*/
const fShader = `
  void main() {
      // (フレネル計算省略...) float rim = ...;
      
      vec3 baseColor = vec3(0.1, 0.1, 0.1); // 暗いボディ
      vec3 rimColor = vec3(1.0, 0.8, 0.0);  // 金色の逆光
      
      // ベース色 + (リム色 * 強さ)
      gl_FragColor = vec4(baseColor + rimColor * rim, 1.0);
  }
`;
```

## 4. 課題の説明

演習 56 のフレネル効果と似ていますが、今回は「特定の方向からの逆光」によって輪郭が光るリムライトを実装してください。
背後から強い光が当たっているような演出を行います。

## 5. 必須要件

以下の機能を実装してください。

- **ライト方向の定義**:
  ユニフォーム `uLightDirection` を定義し、背後からの適当なベクトル（例: `vec3(-1.0, 0.0, -1.0)`）を渡します。

- **リム強度計算**:
  フレネル項（`1.0 - dot(normal, view)`）と、ライト方向成分（`pow(dot(normal, lightDir), ...)` など）を組み合わせて、逆光が当たっているエッジ領域を計算します。
  （簡易版としてフレネルのみでも可としますが、ライト方向ありの方がベター）。

- **色合成**:
  ベースカラー（暗い色）に対し、計算したリム強度分だけ明るい色（黄色など）を「加算」して出力します。
  シルエットが浮かび上がるような見た目を確認します。

## 6. ヒント

- **ヒント 1（リムライトの原理）**:
  フレネル効果（エッジ光）の一種ですが、通常は「逆光（背後からのライト）」をシミュレートするために使われます。
- **ヒント 2（clamp関数）**:
  内積（dot）の結果はマイナスになる（裏面）こともあります。
  計算がおかしくならないよう `clamp(val, 0.0, 1.0)` を使って、範囲を 0〜1 に制限するのが安全です。
- **ヒント 3（加算 or 乗算）**:
  リムライトは「追加の光」なので、ベースの色（テクスチャなど）に対して `baseColor + rimColor` のように足し算（加算）するのが一般的です。
- **ヒント 4（色の例）**:
  ボディを暗めの色（`vec3(0.2)`）にし、リムライトを明るい色（`vec3(1.0, 0.8, 0.0)`）にすると、効果が分かりやすくカッコいい見た目になります。
- **ヒント 5（応用）**:
  さらに `dot(normal, lightDir)` を考慮に入れると、全方向均一なフチではなく「光が当たっている側のフチ」だけを光らせるリアルなリムライトになります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// シェーダーは演習56をベースに改良
const vShader = `
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    void main() {
        vNormal = normalize(normalMatrix * normal);
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vViewPosition = -mvPosition.xyz;
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const fShader = `
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    void main() {
        float dotProduct = dot(normalize(vNormal), normalize(vViewPosition));
        float rim = pow(1.0 - dotProduct, 4.0);
        
        // --- ここでベース色とリム色を合成 ---
        
        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
});

const mesh = new THREE.Mesh(
  new THREE.TorusKnotGeometry(1, 0.3, 100, 16),
  material
);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  mesh.rotation.x += 0.01;
  mesh.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    void main() {
        vNormal = normalize(normalMatrix * normal);
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vViewPosition = -mvPosition.xyz;
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const fShader = `
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    void main() {
        float dotProduct = dot(normalize(vNormal), normalize(vViewPosition));
        // 0未満にならないようにclamp
        float rim = pow(1.0 - clamp(dotProduct, 0.0, 1.0), 4.0);
        
        vec3 baseColor = vec3(0.2, 0.2, 0.2); // 暗いグレー
        vec3 rimColor = vec3(1.0, 0.8, 0.0);  // 金色のリムライト
        
        // ベース色にリムライトを加算
        gl_FragColor = vec4(baseColor + rimColor * rim, 1.0);
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
});

const mesh = new THREE.Mesh(
  new THREE.TorusKnotGeometry(1, 0.3, 100, 16),
  material
);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  mesh.rotation.x += 0.01;
  mesh.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```
