## 1. 問題タイトル

84 本目：ミニレースゲーム（基礎）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 車の操作（加速、旋回）
- 慣性の実装（速度ベクトル）
- 簡易的なコース外判定

## 3. 新しい概念の解説

**Inertia & Velocity（慣性と速度）**
物体が動き続けようとする性質（慣性）を表現するには、単に「キーを押している間だけ進む」のではなく、「速度変数（Velocity）を更新し続け、その速度で位置を更新する」という物理挙動の基礎的な実装が必要です。
摩擦（Friction）を加えることで、徐々に止まるリアルな動きになります。

```javascript
// キー入力で「速度」を加算
if (keys['ArrowUp']) speed += 0.01;

// 毎フレーム「摩擦」で減速（速度に1未満の値を掛ける）
speed *= 0.98;

// 「速度」と「向き」に基づいて位置を更新
car.position.x += Math.sin(car.rotation.y) * speed;
car.position.z += Math.cos(car.rotation.y) * speed;
```

## 4. 課題の説明

キーボード操作で車（直方体）を運転できるミニゲームの基礎を作成してください。
上キーで加速、下キーで減速/バック、左右キーで旋回します。
慣性をつけて、キーを離してもすぐに止まらないようにするとリアルです。

## 5. 必須要件

以下の機能を実装してください。

- **車の作成**:
  直方体（BoxGeometry）を作成し、どちらが前か分かるように縦長（例：1x0.5x2）にします。

- **操作変数の定義**:
  - `speed`（現在の速度、初期値0）
  - `angle`（現在の向き、初期値0）
  - `keys` オブジェクト（押されているキーの状態管理）

- **物理挙動の実装（ループ内）**:
  1. **加速/減速**: 上キーで `speed += 0.01`、下キーで `speed -= 0.01`。
  2. **旋回**: 速度が出ている時（`Math.abs(speed) > 0.001`）のみ、左右キーで `angle += 0.03`（またはマイナス）。
  3. **摩擦**: `speed *= 0.98` を実行して自然に減速させる。
  4. **座標更新**:
     - `car.rotation.y = angle`
     - `car.position.x += Math.sin(angle) * speed`
     - `car.position.z += Math.cos(angle) * speed`

- **簡易追従カメラ**:
  `camera.position.x`, `z` を車の位置に合わせて更新し、少し後ろから見下ろす位置に調整します。

## 6. ヒント

- **ヒント 1（移動計算の数学）**:
  車の向きを `angle` とすると、進行方向の X 成分は `Math.sin(angle)`、Z 成分は `Math.cos(angle)` になります。
  これに `speed` を掛けて現在位置に足し込みます。
- **ヒント 2（慣性の実装）**:
  キーを押した時に「移動」させるのではなく、「速度」を加算します。
  そしてキーを離しても速度はすぐ 0 にせず、摩擦処理で徐々に減らします。
- **ヒント 3（摩擦）**:
  `speed *= 0.96;` のように、毎フレーム 1.0 未満の値を掛けることで、自然に減速して停止します。
- **ヒント 4（ハンドリング）**:
  停止中に旋回すると不自然（戦車の超信地旋回みたいになる）なので、`if (Math.abs(speed) > 0.01)` の時だけ旋回できるようにすると、より車らしくなります。
- **ヒント 5（カメラ追従）**:
  `camera.position.x = car.position.x;`
  `camera.position.z = car.position.z + 10;`
  のように車の位置をコピーしつつ、少しオフセット（後ろや上）を加えることで、簡易的な追跡カメラになります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const car = new THREE.Mesh(
  new THREE.BoxGeometry(1, 0.5, 2),
  new THREE.MeshNormalMaterial()
);
scene.add(car);

// 変数
let speed = 0;
let angle = 0;
const keys = {};

document.addEventListener("keydown", (e) => (keys[e.code] = true));
document.addEventListener("keyup", (e) => (keys[e.code] = false));

camera.position.set(0, 10, 10);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  // --- ここで移動ロジック ---

  // カメラ追従
  // camera.position.x = car.position.x;
  // camera.position.z = car.position.z + 10;

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 地面
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(100, 100),
  new THREE.MeshBasicMaterial({ color: 0x228822 })
);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

// グリッド（移動感のため）
const grid = new THREE.GridHelper(100, 20);
scene.add(grid);

// 環境オブジェクト（木やビルに見立てた箱）をランダム配置
const boxGeo = new THREE.BoxGeometry(2, 5, 2);
const boxMat = new THREE.MeshNormalMaterial();
for (let i = 0; i < 50; i++) {
  const box = new THREE.Mesh(boxGeo, boxMat);
  box.position.set((Math.random() - 0.5) * 80, 2.5, (Math.random() - 0.5) * 80);
  scene.add(box);
}

// 車
const car = new THREE.Mesh(
  new THREE.BoxGeometry(1, 0.5, 2),
  new THREE.MeshNormalMaterial()
);
scene.add(car);

let speed = 0;
let angle = 0;
const keys = {};

document.addEventListener("keydown", (e) => (keys[e.code] = true));
document.addEventListener("keyup", (e) => (keys[e.code] = false));

camera.position.set(0, 10, 10);

function animate() {
  requestAnimationFrame(animate);

  // 加速・減速
  if (keys["ArrowUp"]) speed += 0.01;
  if (keys["ArrowDown"]) speed -= 0.01;

  // 旋回（動いている時だけ）
  if (Math.abs(speed) > 0.001) {
    if (keys["ArrowLeft"]) angle += 0.03;
    if (keys["ArrowRight"]) angle -= 0.03;
  }

  // 摩擦
  speed *= 0.96;

  // 移動反映
  car.rotation.y = angle;
  car.position.x += Math.sin(angle) * speed;
  car.position.z += Math.cos(angle) * speed;

  // カメラ追従（簡易的）
  camera.position.x = car.position.x;
  camera.position.z = car.position.z + 10;
  camera.lookAt(car.position);

  renderer.render(scene, camera);
}
animate();
```
