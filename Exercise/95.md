## 1. 問題タイトル

95 本目：3D グラフ（曲面プロット）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 数式 `z = f(x, y)` に基づくメッシュ生成
- `ParametricGeometry` の使用（または自作メッシュ）
- 3 次元データの可視化

## 3. 新しい概念の解説

**Parametric Geometry (パラメトリックジオメトリ)**
数式 `f(u, v)` (0 <= u, v <= 1) に基づいて曲面を生成するジオメトリです。
数学的なグラフや、自然界の形状（貝殻や花びらなど）を表現するのに適しています。
関数内で `u`, `v` を適切な座標範囲（例: -10 ～ 10）に変換し、x, y, z を計算して `target` ベクトルに設定するだけで、Three.js が自動的にメッシュを構築してくれます。

```javascript
import { ParametricGeometry } from 'three/examples/jsm/geometries/ParametricGeometry';

const graphFunc = (u, v, target) => {
  // u, v (0~1) を座標範囲 (-10 ~ 10) に変換
  const x = (u - 0.5) * 20;
  const z = (v - 0.5) * 20;
  
  // 高さの数式 z = sin(x) * cos(y) ※Three.jsではYが高さ
  const y = Math.sin(x) * Math.cos(z);
  
  target.set(x, y, z);
};

// 50x50 の分割数でメッシュ生成
const geometry = new ParametricGeometry(graphFunc, 50, 50);
```

## 4. 課題の説明

数式 `z = sin(x) * cos(y)` を表す 3D 曲面グラフを作成してください。
`ParametricGeometry` を使うと、関数を渡すだけで曲面を生成できます。

## 5. 必須要件

以下の機能を実装してください。

- **パラメトリック関数の定義**:
  `(u, v, target) => {}` という形式の JavaScript 関数を作成します。
  1. 引数 `u`, `v`（0.0〜1.0）を受け取ります。
  2. これらをグラフの表示範囲（例：-10〜10）に変換し、`x`, `z` とします。
  3. 数式 `y = Math.sin(x) * Math.cos(z)` を計算して高さを求めます（Three.js は Y-up なので y に入れます）。
  4. `target.set(x, y, z)` を実行してベクトルに値をセットします。

- **ジオメトリの作成**:
  `ParametricGeometry`（`three/examples/jsm/geometries/ParametricGeometry` からインポート）を使用し、上記の関数と分割数（例：50, 50）を渡して生成します。

- **マテリアルと表示**:
  曲面が見やすくなるよう、`side: THREE.DoubleSide` を設定した `MeshNormalMaterial` などを適用し、シーンに追加します。
  任意でワイヤーフレームを重ねて形状を分かりやすくします。

## 6. ヒント

- **ヒント 1（関数の仕様）**:
  `ParametricGeometry` に渡す関数は `(u, v, target) => {}` という署名が決まっています。
  `u`, `v` は必ず 0.0 〜 1.0 の範囲で渡されます。
- **ヒント 2（座標変換）**:
  0〜1 のままでは狭いので、`x = (u - 0.5) * 20` のようにして -10〜10 などの使いたい範囲にマッピングします。
- **ヒント 3（三次元グラフ）**:
  数学では Z 軸が高さですが、Three.js は Y-up なので、計算した高さ `z = f(x, y)` を Three.js の `y` 座標にセットします。
  つまり `target.set(x, z, y)` （最後の引数は奥行き）のような対応関係になります。
- **ヒント 4（面の見え方）**:
  曲面は裏側から見ると消えてしまうことがあるため、マテリアルには `side: THREE.DoubleSide` を指定するのが無難です。
- **ヒント 5（ワイヤーフレーム）**:
  形状を把握しやすくするため、半透明の面メッシュの上に、黒いワイヤーフレームメッシュを少しだけ大きくして重ねると、綺麗で解析的な見た目になります。

## 7. スターターコード

```javascript
import * as THREE from "three";
// import { ParametricGeometry } ...

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 関数定義
const graphFunc = (u, v, target) => {
  // u, v (0~1) -> x, z (-10~10)
  const x = (u - 0.5) * 20;
  const z = (v - 0.5) * 20;
  const y = Math.sin(x) * Math.cos(z); // 高さ

  target.set(x, y, z);
};

// --- ここでジオメトリ作成 ---

camera.position.set(0, 10, 20);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { ParametricGeometry } from "three/examples/jsm/geometries/ParametricGeometry";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const graphFunc = (u, v, target) => {
  const range = 10;
  const x = (u - 0.5) * range;
  const z = (v - 0.5) * range;

  // 波打つ関数
  const y = Math.sin(x) * Math.cos(z) * 2;

  target.set(x, y, z);
};

// 分割数 50x50
const geometry = new ParametricGeometry(graphFunc, 50, 50);
const material = new THREE.MeshNormalMaterial({
  side: THREE.DoubleSide,
  wireframe: false,
});
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);

// ワイヤーフレームを重ねると見やすい
const wireMat = new THREE.MeshBasicMaterial({
  color: 0x000000,
  wireframe: true,
  transparent: true,
  opacity: 0.3,
});
const wireMesh = new THREE.Mesh(geometry, wireMat);
scene.add(wireMesh);

camera.position.set(0, 10, 15);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  mesh.rotation.y += 0.005;
  wireMesh.rotation.y += 0.005;

  renderer.render(scene, camera);
}
animate();
```
