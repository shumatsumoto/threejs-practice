## 1. 問題タイトル

22 本目：マウスホバーで拡大

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `mousemove` イベントと Raycaster の連携
- リアルタイムなインタラクションの実装
- ホバー状態の管理（マウスが乗った時、離れた時の処理）

## 3. 新しい概念の解説

**Hover Interaction（ホバー）**
マウスカーソルがオブジェクトの上に乗っている状態のことです。
Web サイトのボタンと同様に、3D でもユーザーに「触れるよ」と伝えるために重要です。
`click` イベントは一瞬だけ発生しますが、ホバー判定は `mousemove` やアニメーションループを使って「常に」チェックし続ける（毎フレーム監視する）必要があります。

```javascript
// アニメーションループ内で常に判定
raycaster.setFromCamera(mouse, camera);
const intersects = raycaster.intersectObjects(scene.children);

if (intersects.length > 0) {
    // マウスが乗っている時：拡大
    cube.scale.set(1.2, 1.2, 1.2);
} else {
    // マウスが乗っていない時：元のサイズ
    cube.scale.set(1.0, 1.0, 1.0);
}
```

## 4. 課題の説明

マウスカーソルがキューブの上に乗った時だけ、キューブを少し拡大（1.2 倍）し、離れたら元のサイズ（1.0 倍）に戻るようにしてください。
Web サイトのボタンのようなインタラクションを 3D オブジェクトで実現します。

## 5. 必須要件

以下の機能を実装してください。

- **マウス位置の追跡**:
  `mousemove` イベントリスナーで、常に最新のマウス座標（正規化済み）を更新し続けます。

- **常時判定**:
  `animate` ループの中で `raycaster.setFromCamera` を実行し、毎フレーム交差判定を行います。

- **ホバー状態の切り替え**:
  - **交差している場合**: オブジェクトのスケールを `1.2` に拡大します。
  - **交差していない場合**: オブジェクトのスケールを `1.0` に戻します（元のサイズ）。

- **注意点**:
  これを行わないと「一度大きくなったら戻らない」状態になります。else文（非交差時の処理）を忘れないようにしてください。

## 6. ヒント

- **ヒント 1（イベントの種類）**:
  クリック時だけ動く `click` ではなく、常に座標を更新し続けるために `mousemove` イベントを使います。
- **ヒント 2（判定のタイミング）**:
  マウスが動いていない時でもアニメーション（回転など）している可能性があるため、Raycaster の判定は `animate` ループの中で毎フレーム行うのがベストです。
- **ヒント 3（条件分岐）**:
  「当たっている時」と「当たっていない時（else）」の両方を書くのがポイントです。
  else を書かないと、一度大きくなったら二度と戻らなくなります。
- **ヒント 4（対象の絞り込み）**:
  `scene.children` にはライトやカメラヘルパーなども含まれます。
  特定のオブジェクトだけ判定したい場合は、`intersectsObjects([cube])` のように配列を渡すと誤動作を防げます。
- **ヒント 5（参照）**:
  `intersects[0].object` で、当たったそのオブジェクトを操作できます。`cube` 変数を直接操作しても良いですが、`object` を使う方が汎用的です。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);

camera.position.z = 5;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// マウス移動時に座標を更新
window.addEventListener("mousemove", (event) => {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
});

function animate() {
  requestAnimationFrame(animate);

  // --- ここでRaycaster判定とスケール変更を行ってください ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);

camera.position.z = 5;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("mousemove", (event) => {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
});

function animate() {
  requestAnimationFrame(animate);

  // Raycasterの更新
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(scene.children);

  if (intersects.length > 0) {
    // ホバー時：拡大
    cube.scale.set(1.2, 1.2, 1.2);
  } else {
    // 非ホバー時：元に戻す
    cube.scale.set(1.0, 1.0, 1.0);
  }

  // 少し回転
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;

  renderer.render(scene, camera);
}
animate();
```
