## 1. 問題タイトル

30 本目：フォグ（霧）の追加

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `Scene.fog` プロパティの設定
- 距離に応じたフェードアウト効果（空気遠近法）
- 背景色とフォグ色の統一

## 3. 新しい概念の解説

**Fog（フォグ/霧）**
カメラから遠ざかるにつれて、オブジェクトの色を徐々に背景色に混ぜていく効果です。
- **空気遠近法**: 遠くの山が霞んで見えるようなリアリティを出せます。
- **クリッピング隠し**: 描画範囲（Far）の限界でオブジェクトがプツッと消えるのを防ぎ、自然にフェードアウトさせることができます。

```javascript
// 背景色をグレーに設定
scene.background = new THREE.Color(0xcccccc);

// フォグを設定 (色, 開始距離, 終了距離)
// 10mから霞み始め、50mで真っ白(背景色)になる
scene.fog = new THREE.Fog(0xcccccc, 10, 50);
```

## 4. 課題の説明

シーンに霧（フォグ）を追加し、遠くにあるオブジェクトが霞んで見えなくなるようにしてください。
これにより、空間の奥行き感が強調され、遠くのポリゴンの切れ目を隠すこともできます。

## 5. 必須要件

以下の機能を実装してください。

- **背景色の設定**:
  `scene.background` に `new THREE.Color(0xcccccc)`（薄いグレーなど）を設定します。

- **フォグの設定**:
  `scene.fog` に `new THREE.Fog(color, near, far)` を作成して代入します。
  `color` は背景色と**全く同じ色**にします。
  `near` と `far` を調整し、オブジェクトが徐々に霞んで消える距離感を作ります。

- **オブジェクト配置と確認**:
  キューブを奥に向かって配置し、遠くのものが霧に溶け込んで見えなくなっていることを確認します。
  `far` の向こう側にあるオブジェクトが、プツッと切れるのではなく自然に背景と馴染んでいることが重要です。

## 6. ヒント

- **ヒント 1（色の統一）**:
  最も重要なのは `scene.background` と `scene.fog` の色を完全に同じにすることです。
  ここがズレていると「霧の中に背景の壁がある」ように見えてしまい、無限の広がりが出ません。
- **ヒント 2（Fogの種類）**:
  `THREE.Fog(色, 開始, 終了)` は線形（Linear）フォグです。ある距離から急に見えなくなります。
  `THREE.FogExp2(色, 密度)` を使うと、指数関数的でよりリアルな空気感が出せます（今回はFogでOK）。
- **ヒント 3（距離感）**:
  `start`（開始距離）を手前にしすぎると、目の前のものまで白んでしまいます。
  `end`（終了距離）をカメラの `Far` クリップ面より少し手前に設定すると、オブジェクトの消失（クリッピング）を綺麗に隠せます。
- **ヒント 4（ライトの影響）**:
  `MeshStandardMaterial` などの反応するマテリアルを使っていても、Fog の色は発光に関係なく上書き（ブレンド）されるため、最終的には背景色になります。
- **ヒント 5（演出）**:
  あえて背景を黒にして黒い霧を作ると「暗闇」になります。
  背景を水色にして水色の霧を作ると「水中」のような表現にも使えます。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
// --- ここで背景色とフォグを設定 ---

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 奥行き確認用にキューブを並べる
for (let i = 0; i < 20; i++) {
  const cube = new THREE.Mesh(
    new THREE.BoxGeometry(1, 1, 1),
    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
  );
  cube.position.z = -i * 2; // 奥へ配置
  cube.position.x = i % 2 === 0 ? 3 : -3; // 横に広く散らす
  scene.add(cube);
}

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();

// 1. 背景色の設定
const color = 0xcccccc;
scene.background = new THREE.Color(color);

// 2. フォグの設定
// Fog(色, 開始距離, 終了距離)
// 10m先から霧がかかり始め、30m先で完全に見えなくなる
scene.fog = new THREE.Fog(color, 10, 30);

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// キューブを奥に向かって配置
for (let i = 0; i < 30; i++) {
  const cube = new THREE.Mesh(
    new THREE.BoxGeometry(1, 1, 1),
    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
  );
  cube.position.z = -i * 1.5; // 1.5m間隔で奥へ
  cube.position.x = Math.sin(i) * 5; // 左右に大きく散らす
  scene.add(cube);
}

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // カメラを少しずつ前進させる演出
  camera.position.z -= 0.05;

  renderer.render(scene, camera);
}
animate();
```
