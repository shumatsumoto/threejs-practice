## 1. 問題タイトル

75 本目：ガラスマテリアル（PhysicalMaterial）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `MeshPhysicalMaterial` の `transmission`（透過）プロパティ
- `thickness`（厚み）と `ior`（屈折率）の設定
- リアルなガラスの表現

## 3. 新しい概念の解説

**Physical Material Transmission（物理ベースの透過）**
`MeshPhysicalMaterial` は `MeshStandardMaterial` の拡張版で、より高度な表現が可能です。
特に `transmission` プロパティを使うと、ガラスやアクリル樹脂のようなリアルな「透け」表現ができます。
`thickness`（厚み）や `ior`（屈折率）を設定することで、光の歪み具合も物理的にシミュレートされます。

```javascript
const material = new THREE.MeshPhysicalMaterial({
  metalness: 0,
  roughness: 0,       // ツルツルにする
  transmission: 1.0,  // 1.0で完全透過
  thickness: 1.5,     // ガラスの厚み（屈折計算に使われる）
  ior: 1.5            // 屈折率 (Index of Refraction)
});
```

## 4. 課題の説明

`MeshPhysicalMaterial` を使って、リアルなガラスの球体を作成してください。
`Refractor` のようなポストプロセス的な手法ではなく、マテリアルのプロパティとして物理ベースの透過と屈折を実現します。

## 5. 必須要件

以下の機能を実装してください。

- **環境の準備**:
  リアルなガラス表現には「映り込む環境」と「透けて見える中身」が重要です。
  1. 高解像度の環境マップ（Equirectangular）をロードし、`scene.environment` と `background` に設定します。
  2. ガラスの中（または後ろ）に、別の不透明なオブジェクト（Cubeなど）を配置します。

- **物理マテリアルの設定**:
  `new THREE.MeshPhysicalMaterial` を作成し、以下のパラメータを設定します。
  - `transmission: 1.0`（透過を有効化）
  - `roughness: 0.0`（表面は滑らかに）
  - `metalness: 0.0`（非金属）
  - `ior: 1.5`（屈折率：ガラス）
  - `thickness: 1.0` 以上の値（厚みを持たせることで屈折計算が有効になる）

- **確認**:
  球体に適用し、後ろにあるオブジェクトが屈折して見えることを確認します。

## 6. ヒント

- **ヒント 1（マテリアルの選択）**:
  `MeshPhysicalMaterial` を使用します。
  これは Standard の機能に加え、透過やクリアコートなどの高度な物理表現をサポートしています。
- **ヒント 2（Transmission 設定）**:
  `transmission: 1.0` に設定すると、光が物体を透過するようになります。
  ただし、透明度（Opacity）とは異なり、光の物理的な透過シミュレーションです。
- **ヒント 3（物理パラメータ）**:
  `thickness`（厚み）を設定すると、光が内部を通る距離に応じて屈折や減衰が計算されます。
  `ior`（屈折率）は通常 1.5（ガラス）を設定します。
- **ヒント 4（環境マップ）**:
  透過と反射を正しく描画するには、高解像度の環境マップが不可欠です。
  これがないと、ただ透明なだけで質感がでません。
- **ヒント 5（中身の配置）**:
  ガラスの中に別のオブジェクト（不透明なキューブなど）を配置すると、それが歪んで見えるため、屈折効果がより明確に分かります。

## 7. スターターコード

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

// 環境マップ
const loader = new THREE.TextureLoader();
loader.load(
  "https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg",
  (texture) => {
    texture.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = texture;
    scene.background = texture;
  }
);

// 中身（透けて見えるもの）
const innerCube = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
scene.add(innerCube);

// --- ここでガラスの球体を作成 ---
// const material = new THREE.MeshPhysicalMaterial({ ... });

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  innerCube.rotation.x += 0.01;
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

const loader = new THREE.TextureLoader();
loader.load(
  "https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg",
  (texture) => {
    texture.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = texture;
    scene.background = texture;
  }
);

const innerCube = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
scene.add(innerCube);

// ガラスマテリアル
const material = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 0,
  roughness: 0,
  transmission: 1.0, // 透過
  thickness: 1.5, // 厚み（屈折に影響）
  ior: 1.5, // 屈折率（ガラスは1.5くらい）
  clearcoat: 1.0, // 表面のコーティング
  clearcoatRoughness: 0,
});

const sphere = new THREE.Mesh(new THREE.SphereGeometry(2, 32, 32), material);
scene.add(sphere);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  controls.update();

  innerCube.rotation.x += 0.01;
  innerCube.rotation.y += 0.01;

  renderer.render(scene, camera);
}
animate();
```
