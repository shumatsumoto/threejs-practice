## 1. 問題タイトル

47 本目：ビルボード効果（Mesh で実装）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `lookAt` メソッドの応用
- 通常のメッシュを常にカメラに向ける処理
- スプライトを使わないビルボードの実装

## 3. 新しい概念の解説

**Billboarding（ビルボード処理）**
スプライトのように「常にカメラの方を向く」振る舞いのことです。
`lookAt(camera.position)` を毎フレーム実行することで、通常のメッシュ（板ポリゴンなど）でもビルボード効果を実現できます。
スプライトと違い、回転の自由度（Y軸だけ固定など）を自分で制御できるメリットがあります。

```javascript
function animate() {
  requestAnimationFrame(animate);

  // オブジェクトの正面(Z軸)をカメラに向ける
  mesh.lookAt(camera.position);

  renderer.render(scene, camera);
}
```

## 4. 課題の説明

スプライトは自動的にカメラを向きますが、通常の `Mesh`（例えば板ポリゴン）を使って同じ効果（ビルボード）を実装してください。
アニメーションループ内で、メッシュが常にカメラの方を向くように制御します。

## 5. 必須要件

以下の機能を実装してください。

- **メッシュの作成**:
  `PlaneGeometry` と任意のテクスチャを貼ったマテリアルでメッシュを作成します。
  裏面が見える可能性を考慮し、`side: THREE.DoubleSide` を設定します。

- **ビルボード処理の実装**:
  `animate` ループの中で、毎フレーム `mesh.lookAt(camera.position)` を実行します。
  これにより、メッシュのZ軸（法線方向）が常にカメラの方を向くようになります。

- **動作確認**:
  カメラを動かしても、スプライトと同じようにメッシュがこちらを向き続けることを確認します。

## 6. ヒント

- **ヒント 1（基本動作）**:
  `mesh.lookAt(target)` メソッドは、オブジェクトのローカル Z 軸（正面）がターゲットの方を向くように回転させます。
- **ヒント 2（ターゲット）**:
  常に `camera.position` をターゲットに指定すれば、カメラの方を向くようになります。
- **ヒント 3（更新タイミング）**:
  カメラは動くものなので、`animate` ループの中で毎フレーム `mesh.lookAt` を呼び出す必要があります。
- **ヒント 4（スプライトとの違い）**:
  スプライトは常に真正面を向きますが、Mesh のビルボードは「Y 軸回転だけさせたい（木の看板など）」といった細かい制御（軸のロック）が計算で可能です（今回は単純な lookAt で OK）。
- **ヒント 5（裏面）**:
  カメラが回り込んだ瞬間に裏返る挙動になることがあります。
  念のため `side: THREE.DoubleSide` にしておくと、予期せぬ不可視状態を防げます。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.PlaneGeometry(2, 2);
const material = new THREE.MeshBasicMaterial({
  color: 0x00ff00,
  side: THREE.DoubleSide,
});
const plane = new THREE.Mesh(geometry, material);
scene.add(plane);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // カメラ移動
  camera.position.x = Math.sin(Date.now() * 0.001) * 3;

  // --- ここでplaneをカメラに向ける ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// テクスチャ読み込み
const loader = new THREE.TextureLoader();
const texture = loader.load(
  "https://threejs.org/examples/textures/uv_grid_opengl.jpg"
);

const geometry = new THREE.PlaneGeometry(2, 2);
const material = new THREE.MeshBasicMaterial({
  map: texture,
  side: THREE.DoubleSide,
});
const plane = new THREE.Mesh(geometry, material);
scene.add(plane);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // カメラを左右に揺らす
  camera.position.x = Math.sin(Date.now() * 0.001) * 4;
  camera.lookAt(0, 0, 0);

  // メッシュをカメラに向ける（ビルボード処理）
  plane.lookAt(camera.position);

  renderer.render(scene, camera);
}
animate();
```
