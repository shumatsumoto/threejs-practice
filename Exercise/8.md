## 1. 問題タイトル

8 本目：アニメーションループの実装

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `requestAnimationFrame` を使用した描画ループの構築
- 静止画描画とリアルタイムレンダリングの違い

## 3. 新しい概念の解説

**Animation Loop（アニメーションループ）**
静止画ではなく動画（アニメーション）を作るための仕組みです。
「画面を消す」→「少し動かして描く」→「画面を消す」... を高速に繰り返すことで動いているように見せます。

**requestAnimationFrame**
ブラウザが用意している「次の描画タイミング」を教えてくれる関数です。
一般的なモニタでは1秒間に60回（60fps）呼ばれます。この関数の中で自分自身を再度呼び出すことで、無限ループを作ります。

```javascript
function animate() {
  // 次のフレームでまたこの関数を呼ぶようにブラウザに依頼
  requestAnimationFrame(animate);

  // ここに更新処理や描画処理を書く
  renderer.render(scene, camera);
}

// 最初の1回を呼んでループを開始
animate();
```

## 4. 課題の説明

静止画ではなく、アニメーションとして動かすための「描画ループ」を作成してください。
まだ物体は動きませんが、裏側で毎秒 60 回描画処理が走るようにします。

## 5. 必須要件

以下の機能を実装してください。

- **関数の作成**:
  `function animate() { ... }` を作成します。

- **ループ処理**:
  関数内で `requestAnimationFrame(animate);` を呼び出し、自分自身をループさせます。

- **レンダリング**:
  `renderer.render(scene, camera);` をこの関数の中に移動させます（ループ外にあると最初の1回しか描画されません）。

- **開始**:
  コードの最後に `animate();` を一度だけ呼び出して、ループをスタートさせます。
  ※見た目は変わりませんが、内部で毎秒60回描画され続けていれば成功です。

## 6. ヒント

- **ヒント 1（再帰呼び出し）**:
  `animate` 関数の中で `requestAnimationFrame(animate)` を呼ぶことで、「次のフレームでもまた自分を呼んでね」とブラウザに予約し続けます。
- **ヒント 2（無限ループの仕組み）**:
  1. `animate()` 初回実行
  2. `render` 実行
  3. 次回予約
  4. (約16ms後) `animate()` 再実行... これが繰り返されます。
- **ヒント 3（renderの位置）**:
  `renderer.render(scene, camera)` を `animate` 関数の中に移動させないと、画面が更新されません。ループの外にあると最初の1回しか描画されません。
- **ヒント 4（名前慣習）**:
  関数名は `animate` や `tick`、`loop` などがよく使われます。
- **ヒント 5（FPS）**:
  `requestAnimationFrame` は通常、モニタのリフレッシュレート（60Hzなら60fps）に合わせて実行されるので、滑らかなアニメーションになります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);

camera.position.z = 5;

// --- これまでの renderer.render(scene, camera); を削除し、
//     アニメーションループを作成してください ---

// --- ここまで ---
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);

camera.position.z = 5;

// アニメーションループ関数
function animate() {
  // 次のフレームを予約
  requestAnimationFrame(animate);

  // 描画
  renderer.render(scene, camera);
}

// ループ開始
animate();
```
