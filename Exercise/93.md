## 1. 問題タイトル

93 本目：パーティクルベースの VFX（魔法陣）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 複雑な数式によるパーティクル配置
- 回転アニメーションによるエフェクト表現
- 加算合成による光の演出

## 3. 新しい概念の解説

**Math-based Layout & Animation (数式による配置とアニメーション)**
「魔法陣」や「爆発」などのエフェクトは、三角関数（sin, cos）を駆使してパーティクルの座標を計算することで作られます。
`BufferGeometry` の頂点データを直接操作することで、CPU 側で柔軟な動き（波打つ、広がる、集まるなど）をプログラムできます。
`AdditiveBlending`（加算合成）を使うと、光が重なった部分が白く輝き、幻想的な表現になります。

```javascript
// 初期配置：円周上に並べる
const angle = (i / count) * Math.PI * 2;
positions[i*3] = Math.cos(angle) * radius;     // X
positions[i*3 + 1] = 0;                        // Y
positions[i*3 + 2] = Math.sin(angle) * radius; // Z

// アニメーションループ：Y座標をサイン波で波打たせる
function animate() {
  const time = Date.now() * 0.002;
  const positions = geometry.attributes.position.array;
  
  for(let i=0; i<count; i++) {
    // 角度に応じて位相をずらすと波のように見える
    const angle = (i / count) * Math.PI * 2;
    positions[i*3 + 1] = Math.sin(angle * 5 + time) * 0.5;
  }
  
  geometry.attributes.position.needsUpdate = true;
}
```

## 4. 課題の説明

ファンタジーゲームに出てくるような、床で回転しながら光り輝く「魔法陣」のエフェクトを作成してください。
円周上にパーティクルを配置し、全体を回転させたり、パーティクルを上下させたりして神秘的な雰囲気を作ります。

## 5. 必須要件

以下の機能を実装してください。

- **BufferGeometry のセットアップ**:
  `new THREE.BufferGeometry()` を作成し、`position`（xyz）と `color`（rgb）の属性配列（`Float32Array`）を確保します（パーティクル数 `count` の 3 倍の長さ）。

- **数式による初期配置**:
  ループ処理で以下の計算を行い、配列に値をセットします。
  - **半径**: 複数のリングを作るため、`i` に応じて半径を変える（例：`radius = (i % 3 + 1) * 2`）。
  - **角度**: `angle = Math.random() * Math.PI * 2` でランダムな位置、または均等配置。
  - **座標**: `x = cos(angle) * radius`, `z = sin(angle) * radius`, `y = 0`。
  - **色**: `color.setHSL(...)` を使って、青〜紫などの魔法的な色のグラデーションを作る。

- **マテリアル設定**:
  `PointsMaterial` を使い、以下の設定を行って「光る表現」にします。
  - `vertexColors: true`（個別の色を使用）
  - `blending: THREE.AdditiveBlending`（加算合成）
  - `transparent: true`, `depthWrite: false`（透過バグ防止）

- **アニメーション**:
  `animate` ループ内で以下の動きを実装します。
  1. **全体回転**: メッシュ自体の `rotation.y` を回す。
  2. **波打ち**: 各パーティクルの Y 座標を `sin(angle * 5 + time)` などで上下させ、`geometry.attributes.position.needsUpdate = true` で更新する。

## 6. ヒント

- **ヒント 1（円形配置の公式）**:
  半径 `r`、角度 `th` のとき、`x = r * cos(th)`, `z = r * sin(th)` です。
  `th` を `i` に応じてずらしていくことで円を作れます。
- **ヒント 2（アニメーション）**:
  Y 座標に `Math.sin(time + index)` などを足すと、波打つような動きになります。
  `geometry.attributes.position.array` を直接書き換えた後は、必ず `needsUpdate = true` が必要です。
- **ヒント 3（加算合成）**:
  `blending: THREE.AdditiveBlending`、`depthWrite: false`、`transparent: true` の3点セットは、光るパーティクル表現の鉄板設定です。
- **ヒント 4（色の変化）**:
  頂点カラー（`vertexColors: true`）を使うと、パーティクルごとに個別の色を付けられます。
  配列内側と外側で色相（Hue）を変えると綺麗です。
- **ヒント 5（パフォーマンス）**:
  数千個程度なら毎フレーム CPU で座標計算しても動きますが、数万個になると重くなるため、シェーダー（Vertex Shader）での計算に移行するのが次のステップです。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- ここでパーティクル作成 ---

camera.position.set(0, 5, 10);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  // --- アニメーション ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
// 背景を暗く
scene.background = new THREE.Color(0x050510);
document.body.appendChild(renderer.domElement);

const particleCount = 2000;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(particleCount * 3);
const colors = new Float32Array(particleCount * 3);

const color = new THREE.Color();

for (let i = 0; i < particleCount; i++) {
  // 3つのリングを作る
  const radiusBase = ((i % 3) + 1) * 2;
  // 少しばらつきを持たせる
  const radius = radiusBase + (Math.random() - 0.5) * 0.5;
  const angle = Math.random() * Math.PI * 2;

  const x = Math.cos(angle) * radius;
  const z = Math.sin(angle) * radius;
  const y = (Math.random() - 0.5) * 0.5;

  positions[i * 3] = x;
  positions[i * 3 + 1] = y;
  positions[i * 3 + 2] = z;

  // 色（シアン〜紫）
  color.setHSL(0.5 + Math.random() * 0.2, 1.0, 0.5);
  colors[i * 3] = color.r;
  colors[i * 3 + 1] = color.g;
  colors[i * 3 + 2] = color.b;
}

geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
  size: 0.1,
  vertexColors: true,
  blending: THREE.AdditiveBlending,
  transparent: true,
  depthWrite: false,
});

const magicCircle = new THREE.Points(geometry, material);
scene.add(magicCircle);

camera.position.set(0, 8, 12);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  const time = Date.now() * 0.002;

  // 全体回転
  magicCircle.rotation.y = time * 0.2;

  // 波打つ動き
  const pos = geometry.attributes.position.array;
  for (let i = 0; i < particleCount; i++) {
    // Y座標を更新
    // 元のY座標を保持していないので、単純にサイン波で上書き
    // 本来は初期位置を保存しておくべきだが、簡易的に
    const angle = Math.atan2(pos[i * 3 + 2], pos[i * 3]); // 角度再計算
    pos[i * 3 + 1] = Math.sin(angle * 5 + time) * 0.5;
  }
  geometry.attributes.position.needsUpdate = true;

  renderer.render(scene, camera);
}
animate();
```
