## 1. 問題タイトル

50 本目：ポストプロセッシングの基礎（EffectComposer）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `EffectComposer` の導入
- `RenderPass` と `ShaderPass` の仕組み
- 画面全体へのエフェクト適用（セピア、ドット絵など）

## 3. 新しい概念の解説

**Post-Processing（ポストプロセス）**
3D シーンをレンダリングした「後」に、画像処理ソフトのようなエフェクト（フィルター）をかける技術です。
画面全体を白黒にしたり、光を滲ませたり（ブルーム）、ドット絵風にしたりと、映像のクオリティを一気に高めることができます。
`EffectComposer` という仕組みを使って、複数のエフェクトを重ねがけします。

```javascript
// コンポーザーの作成
const composer = new EffectComposer(renderer);

// 1. 通常のレンダリングパスを追加
composer.addPass(new RenderPass(scene, camera));

// 2. エフェクトパスを追加（例：ドット絵風）
const effect = new ShaderPass(DotScreenShader);
composer.addPass(effect);

function animate() {
  // renderer.render(...) の代わりに呼ぶ
  composer.render();
}
```

## 4. 課題の説明

通常のレンダリング結果に対して、後処理（ポストプロセス）を加えて画面の色味を変えてください。
Three.js の `EffectComposer` を使い、標準的なエフェクト（例：DotScreenShader など）を適用します。

## 5. 必須要件

以下の機能を実装してください。

- **モジュールのインポート**:
  `EffectComposer`, `RenderPass`, `ShaderPass`, および使用するシェーダー（`DotScreenShader`など）をインポートします。
  パス：`three/examples/jsm/postprocessing/...`

- **Composerのセットアップ**:
  `new EffectComposer(renderer)` でインスタンスを作成します。
  最初のパスとして `new RenderPass(scene, camera)` を `addPass` します。

- **エフェクトの適用**:
  `new ShaderPass(DotScreenShader)` などを作成し、Composerに追加します。

- **レンダリングループの変更**:
  `animate` 関数内の `renderer.render(scene, camera)` を `composer.render()` に置き換えます。
  画面全体にエフェクトがかかっていることを確認します。

## 6. ヒント

- **ヒント 1（EffectComposerの仕組み）**:
  これは「裏でレンダリングした画像に対して Photoshop のようなフィルタ処理をしてから画面に出す」仕組みです。
  通常：レンダラー -> 画面
  ポストプロセス：レンダラー -> 画像メモリ -> エフェクト処理 -> 画面
- **ヒント 2（RenderPass）**:
  最初に必ず `RenderPass` が必要です。これは「エフェクトなしの普通の 3D シーン」を描画する役割です。これがないと真っ黒になります。
- **ヒント 3（描画関数の変更）**:
  これが最大の忘れポイントです。
  `renderer.render(scene, camera)` を削除し、代わりに `composer.render()` を呼び出します。
- **ヒント 4（インポートパス）**:
  これらは Three.js のコア（`three`）には含まれていません。
  `three/examples/jsm/postprocessing/...` からインポートする必要があります。
- **ヒント 5（リサイズ対応）**:
  ウィンドウサイズが変わった時、renderer だけでなく `composer.setSize(width, height)` も呼ぶ必要があります（今回は必須ではありませんが覚えておくと良いです）。

## 7. スターターコード

```javascript
import * as THREE from "three";
// --- ここで必要なクラスをインポート ---
// import { EffectComposer } ...

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshNormalMaterial()
);
scene.add(cube);

// --- ここでComposerを設定 ---
// const composer = new EffectComposer(renderer);
// composer.addPass(new RenderPass(scene, camera));
// ...

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;

  // renderer.render(scene, camera); の代わりに
  // composer.render();
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass";
import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass";
import { DotScreenShader } from "three/examples/jsm/shaders/DotScreenShader";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshNormalMaterial()
);
scene.add(cube);

// 1. Composerの作成
const composer = new EffectComposer(renderer);

// 2. RenderPass（通常のシーン描画）を追加
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);

// 3. エフェクトパス（ドットスクリーン）を追加
const effectPass = new ShaderPass(DotScreenShader);
effectPass.uniforms["scale"].value = 4; // ドットの大きさ
composer.addPass(effectPass);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;

  // 4. Composerを通してレンダリング
  composer.render();
}
animate();
```
