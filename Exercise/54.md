## 1. 問題タイトル

54 本目：ノイズを使ったシェーダー

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- GLSL での乱数（ノイズ）生成関数
- 砂嵐のようなエフェクトの作成
- `fract` と `sin` を組み合わせた疑似乱数

## 3. 新しい概念の解説

**GLSL Random & Noise（乱数とノイズ）**
GLSL には `Math.random()` のような標準関数がありません。
そのため、三角関数（sin）やフラクタル（fract）などの計算式を組み合わせて、「擬似的な乱数」を作り出す必要があります。
この計算式はシェーダーアートで頻繁に使われる定番テクニックです。

```javascript
/*
  GLSLでの乱数生成（擬似乱数）
  fract(sin(...) * largeNumber) で小数点以下の値を取り出し、
  ランダムな0.0〜1.0の値を作る手法。
*/
const fShader = `
  float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
  }
  
  varying vec2 vUv;
  void main() {
    float r = random(vUv); // 砂嵐のようなノイズ
    gl_FragColor = vec4(vec3(r), 1.0);
  }
`;
```

## 4. 課題の説明

フラグメントシェーダー内で計算式を使ってノイズ（ランダムな値）を生成し、テレビの砂嵐のようなザラザラした模様を表示してください。
GLSL には標準の `random` 関数がないため、自作する必要があります。

## 5. 必須要件

以下の機能を実装してください。

- **乱数関数の実装**:
  フラグメントシェーダー内で `fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453)` を使った `random` 関数を定義します。

- **ノイズ出力**:
  UV座標（`vUv`）を乱数関数に入力し、得られた 0〜1 の値を `gl_FragColor` の RGB にして白黒ノイズを表示します。

- **動的ノイズ**:
  入力する UV 座標に時間（`uTime`）を足すことで、砂嵐のようにザラザラ動くノイズにします。

## 6. ヒント

- **ヒント 1（乱数生成の定石）**:
  GLSL には `Math.random` がありません。
  `fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453)`
  この数式は「擬似乱数」を作る魔法の呪文としてよくコピペで使われます。
- **ヒント 2（fract関数）**:
  `fract(x)` は `x` の小数部分（0.0 〜 0.999...）を返す関数です。
  `sin` の結果を巨大な数で倍増させ、その小数部分を取ることでランダムに見える値を作り出しています。
- **ヒント 3（入力値）**:
  `random(vUv)` のように UV 座標を渡すと、場所ごとに違うノイズ（砂嵐）になります。
- **ヒント 4（アニメーション）**:
  `random(vUv)` だけだと静止したノイズになります。
  `random(vUv + uTime)` のように時間を加算して「入力座標」をずらし続けることで、砂嵐が動いて見えるようになります。
- **ヒント 5（色の出力）**:
  ランダム値は `float`（一桁の数値）なので、`vec3(rnd)` とすることでグレースケール（白黒）の色情報に変換できます。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

const fShader = `
    varying vec2 vUv;
    
    // 乱数生成関数
    float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }

    void main() {
        // --- ここでノイズを出力 ---
        
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
});

const plane = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), material);
scene.add(plane);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

const fShader = `
    varying vec2 vUv;
    uniform float uTime;
    
    float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }

    void main() {
        // 時間を加えることで動くノイズにする
        float rnd = random(vUv + uTime);
        gl_FragColor = vec4(vec3(rnd), 1.0);
    }
`;

const uniforms = {
  uTime: { value: 0.0 },
};

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  uniforms: uniforms,
});

const plane = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), material);
scene.add(plane);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  material.uniforms.uTime.value += 0.1;
  renderer.render(scene, camera);
}
animate();
```
