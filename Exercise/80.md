## 1. 問題タイトル

80 本目：パーティクルアニメーション応用（モーフィング）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- パーティクルの目標位置への移動
- 形状（ジオメトリ）から形状への変形
- 補間（Lerp）を使ったスムーズなアニメーション

## 3. 新しい概念の解説

**Particle Morphing（パーティクルモーフィング）**
多数のパーティクルを、ある形状から別の形状へとスムーズに移動させるアニメーション技術です。
それぞれのパーティクルに対して「現在の座標」と「目標の座標」を持ち、毎フレーム少しずつ目標に近づける（線形補間: Lerp）ことで、砂が形を変えるような美しいエフェクトを実現できます。

```javascript
/*
  線形補間（Lerp）による移動ロジック
  current += (target - current) * factor
  factorが小さいほどゆっくり近づく
*/
function animate() {
  const positions = geometry.attributes.position.array;
  
  for(let i=0; i<count*3; i++) {
    // 現在位置を目標位置に 5% ずつ近づける
    positions[i] += (targetPositions[i] - positions[i]) * 0.05;
  }
  
  geometry.attributes.position.needsUpdate = true;
}
```

## 4. 課題の説明

多数のパーティクルが、最初は「箱」の形に並んでいて、クリックすると「球体」の形にスムーズに移動して変形するアニメーションを作成してください。
2 つのジオメトリから頂点座標を取得し、パーティクルの現在位置と目標位置を管理します。

## 5. 必須要件

以下の機能を実装してください。

- **パーティクル準備**:
  `count = 3000` 程度のパーティクル用 `BufferGeometry` を作成します。
  属性 `position`（初期値はランダムな箱型など）を設定し、`Points` としてシーンに追加します。

- **ターゲット座標の計算**:
  JavaScript の配列として 2 つのターゲット座標セットを用意します。
  1. `boxPositions`: `(Math.random()-0.5) * size` で立方体内に分布。
  2. `spherePositions`: 極座標系 `r, theta, phi` を使って球面上（または球体内）に分布。

- **モーフィング処理（アニメーションループ）**:
  ループ内で `geometry.attributes.position.array` の各頂点座標を更新します。
  `current[i] += (target[i] - current[i]) * speed` （speedは 0.05 程度）。
  更新後は必ず `geometry.attributes.position.needsUpdate = true` を設定します。
  クリックイベントなどで `target` を切り替えられるようにします。

## 6. ヒント

- **ヒント 1（データ構造）**:
  パーティクルの「現在の位置」を持つ `BufferGeometry` の属性とは別に、「目標位置（球体や箱の形の座標）」を配列として JavaScript 側で保持しておきます。
- **ヒント 2（線形補間 Lerp）**:
  アニメーションループ内で `current.x += (target.x - current.x) * 0.05` のように計算すると、徐々に目標に近づく動きになります。
  係数（0.05）を変えると移動速度が変わります。
- **ヒント 3（更新フラグ）**:
  `geometry.attributes.position` の値を書き換えた後は、必ず `needsUpdate = true` をセットしてください。
  これがないと GPU に変更が転送されません。
- **ヒント 4（座標計算）**:
  球面上にランダムに配置するには、極座標系（`r, theta, phi`）を使って計算します。
  箱型は単純に `Math.random()` で範囲内に収めます。
- **ヒント 5（パフォーマンス）**:
  数万個のパーティクルを CPU で計算して転送するのは重いため、本格的な用途では GPGPU（シェーダーでの計算）を使いますが、数千個程度ならこの方法でも十分動きます。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const count = 1000;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(count * 3);
geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

const material = new THREE.PointsMaterial({ size: 0.1, color: 0xffffff });
const particles = new THREE.Points(geometry, material);
scene.add(particles);

// 目標座標の配列
const boxPositions = []; // 箱の形
const spherePositions = []; // 球の形

// --- ここで座標を計算 ---

let currentShape = "box"; // 現在の形状

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // --- ここでパーティクルを移動 ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const count = 2000;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(count * 3);
geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

const material = new THREE.PointsMaterial({ size: 0.05, color: 0x00ffff });
const particles = new THREE.Points(geometry, material);
scene.add(particles);

// ターゲット座標
const boxPositions = [];
const spherePositions = [];

// 座標計算
for (let i = 0; i < count; i++) {
  // Box (ランダムに内部または表面)
  boxPositions.push(
    (Math.random() - 0.5) * 3,
    (Math.random() - 0.5) * 3,
    (Math.random() - 0.5) * 3
  );

  // Sphere (半径2の球面上)
  const phi = Math.acos(-1 + (2 * i) / count);
  const theta = Math.sqrt(count * Math.PI) * phi;
  const r = 2;
  spherePositions.push(
    r * Math.cos(theta) * Math.sin(phi),
    r * Math.sin(theta) * Math.sin(phi),
    r * Math.cos(phi)
  );

  // 初期位置はBox
  positions[i * 3] = boxPositions[i * 3];
  positions[i * 3 + 1] = boxPositions[i * 3 + 1];
  positions[i * 3 + 2] = boxPositions[i * 3 + 2];
}

let useSphere = false;

// クリックで切り替え
window.addEventListener("click", () => {
  useSphere = !useSphere;
});

camera.position.z = 6;

function animate() {
  requestAnimationFrame(animate);

  const target = useSphere ? spherePositions : boxPositions;
  const current = geometry.attributes.position.array;

  // 補間アニメーション
  for (let i = 0; i < count * 3; i++) {
    current[i] += (target[i] - current[i]) * 0.05;
  }

  geometry.attributes.position.needsUpdate = true;

  particles.rotation.y += 0.002;

  renderer.render(scene, camera);
}
animate();
```
