## 1. 問題タイトル

99 本目：パフォーマンス最適化（マージと破棄）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- ジオメトリのマージ（`BufferGeometryUtils.mergeGeometries`）
- ドローコールの削減
- オブジェクト削除時のメモリ解放（`dispose`）

## 3. 新しい概念の解説

**Geometry Merging & Disposal (ジオメトリのマージと破棄)**
数千個のオブジェクトを個別の `Mesh` として描画（ドローコール）すると、CPU/GPU 間の通信オーバーヘッドが大きくなり、フレームレートが低下します。
`BufferGeometryUtils.mergeGeometries` を使って複数のジオメトリを 1 つに統合（マージ）することで、ドローコールを 1 回に減らし、劇的にパフォーマンスを向上させることができます。
また、不要になったオブジェクトは `dispose()` メソッドを呼んで GPU メモリから明示的に解放しないと、メモリリークの原因になります。

```javascript
import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils';

const geometries = [];
for (let i = 0; i < 5000; i++) {
  const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
  // 位置を確定させる（メッシュのpositionではなく、頂点座標自体をずらす）
  geo.translate(Math.random(), Math.random(), Math.random());
  geometries.push(geo);
}

// 配列内のジオメトリを1つに結合
const mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
const mesh = new THREE.Mesh(mergedGeometry, material);
scene.add(mesh); // ドローコールは1回で済む

// 削除時の処理
scene.remove(mesh);
mergedGeometry.dispose(); // GPUメモリ解放
material.dispose();
```

## 4. 課題の説明

大量のオブジェクト（例：5000 個の立方体）を表示してください。
個別に `Mesh` を作ると重くなるため、ジオメトリを 1 つにマージ（結合）して高速化します。
また、クリックしたらシーンから削除し、メモリからも正しく解放（dispose）する処理を実装します。

## 5. 必須要件

以下の機能を実装してください。

- **大量のジオメトリ準備**:
  `BoxGeometry` などのジオメトリをループで多数（例：5000個）生成します。
  それぞれのジオメトリに対して `geometry.translate(x, y, z)` を実行し、**ジオメトリレベルで**位置をバラバラにします（メッシュの位置ではない点に注意）。これらを配列 `geometries` に格納します。

- **マージ（結合）**:
  `BufferGeometryUtils.mergeGeometries(geometries)` を実行し、全ジオメトリを 1 つの `BufferGeometry` に統合します。
  これを使って 1 つだけ `Mesh` を作成し、シーンに追加します（これでドローコールが 1 回になります）。

- **クリーンアップ処理（Dispose）**:
  HTML ボタンを作成し、クリックイベントを実装します。
  クリックされたら以下の手順でメモリ解放を行います。
  1. `scene.remove(mesh)` でシーンから外す。
  2. `mesh.geometry.dispose()` で統合ジオメトリのメモリを解放する。
  3. `mesh.material.dispose()` でマテリアルのメモリを解放する。
  （コンソールに "Disposed" と表示などで確認）

## 6. ヒント

- **ヒント 1（トランスフォーム）**:
  `geometry.translate(x, y, z)` や `rotateX()` などは、「ジオメトリ自体の頂点」を書き換えます。
  マージする前に、個々のジオメトリを所定の位置・回転に変形させておく必要があります。
- **ヒント 2（マテリアル）**:
  マージされたジオメトリは 1 つのメッシュになるため、マテリアルも 1 つしか使えません。
  色を分けたい場合は、テクスチャアトラスを使うか、頂点カラー（Vertex Colors）を使用します。
- **ヒント 3（破棄の手順）**:
  1. `scene.remove(mesh)` で表示リストから外す。
  2. `geometry.dispose()` でバッファメモリ解放。
  3. `material.dispose()` でシェーダープログラム解放。
  4. テクスチャがあれば `texture.dispose()`。
  ここまでやらないとメモリリークします。
- **ヒント 4（制約）**:
  マージした後は「個別に動かす」ことが困難になります。
  動かない背景オブジェクト（木や岩など）の最適化に最適です。
- **ヒント 5（BufferGeometryUtils）**:
  標準の Three.js 本体には含まれていないため、`examples/jsm/utils` から明示的にインポートが必要です。

## 7. スターターコード

```javascript
import * as THREE from "three";
// import * as BufferGeometryUtils ...

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometries = [];
for (let i = 0; i < 5000; i++) {
  const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
  // geo.translate(...);
  geometries.push(geo);
}

// --- ここでマージ ---
// const mergedGeo = BufferGeometryUtils.mergeGeometries(geometries);
// const mesh = new THREE.Mesh(mergedGeo, ...);
// scene.add(mesh);

// 削除処理
// mesh.geometry.dispose(); ...

camera.position.z = 10;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import * as BufferGeometryUtils from "three/examples/jsm/utils/BufferGeometryUtils";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometries = [];
const count = 5000;

for (let i = 0; i < count; i++) {
  const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);

  // ランダムな位置に配置（ジオメトリ自体を移動させる）
  const x = (Math.random() - 0.5) * 10;
  const y = (Math.random() - 0.5) * 10;
  const z = (Math.random() - 0.5) * 10;

  geometry.translate(x, y, z);
  geometries.push(geometry);
}

// マージ（結合）
const mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
const material = new THREE.MeshNormalMaterial();
const mesh = new THREE.Mesh(mergedGeometry, material);
scene.add(mesh);

// 削除ボタン
const btn = document.createElement("button");
btn.innerText = "Dispose (Clean up)";
btn.style.position = "absolute";
btn.style.top = "10px";
btn.style.left = "10px";
document.body.appendChild(btn);

btn.addEventListener("click", () => {
  scene.remove(mesh);
  // メモリ解放（重要）
  mergedGeometry.dispose();
  material.dispose();
  console.log("Disposed!");
});

camera.position.z = 15;

function animate() {
  requestAnimationFrame(animate);

  if (mesh.parent) {
    // シーンに存在する場合のみ
    mesh.rotation.y += 0.002;
  }

  renderer.render(scene, camera);
}
animate();
```
