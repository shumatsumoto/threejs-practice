## 1. 問題タイトル

87 本目：シューティングゲーム（簡易版）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 弾丸（Projectile）の生成と移動
- 衝突判定（弾と敵）
- オブジェクトの削除（メモリ管理）

## 3. 新しい概念の解説

**Object Pooling / Management (オブジェクト管理)**
ゲームでは多数の弾や敵が登場しますが、これらを適切に管理（生成、移動、削除）しないと、メモリリークやパフォーマンス低下の原因になります。
特に Three.js では `scene.remove(mesh)` するだけでなく、ジオメトリやマテリアルの `dispose()` を呼ぶことが推奨されます（今回は簡易的に配列操作のみに焦点を当てますが、知識として重要です）。
衝突判定は「距離（distanceTo）」を使うのが最もシンプルです。

```javascript
// 弾と敵の衝突判定（総当たりチェック）
for (let i = enemies.length - 1; i >= 0; i--) {
  for (let j = bullets.length - 1; j >= 0; j--) {
    const dist = enemies[i].position.distanceTo(bullets[j].position);
    
    if (dist < 1.0) {
      // 衝突したら両方削除
      scene.remove(enemies[i]);
      scene.remove(bullets[j]);
      
      enemies.splice(i, 1);
      bullets.splice(j, 1);
      break; // この敵は消えたので次の弾チェックは不要
    }
  }
}
```

## 4. 課題の説明

スペースキーを押すと弾を発射し、迫ってくる敵（キューブ）を倒すシューティングゲームを作成してください。
弾は奥に向かって飛び、敵は奥から手前に向かってきます。

## 5. 必須要件

以下の機能を実装してください。

- **オブジェクト配列の管理**:
  自機（`player`）、弾丸（`bullets`配列）、敵（`enemies`配列）を用意します。

- **弾の発射**:
  スペースキーが押されたら、小さな球体を作成し、自機の位置に配置して `bullets` に追加します。

- **敵の生成**:
  `setInterval` で 1 秒ごとに敵（Box）を作成し、画面奥（z = -20など）のランダムな X 座標に配置して `enemies` に追加します。

- **移動と更新（アニメーションループ内）**:
  **後ろからループ**（`for (let i = bullets.length - 1; ...)`）を使って配列を操作します。
  1. 弾を奥へ、敵を手前へ移動させます。
  2. **画面外判定**: 一定距離を超えたら `scene.remove` して配列から `splice` します。
  3. **衝突判定**: 全ての弾と全ての敵の距離（`distanceTo`）をチェックし、一定以下なら両方を削除（`remove` & `splice`）します。

## 6. ヒント

- **ヒント 1（ループ中の削除テクニック）**:
  配列を前から順に処理しながら要素を削除（`splice`）すると、インデックスがずれてバグの原因になります。
  `for (let i = bullets.length - 1; i >= 0; i--)` のように後ろからループするのが鉄則です。
- **ヒント 2（衝突判定）**:
  `bullet.position.distanceTo(enemy.position) < (radiusA + radiusB)`
  それぞれの半径の和より距離が近ければ衝突とみなします。
- **ヒント 3（メモリ管理）**:
  画面外に出た弾や敵も忘れずに削除してください。削除しないと永遠に計算され続け、PC が重くなります。
  `scene.remove(mesh)` と `array.splice(i, 1)` の両方が必要です。
- **ヒント 4（発射レート制御）**:
  スペースキー押しっぱなしで連射されすぎないよう、`keydown` イベントではなく、クールタイム変数を設けるか `keyup` を待つ工夫があるとゲームらしくなります。
- **ヒント 5（ジオメトリの使い回し）**:
  弾や敵を毎回 `new Geometry()` するとメモリ効率が悪いです。
  一つ作ったジオメトリを定数に入れておき、全てのメッシュで使い回すのが良いでしょう。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const bullets = [];
const enemies = [];

// 発射
document.addEventListener("keydown", (e) => {
  if (e.code === "Space") {
    // 弾作成
  }
});

// 敵生成
setInterval(() => {
  // 敵作成
}, 1000);

camera.position.y = 2;
camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // --- 移動と衝突判定 ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const bullets = [];
const enemies = [];

// プレイヤー（自機）
const player = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
player.position.set(0, 0, 4);
scene.add(player);

// キー状態管理
const keys = {};
document.addEventListener("keydown", (e) => (keys[e.code] = true));
document.addEventListener("keyup", (e) => (keys[e.code] = false));

// 弾発射
document.addEventListener("keydown", (e) => {
  if (e.code === "Space") {
    const geometry = new THREE.SphereGeometry(0.1);
    const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const bullet = new THREE.Mesh(geometry, material);
    // 自機の位置から発射
    bullet.position.copy(player.position);
    scene.add(bullet);
    bullets.push(bullet);
  }
});

// 敵生成
setInterval(() => {
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
  const enemy = new THREE.Mesh(geometry, material);
  enemy.position.set((Math.random() - 0.5) * 10, 0, -20);
  scene.add(enemy);
  enemies.push(enemy);
}, 1000);

camera.position.set(0, 5, 10);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  // 自機の移動
  if (keys["ArrowLeft"]) player.position.x -= 0.1;
  if (keys["ArrowRight"]) player.position.x += 0.1;

  // 弾の移動
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.position.z -= 0.5; // 奥へ

    // 画面外削除
    if (b.position.z < -30) {
      scene.remove(b);
      bullets.splice(i, 1);
    }
  }

  // 敵の移動と衝突判定
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    e.position.z += 0.1; // 手前へ

    // 衝突判定
    for (let j = bullets.length - 1; j >= 0; j--) {
      const b = bullets[j];
      if (e.position.distanceTo(b.position) < 0.8) {
        // ヒット
        scene.remove(e);
        scene.remove(b);
        enemies.splice(i, 1);
        bullets.splice(j, 1);
        break; // この敵は消えたのでループ抜ける
      }
    }

    // 画面外削除
    if (e.position.z > 10) {
      scene.remove(e);
      enemies.splice(i, 1);
    }
  }

  renderer.render(scene, camera);
}
animate();
```
