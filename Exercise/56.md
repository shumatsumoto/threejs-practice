## 1. 問題タイトル

56 本目：フレネル効果（輪郭が光る表現）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 視線ベクトル（View Vector）と法線ベクトル（Normal）の内積
- エッジ検出の原理
- SF チックな発光表現

## 3. 新しい概念の解説

**Fresnel Effect（フレネル効果）**
「見る角度によって反射率が変わる」という物理現象のことです。
水面やガラスを正面から見ると透明ですが、浅い角度（横）から見ると鏡のように反射して見える現象を指します。
シェーダーでは「視線ベクトルと法線ベクトルの内積」計算することで、エッジ部分（輪郭）だけを発光させる表現に使われます。

```javascript
/*
  vViewPosition: カメラから見た頂点の位置（視線ベクトル用）
  vNormal: 法線ベクトル
*/
const fShader = `
  varying vec3 vNormal;
  varying vec3 vViewPosition;
  
  void main() {
      // 視線と法線の内積（正面だと1.0、真横だと0.0）
      float dotProduct = dot(normalize(vNormal), normalize(vViewPosition));
      
      // 反転して3乗することで、エッジ（0.0に近い部分）を鋭く光らせる
      float fresnel = pow(1.0 - dotProduct, 3.0);
      
      // アルファ値に適用
      gl_FragColor = vec4(0.0, 0.8, 1.0, fresnel);
  }
`;
```

## 4. 課題の説明

球体の中心は透明に近く、輪郭（エッジ）に行くほど明るく光る「フレネル効果」を実装してください。
これはバリアやエネルギーフィールドの表現によく使われます。

## 5. 必須要件

以下の機能を実装してください。

- **法線と視線の取得**:
  頂点シェーダーで `normal`（法線）と `viewVector`（カメラ位置 - 頂点位置）を計算し、正規化して `varying` で渡します。

- **フレネル計算**:
  フラグメントシェーダーで、法線と視線ベクトルの内積 `dot(normal, view)` を計算します。
  内積値（1.0〜0.0）を反転して累乗（`pow(1.0 - dot, 3.0)`）し、エッジ部分のみ高い値になるようにします。

- **合成と透過**:
  計算結果を `gl_FragColor` のアルファ値または色に反映させます。
  `transparent: true` と `blending: THREE.AdditiveBlending` を設定し、球体の輪郭が光り輝いているように見せます。

## 6. ヒント

- **ヒント 1（内積 dot product）**:
  `dot(A, B)` は、ベクトル A と B が「どれくらい同じ向きか」を -1〜1 で返します。
  1.0 なら完全一致、0.0 なら直角（90度）です。
- **ヒント 2（視線と法線）**:
  球体の中心付近では、視線（カメラ方向）と法線（面の向き）はほぼ同じ向きなので `dot` は 1.0 に近くなります。
  球体の輪郭（エッジ）では、視線に対して面が横を向くので `dot` は 0.0 に近くなります。
- **ヒント 3（反転）**:
  今回はエッジ（0.0）を光らせたいので、`1.0 - dot` と計算して、エッジ側を 1.0（白）にします。
- **ヒント 4（強弱）**:
  単なる線形変化ではなく、`pow(val, 3.0)` のように累乗することで、光の帯を細くシャープにすることができます。
- **ヒント 5（透明度）**:
  `transparent: true` と `blending: THREE.AdditiveBlending`（加算合成）を組み合わせると、光り輝くエネルギー体のような綺麗な表現になります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    void main() {
        vNormal = normalize(normalMatrix * normal);
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vViewPosition = -mvPosition.xyz;
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const fShader = `
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    void main() {
        // --- ここでフレネル計算 ---
        
        gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  transparent: true,
  blending: THREE.AdditiveBlending, // 加算合成で光らせる
});

const sphere = new THREE.Mesh(new THREE.SphereGeometry(2, 32, 32), material);
scene.add(sphere);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    void main() {
        vNormal = normalize(normalMatrix * normal);
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vViewPosition = -mvPosition.xyz;
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const fShader = `
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    void main() {
        // 法線と視線の内積（0〜1）
        // 正面から見ると1、横から見ると0
        float dotProduct = dot(normalize(vNormal), normalize(vViewPosition));
        
        // 反転して累乗することで、エッジを鋭く光らせる
        float fresnel = pow(1.0 - dotProduct, 3.0);
        
        // 水色で光らせる
        gl_FragColor = vec4(0.0, 0.8, 1.0, fresnel);
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  transparent: true,
  blending: THREE.AdditiveBlending, // 加算合成
  side: THREE.DoubleSide,
});

const sphere = new THREE.Mesh(new THREE.SphereGeometry(2, 32, 32), material);
scene.add(sphere);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  sphere.rotation.y += 0.005;
  renderer.render(scene, camera);
}
animate();
```
