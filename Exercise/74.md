## 1. 問題タイトル

74 本目：環境マップによる屈折（Refraction Mapping）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `THREE.EquirectangularRefractionMapping` の使用
- 環境マップを使った簡易的な屈折表現
- `refractionRatio` による屈折率の調整

## 3. 新しい概念の解説

**Refraction Mapping（屈折マッピング）**
環境マップは通常「反射」に使われますが、マッピングモードを `EquirectangularRefractionMapping` に変更することで「屈折（透過）」のように見せることができます。
背景画像を歪ませてモデル表面に投影することで、ガラスや水滴を通して背景を見ているような疑似的な表現が可能になります。

```javascript
const texture = new THREE.TextureLoader().load('env.jpg');

// 重要：マッピングモードを「反射」から「屈折」に変更
texture.mapping = THREE.EquirectangularRefractionMapping;

const material = new THREE.MeshBasicMaterial({
  envMap: texture,
  refractionRatio: 0.98 // 1.0で屈折なし。下げるほど大きく歪む。
});
```

## 4. 課題の説明

環境マップを使って、ガラス玉や水滴のような「屈折」を表現してください。
物理ベースの透過（Transmission）とは異なり、こちらは「背景画像（環境マップ）」を歪めて映し出す手法です。
計算コストが低く、古くから使われているテクニックです。

## 5. 必須要件

以下の機能を実装してください。

- **マッピング変更**:
  `TextureLoader` で環境マップ画像をロードし、コールバック内で `texture.mapping = THREE.EquirectangularRefractionMapping` に変更します（デフォルトは Reflection）。
  このテクスチャを `scene.background` と `scene.environment` に設定します。

- **屈折マテリアル**:
  `MeshBasicMaterial`（または Phong/Standard）を作成し、`envMap` に上記のテクスチャを設定します。
  `refractionRatio` プロパティを `0.98` 程度に設定します（1.0 未満にすると拡大、1.0 以上で縮小のような歪みになります）。

- **オブジェクト**:
  球体を作成してこのマテリアルを適用し、背景が歪んで透過しているように見えるか確認します。

## 6. ヒント

- **ヒント 1（マッピングモードの変更）**:
  `texture.mapping = THREE.EquirectangularRefractionMapping;`
  これを設定することで、テクスチャが「反射」ではなく「屈折（透過）」として計算されるようになります。
- **ヒント 2（マテリアル設定）**:
  `envMap` に上記テクスチャを設定します。
  `MeshBasicMaterial` でも `MeshStandardMaterial` でも機能します。
- **ヒント 3（屈折率の調整）**:
  `refractionRatio` プロパティで歪み具合を調整します。
  `0.98`（空気→ガラス）や `0.75`（空気→水）のような値を設定します。`1.0` だと屈折しません。
- **ヒント 4（背景の一致）**:
  `scene.background` にも同じテクスチャを設定しないと、透けた先に見えるものと実際の背景が一致せず、不自然になります。
- **ヒント 5（仕組み）**:
  これは物理的なシミュレーションではなく、単に背景画像を歪めて表示しているだけ（フェイク）なので、非常に高速ですが、裏側にあるオブジェクトなどは透けません。

## 7. スターターコード

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

const loader = new THREE.TextureLoader();
// 環境マップ用画像
const texture = loader.load(
  "https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg"
);

// --- ここでマッピングモードを変更 ---
// texture.mapping = ...

scene.background = texture;

// --- ここでマテリアル作成 ---
// const material = new THREE.MeshBasicMaterial({ envMap: texture });
// material.refractionRatio = 0.98;

const sphere = new THREE.Mesh(
  new THREE.SphereGeometry(2, 32, 32),
  new THREE.MeshNormalMaterial()
);
scene.add(sphere);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

const loader = new THREE.TextureLoader();
// パノラマ画像を読み込む
loader.load(
  "https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg",
  (texture) => {
    // 屈折マッピングに設定（重要）
    texture.mapping = THREE.EquirectangularRefractionMapping;

    scene.background = texture;

    // 屈折マテリアル
    const material = new THREE.MeshBasicMaterial({
      envMap: texture,
      refractionRatio: 0.98, // 屈折率（1.0で変化なし、小さくすると歪む）
    });

    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(2, 64, 64),
      material
    );
    scene.add(sphere);
  }
);

camera.position.z = 6;

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
```
