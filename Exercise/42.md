## 1. 問題タイトル

42 本目：頂点カラーの設定

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 頂点ごとの色指定（Vertex Colors）
- `vertexColors: true` のマテリアル設定
- グラデーション表現の基礎

## 3. 新しい概念の解説

**Vertex Colors（頂点カラー）**
テクスチャ画像を使わずに、頂点データそのものに色情報を持たせる技術です。
頂点 A が赤、頂点 B が青の場合、その間は自動的に滑らかなグラデーションで塗りつぶされます。
`material.vertexColors = true` に設定することで有効になります。

```javascript
// RGBの配列 (0.0 〜 1.0)
const colors = new Float32Array([
  1.0, 0.0, 0.0, // 頂点1: 赤
  0.0, 1.0, 0.0, // 頂点2: 緑
  0.0, 0.0, 1.0  // 頂点3: 青
]);
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

// 必ず vertexColors: true を有効にする
const material = new THREE.MeshBasicMaterial({ vertexColors: true });
```

## 4. 課題の説明

演習 41 で作った三角形の各頂点に異なる色（赤、緑、青）を設定し、面の中で色が滑らかに混ざり合うグラデーションを作成してください。
テクスチャを使わずにカラフルな表現が可能になります。

## 5. 必須要件

以下の機能を実装してください。

- **カラーデータの作成**:
  頂点座標（position）と同じ頂点数分のRGBデータを持つ `Float32Array` を作成します。
  値は 0.0 〜 1.0 の範囲（例: 赤 `1.0, 0.0, 0.0`）で指定します。

- **属性の登録**:
  `geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3))` でジオメトリにカラーデータを登録します。

- **マテリアル設定**:
  `MeshBasicMaterial` の作成時に `{ vertexColors: true }` を設定します。
  これがないと頂点カラーは無視されます。

- **描画確認**:
  三角形の3つの角がそれぞれ異なる色になり、その間がグラデーションで補間されていることを確認します。

## 6. ヒント

- **ヒント 1（データ構造）**:
  頂点座標（position）と同じ数の `color` データを用意します。
  三角形なら 3 頂点なので、色は RGB で 3 つ × 3 頂点 = 9 個の数値が必要です。
- **ヒント 2（色の値）**:
  0〜255 ではなく、`0.0` 〜 `1.0` の範囲で指定します。
  赤は `1.0, 0.0, 0.0` です。
- **ヒント 3（属性名）**:
  必ず `'color'` という名前で登録してください。Three.js のシェーダーはこの名前を探しに行きます。
  `geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3))`
- **ヒント 4（マテリアル設定）**:
  ここが一番の落とし穴です。
  `new THREE.MeshBasicMaterial({ vertexColors: true })`
  このオプションを忘れると、色は反映されず白になります。
- **ヒント 5（補間）**:
  頂点間（例えば赤と青の間）の色は、GPU が自動的に滑らかに補間して紫色のグラデーションを作ってくれます。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BufferGeometry();
const vertices = new Float32Array([
  -1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0, 0.0,
]);
geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));

// --- ここで頂点カラーを設定 ---
// const colors = new Float32Array([ ... ]);
// geometry.setAttribute('color', ...);

// --- マテリアルで vertexColors: true を有効化 ---
const material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide });

const triangle = new THREE.Mesh(geometry, material);
scene.add(triangle);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BufferGeometry();

// 頂点座標
const vertices = new Float32Array([
  -2.0,
  -2.0,
  0.0, // 左下
  2.0,
  -2.0,
  0.0, // 右下
  0.0,
  2.0,
  0.0, // 上
]);
geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));

// 頂点カラー (R, G, B)
const colors = new Float32Array([
  1.0,
  0.0,
  0.0, // 赤
  0.0,
  1.0,
  0.0, // 緑
  0.0,
  0.0,
  1.0, // 青
]);
geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

// マテリアル設定
const material = new THREE.MeshBasicMaterial({
  vertexColors: true, // これが重要
  side: THREE.DoubleSide,
});

const triangle = new THREE.Mesh(geometry, material);
scene.add(triangle);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  triangle.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```
