## 1. 問題タイトル

44 本目：インスタンシング（大量オブジェクト）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `InstancedMesh` の使用方法
- 1 回のドローコールで大量のメッシュを描画する技術
- 行列（Matrix4）による各インスタンスの位置・回転・スケール設定

## 3. 新しい概念の解説

**InstancedMesh（インスタンシング）**
「全く同じ形状・同じマテリアルの物体」を大量に表示するための最適化技術です。
1 つのメッシュデータだけを GPU に送り、「位置・回転・サイズ」の情報だけを個別に渡すことで、1 回の描画命令（ドローコール）で数千〜数万個のオブジェクトを描画できます。

```javascript
const count = 1000;
// InstancedMeshを作成 (ジオメトリ, マテリアル, 個数)
const mesh = new THREE.InstancedMesh(geometry, material, count);

// 計算用ダミーオブジェクト
const dummy = new THREE.Object3D();

for (let i = 0; i < count; i++) {
  dummy.position.set(Math.random(), Math.random(), Math.random());
  dummy.updateMatrix();
  // i番目のインスタンスに行列情報をセット
  mesh.setMatrixAt(i, dummy.matrix);
}
```

## 4. 課題の説明

1000 個のキューブをシーンに配置してください。
普通に `new THREE.Mesh` を 1000 回やると重くなりますが、`InstancedMesh` を使うと非常に高速に描画できます。
各キューブの位置はランダムに設定してください。

## 5. 必須要件

以下の機能を実装してください。

- **InstancedMesh の作成**:
  ジオメトリ（BoxGeometryなど）とマテリアルを1つずつ作成します。
  `new THREE.InstancedMesh(geometry, material, count)` で、指定した個数（例: 1000個）を扱えるインスタンスメッシュを生成します。

- **行列（Matrix）の設定**:
  計算用のダミーオブジェクト（`new THREE.Object3D()`）を用意します。
  ループ内でダミーの位置（`position`）、回転（`rotation`）、スケール（`scale`）をランダムに設定し、`dummy.updateMatrix()` を呼び出します。

- **インスタンスへの適用**:
  `mesh.setMatrixAt(index, dummy.matrix)` を使って、各インデックスに対応する行列データをセットします。

- **描画確認**:
  シーンに追加し、1回のドローコールで大量のキューブが描画されていることを確認します。
  （必要であれば `mesh.instanceMatrix.needsUpdate = true` を設定）

## 6. ヒント

- **ヒント 1（概念）**:
  「1000 個の Mesh を作る」のではなく、「1 個の InstancedMesh を作り、その中に 1000 個分の座標データを持たせる」というイメージです。
- **ヒント 2（ダミーオブジェクト）**:
  行列計算を手動でやるのは大変です。計算用の空オブジェクト `const dummy = new THREE.Object3D()` を用意し、これに対して `position` や `rotation` を設定します。
- **ヒント 3（行列の適用）**:
  `dummy.updateMatrix()` で計算結果を反映させてから、`mesh.setMatrixAt(i, dummy.matrix)` でデータをコピーします。
- **ヒント 4（コンストラクタ）**:
  `new THREE.InstancedMesh(geometry, material, count)`
  第 3 引数の `count` が最大個数になります。これを超えるインデックスにはアクセスできません。
- **ヒント 5（更新フラグ）**:
  もし生成後に位置を動かしたい場合は `mesh.instanceMatrix.needsUpdate = true` が必要になります（今回は初回のみなので不要ですが、動かない場合は確認してください）。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
const material = new THREE.MeshNormalMaterial();

// --- ここでInstancedMeshを作成 ---
// const count = 1000;
// const mesh = new THREE.InstancedMesh(geometry, material, count);
// const dummy = new THREE.Object3D();

// for (let i = 0; i < count; i++) {
//     ...
// }

camera.position.z = 15;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
const material = new THREE.MeshNormalMaterial();

const count = 1000;
const mesh = new THREE.InstancedMesh(geometry, material, count);

const dummy = new THREE.Object3D();

for (let i = 0; i < count; i++) {
  // ランダムな位置
  dummy.position.set(
    (Math.random() - 0.5) * 20,
    (Math.random() - 0.5) * 20,
    (Math.random() - 0.5) * 20
  );

  // ランダムな回転
  dummy.rotation.set(
    Math.random() * Math.PI,
    Math.random() * Math.PI,
    Math.random() * Math.PI
  );

  dummy.updateMatrix();
  mesh.setMatrixAt(i, dummy.matrix);
}

scene.add(mesh);

camera.position.z = 15;

function animate() {
  requestAnimationFrame(animate);

  // 全体を回すことも可能
  mesh.rotation.y += 0.002;

  renderer.render(scene, camera);
}
animate();
```
