## 1. 問題タイトル

77 本目：サブサーフェススキャタリング（SSS）風表現

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `MeshPhysicalMaterial` の `thickness` と `transmission` の応用
- 光が内部で散乱するような質感（ロウソク、肌、翡翠など）
- `attenuationColor`（減衰色）の設定

## 3. 新しい概念の解説

**Subsurface Scattering Style (SSS風表現)**
光が物体の内部に入り込み、散乱してから出てくる現象（サブサーフェススキャタリング）を擬似的に表現する方法です。
人の肌、ロウソク、果物などの柔らかい質感に重要です。
Three.js では `attenuationColor`（光が通過する際に吸収される色）と `attenuationDistance`（吸収されるまでの距離）を設定することで、内部で光が滲むような効果を作ることができます。

```javascript
const material = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  roughness: 0.2,
  metalness: 0.0,
  transmission: 0.8,    // 光を透過させる
  thickness: 2.0,       // 物体の厚み（光が通る距離）
  
  // 内部で吸収されて残る色（例：白光→吸収→オレンジ）
  attenuationColor: 0xffaa00, 
  attenuationDistance: 1.0 // 色が完全に乗るまでの距離（小さいほど濃くなる）
});
```

## 4. 課題の説明

光が物体の内部に入り込み、中で散乱してぼんやりと光る「サブサーフェススキャタリング（SSS）」のような質感を表現してください。
Three.js では完全な SSS は重いですが、`MeshPhysicalMaterial` の透過設定を工夫することで、半透明なプラスチックやゼリーのような質感が作れます。

## 5. 必須要件

以下の機能を実装してください。

- **ライティング設定**:
  サブサーフェススキャタリング（SSS）効果を確認するため、**カメラの反対側（背後）**からオブジェクトを照らす「逆光」のライト（`DirectionalLight`）を配置します。

- **SSS風マテリアル**:
  `MeshPhysicalMaterial` で以下を設定します。
  - `transmission`: 0.6〜0.8（光を通す）。
  - `thickness`: 2.0程度（厚みを持たせる）。
  - `attenuationColor`: `0xffaa00`（オレンジ）など、内部で散乱させたい色。
  - `attenuationDistance`: 1.0程度（この距離で色が完全に吸収される）。
  - `roughness`: 0.2程度。

- **確認**:
  逆光が当たった部分が、指定した `attenuationColor` でぼんやり光る（透ける）ことを確認します。

## 6. ヒント

- **ヒント 1（Transmissionの役割）**:
  `transmission`（透過）を設定することで、光が物体の裏側から透過してくるようになります。
  SSS 表現の基礎となるプロパティです。
- **ヒント 2（Thicknessの効果）**:
  `thickness`（厚み）は物理的な厚さをシミュレートします。
  これが 0 だと薄い膜のようになりますが、数値を大きくすると「厚みのある物体」として光の減衰が計算されます。
- **ヒント 3（Attenuation設定）**:
  `attenuationColor` は「光が吸収されて残る色」です。
  例えば白い光を当てて赤く光らせたい場合、ここを赤色系にします。
  `attenuationDistance` は光が届く距離で、小さいほど光がすぐに吸収されて濃い色になります。
- **ヒント 4（ライトの配置）**:
  SSS 効果は「逆光」で最も顕著になります。
  カメラの向いている方向の逆側（オブジェクトの裏側）に強いライトを配置すると、光が透けてくる様子が観察できます。
- **ヒント 5（パフォーマンス）**:
  `MeshPhysicalMaterial` の透過計算は負荷が高いため、モバイルなどで多用する際は注意が必要です。

## 7. スターターコード

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

// ライト
const dirLight = new THREE.DirectionalLight(0xffffff, 3);
dirLight.position.set(0, 0, -5); // 背後から
scene.add(dirLight);
scene.add(new THREE.AmbientLight(0x404040));

// --- SSS風マテリアル ---
// const material = new THREE.MeshPhysicalMaterial({ ... });

const mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 0), material);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

// 環境マップ（質感向上用）
const loader = new THREE.TextureLoader();
loader.load(
  "https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg",
  (texture) => {
    texture.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = texture;
    scene.background = texture;
  }
);

// 背後からのライト
const dirLight = new THREE.DirectionalLight(0xffffff, 5);
dirLight.position.set(0, 2, -5);
scene.add(dirLight);

const material = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  roughness: 0.2,
  metalness: 0,
  transmission: 0.8, // 透過させる
  thickness: 2.0, // 厚み
  attenuationColor: 0xffaa00, // 内部でオレンジ色になる
  attenuationDistance: 1.0, // 色が変化する距離
});

const mesh = new THREE.Mesh(
  new THREE.TorusKnotGeometry(1, 0.3, 100, 16),
  material
);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  controls.update();

  mesh.rotation.y += 0.005;

  renderer.render(scene, camera);
}
animate();
```
