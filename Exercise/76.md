## 1. 問題タイトル

76 本目：メタリックマテリアル（クリアコート）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `clearcoat` プロパティの使用
- カーペイント（車の塗装）のような質感表現
- 表面の光沢と下地の粗さの分離

## 3. 新しい概念の解説

**Clearcoat (クリアコート)**
車の塗装やニスを塗った木材のように、ベース素材の上に「透明なコーティング層」がある質感を表現する機能です。
`MeshPhysicalMaterial` で使用でき、下地の粗さ（Roughness）とは独立して、表面の光沢（Clearcoat Roughness）を設定できるため、深みのあるリアルな光沢表現が可能になります。

```javascript
const material = new THREE.MeshPhysicalMaterial({
  color: 0xff0000,    // 下地の色（赤）
  metalness: 0.6,
  roughness: 0.5,     // 下地は少しマット
  
  clearcoat: 1.0,     // クリアコート層を有効化 (0.0〜1.0)
  clearcoatRoughness: 0.0 // 表面はピカピカに
});
```

## 4. 課題の説明

車の塗装のように、下地には色と少しのザラつきがあり、その上に透明で滑らかなコーティング層がある「クリアコート」マテリアルを作成してください。
`MeshPhysicalMaterial` を使用します。

## 5. 必須要件

以下の機能を実装してください。

- **環境セットアップ**:
  クリアコートの効果を観察するため、`scene.environment` に環境マップを必ず設定します。

- **カーペイントマテリアルの作成**:
  `MeshPhysicalMaterial` を作成し、以下のように二層構造をシミュレートします。
  1. **下地（ベース）**:
     - `color`: 濃い赤や青など。
     - `roughness`: 0.5 程度（少しザラついている）。
     - `metalness`: 0.6 程度（金属っぽさ）。
  2. **コーティング層**:
     - `clearcoat`: 1.0（コート層を有効化）。
     - `clearcoatRoughness`: 0.0〜0.1（表面はピカピカに）。

- **比較**:
  `clearcoat: 0` の場合と `1` の場合で、光沢の質感がどう変わるか（特にハイライトの入り方）を確認します。

## 6. ヒント

- **ヒント 1（二層構造の理解）**:
  クリアコートは「ベース素材」の上に「透明な薄膜」がある状態をシミュレートします。
  ベースの `roughness` で下地のザラつきを、`clearcoatRoughness` で表面のツヤを個別に制御できます。
- **ヒント 2（マテリアル設定）**:
  `clearcoat: 1.0` で層を有効にし、`clearcoatRoughness: 0.0`〜`0.1` などの低い値で鋭い反射を作ります。
  逆に `clearcoatRoughness` を上げると、すりガラスでコーティングしたような見た目になります。
- **ヒント 3（環境マップ）**:
  反射が命なので、環境マップの設定は必須です。
  これがないと、クリアコートの効果（特にスペキュラ反射）がほとんど分かりません。
- **ヒント 4（ノーマルマップとの関係）**:
  `normalMap`（凹凸）を設定した場合、`clearcoatNormalMap` を別途設定しない限り、クリアコート層は平滑なままです（ニスで埋められたような状態）。
  これもリアルな表現の一つです。
- **ヒント 5（用途）**:
  カーペイント（車の塗装）、漆塗り、濡れた道路、プラスチック製品などの表現に最適です。

## 7. スターターコード

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

const loader = new THREE.TextureLoader();
loader.load(
  "https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg",
  (texture) => {
    texture.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = texture;
    scene.background = texture;
  }
);

// --- ここでカーペイント風マテリアルを作成 ---
// const material = new THREE.MeshPhysicalMaterial({ ... });

const mesh = new THREE.Mesh(
  new THREE.TorusKnotGeometry(1, 0.3, 100, 16),
  material
);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

const loader = new THREE.TextureLoader();
loader.load(
  "https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg",
  (texture) => {
    texture.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = texture;
    scene.background = texture;
  }
);

const material = new THREE.MeshPhysicalMaterial({
  color: 0xff0000, // 赤い塗装
  metalness: 0.6, // 少し金属的
  roughness: 0.5, // 下地は少しマット
  clearcoat: 1.0, // クリアコート層を有効化
  clearcoatRoughness: 0.0, // コーティングはピカピカ
});

const mesh = new THREE.Mesh(
  new THREE.TorusKnotGeometry(1, 0.3, 100, 16),
  material
);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  controls.update();

  mesh.rotation.x += 0.005;
  mesh.rotation.y += 0.005;

  renderer.render(scene, camera);
}
animate();
```
