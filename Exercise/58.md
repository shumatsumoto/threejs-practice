## 1. 問題タイトル

58 本目：ホログラム効果（走査線）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `fract` を使ったストライプ模様の生成
- 半透明と加算合成の組み合わせ
- サイバーパンク風の表現

## 3. 新しい概念の解説

**Hologram Shader（ホログラムシェーダー）**
SF 作品でよく見る、半透明でノイズの混じった立体映像表現です。
「フレネル効果による輪郭発光」と「サイン波による走査線（スキャンライン）」を組み合わせることで作れます。
さらに「加算合成（Additive Blending）」を使うと、光が重なった部分が白くなり、より発光体らしく見えます。

```javascript
const fShader = `
  varying vec3 vPosition; // オブジェクトのローカル座標
  uniform float uTime;
  
  void main() {
      // (フレネル計算省略...)
      
      // Y座標を使ってサイン波（縞模様）を作る
      float scanline = sin(vPosition.y * 50.0 - uTime * 5.0);
      
      // 0未満の部分を切り捨てる（縞模様の隙間を作る）
      if(scanline < 0.0) discard;
      
      gl_FragColor = vec4(0.0, 1.0, 1.0, fresnel);
  }
`;
```

## 4. 課題の説明

物体がホログラム映像のように見えるシェーダーを作成してください。
半透明で青白く光り、水平方向の走査線（スキャンライン）が常に動いているようなエフェクトです。

## 5. 必須要件

以下の機能を実装してください。

- **走査線（スキャンライン）**:
  オブジェクトのローカル座標（Y軸）を `varying` で受け取ります。
  `sin(vPosition.y * 50.0 - uTime)` のような計算式で、横縞模様を作ります。

- **アニメーションと透過**:
  `uTime` で縞模様をスクロールさせます。
  縞の隙間（値が負の部分など）は `discard` するか alpha を 0 にして、ホログラムらしい透け感を作ります。

- **フレネル合成**:
  演習 56 のフレネル効果を同時に適用し、「輪郭が光り、かつ縞模様が走る」サイバーパンクな見た目に仕上げます。
  `blending: THREE.AdditiveBlending` で発光させます。

## 6. ヒント

- **ヒント 1（走査線の作り方）**:
  Y 座標をサイン波に入力します。
  `sin(vPosition.y * 50.0)` と係数を大きくすることで、細かい縞模様になります。ワールド座標ではなくローカル座標を使うと、物体が動いても模様がついてきます。
- **ヒント 2（アニメーション）**:
  `sin(vPosition.y * 50.0 - uTime * 5.0)`
  時間を引く（または足す）ことで、波の位相がずれ、縞模様が上下にスクロールして見えます。
- **ヒント 3（discardによる切り抜き）**:
  `if (sinVal < 0.0) discard;`
  サイン波がマイナスになる部分（縞の黒い部分）を描画せずに捨てることで、ブラインドのような隙間を作ります。
- **ヒント 4（合成）**:
  「フレネル効果（青い光）」と「走査線（模様）」を組み合わせます。
  色は共通で、アルファ値（不透明度）を操作するのが簡単です。
- **ヒント 5（サイバー感）**:
  `blending: THREE.AdditiveBlending`（加算合成）にし、色はシアン（水色）や紫などのネオンカラーを選ぶと、それっぽいホログラムになります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    void main() {
        vNormal = normalize(normalMatrix * normal);
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vViewPosition = -mvPosition.xyz;
        vPosition = position; // ローカル座標
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const fShader = `
    uniform float uTime;
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    
    void main() {
        // フレネル
        float dotProduct = dot(normalize(vNormal), normalize(vViewPosition));
        float fresnel = pow(1.0 - dotProduct, 3.0);
        
        // --- ここで走査線を作成 ---
        
        gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  uniforms: { uTime: { value: 0 } },
  transparent: true,
  blending: THREE.AdditiveBlending,
  side: THREE.DoubleSide,
});

const mesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 3, 32), material);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  material.uniforms.uTime.value += 0.1;
  mesh.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    void main() {
        vNormal = normalize(normalMatrix * normal);
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vViewPosition = -mvPosition.xyz;
        vPosition = position;
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const fShader = `
    uniform float uTime;
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    
    void main() {
        // フレネル
        float dotProduct = dot(normalize(vNormal), normalize(vViewPosition));
        float fresnel = pow(1.0 - dotProduct, 3.0);
        
        // 走査線（Y座標に基づいてサイン波を作る）
        float scanline = sin(vPosition.y * 20.0 - uTime * 5.0);
        // 0〜1の範囲にせず、-1〜1のまま使って点滅させるのもあり
        // ここでは縞模様を強調するため step関数などを使う手もあるが、シンプルに
        if(scanline < 0.0) discard; // 縞の半分を透明にする
        
        vec3 color = vec3(0.0, 1.0, 1.0); // シアン
        
        // フレネルと走査線を組み合わせる
        float alpha = fresnel + 0.5;
        
        gl_FragColor = vec4(color, alpha);
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  uniforms: { uTime: { value: 0 } },
  transparent: true,
  blending: THREE.AdditiveBlending,
  side: THREE.DoubleSide,
});

const mesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 3, 32), material);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  material.uniforms.uTime.value += 0.05;
  mesh.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```
