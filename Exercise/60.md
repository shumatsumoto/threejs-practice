## 1. 問題タイトル

60 本目：水面シェーダー（簡易版）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 頂点シェーダーでの波の動き（演習 52 の応用）
- フラグメントシェーダーでのハイライト表現
- 透過と反射の疑似的な表現

## 3. 新しい概念の解説

**Water Shader（水面シェーダー）**
リアルな水を表現するには、頂点を波打たせる（物理形状の変化）だけでなく、高さに応じた色の変化（低い所は暗い青、高い所は明るい水色や白）を加えるのが効果的です。
頂点シェーダーで計算した高さ（`elevation`）をフラグメントシェーダーに渡し、`mix` 関数で色を合成します。

```javascript
// 頂点シェーダー
const vShader = `
  varying float vElevation; // 高さをフラグメントへ送る
  void main() {
    vec3 pos = position;
    // 波の計算
    pos.z = sin(pos.x * 3.0 + uTime) * 0.2 + sin(pos.y * 2.0) * 0.1;
    vElevation = pos.z;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
`;

// フラグメントシェーダー
const fShader = `
  varying float vElevation;
  void main() {
    // 高さに基づいて色をブレンド
    vec3 color = mix(vec3(0.0, 0.0, 0.5), vec3(0.5, 0.8, 1.0), vElevation * 2.0 + 0.5);
    gl_FragColor = vec4(color, 0.8);
  }
`;
```

## 4. 課題の説明

波打つ水面を作成してください。
演習 52 では形を変えるだけでしたが、今回は色も変化させ、高い部分は白っぽく（泡）、低い部分は青く見えるようにして、より水面らしくします。

## 5. 必須要件

以下の機能を実装してください。

- **頂点操作（波）**:
  演習 52 と同様に頂点を波打たせますが、高さを `varying float vElevation` として保存します。
  複数の `sin` 波（周波数・方向を変えたもの）を合成して、より複雑な波にします。

- **色変化**:
  フラグメントシェーダーで `vElevation` を受け取り、`mix` 関数で色をブレンドします。
  - 低い部分：濃い青（深海）
  - 高い部分：明るい青や白（波頭）

- **マテリアル**:
  `transparent: true`, `opacity: 0.8` 程度に設定し、半透明な水面として表示します。

## 6. ヒント

- **ヒント 1（頂点と色の連携）**:
  Vertex Shader で波の高さを計算し、それを `varying float vElevation` として Fragment Shader に渡します。
  「高い場所ほど白い」などの色分けをするために必要です。
- **ヒント 2（複雑な波）**:
  単一の `sin` 波だと人工的に見えます。
  周波数やスピードの違う波を 2〜3 個足し合わせる（合成波）と、不規則で自然な水面に見えます。
  例: `sin(x) + sin(z * 2.3 + time) * 0.5`
- **ヒント 3（mixによる着色）**:
  Fragment Shader で `mix(deepColor, surfaceColor, vElevation)` を使います。
  高さ（vElevation）が 0.0〜1.0 の範囲になるように調整して渡すと、色が綺麗にブレンドされます。
- **ヒント 4（透明感）**:
  水らしさのポイントは `transparent: true` と `opacity`（またはアルファ値 0.8 など）の設定です。
- **ヒント 5（法線の再計算）**:
  今回は簡易版なので行いませんが、本来は頂点を動かしたら「法線（Normal）」も再計算しないと、光の反射（スペキュラ）がおかしくなります（これは上級編の課題です）。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    uniform float uTime;
    varying float vElevation;
    void main() {
        vec3 pos = position;
        // 複雑な波を作る
        float wave1 = sin(pos.x * 2.0 + uTime);
        float wave2 = sin(pos.y * 1.5 + uTime * 0.5);
        
        pos.z = (wave1 + wave2) * 0.2;
        vElevation = pos.z;
        
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
`;

const fShader = `
    varying float vElevation;
    void main() {
        // --- ここで高さに応じた色を決める ---
        
        gl_FragColor = vec4(0.0, 0.5, 1.0, 0.8);
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  uniforms: { uTime: { value: 0 } },
  transparent: true,
  side: THREE.DoubleSide,
});

const plane = new THREE.Mesh(new THREE.PlaneGeometry(5, 5, 64, 64), material);
plane.rotation.x = -Math.PI / 2; // 水平にする
scene.add(plane);

camera.position.set(0, 3, 5);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  material.uniforms.uTime.value += 0.05;
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    uniform float uTime;
    varying float vElevation;
    void main() {
        vec3 pos = position;
        
        // 複数の波を合成
        float elevation = sin(pos.x * 3.0 + uTime) * 0.2;
        elevation += sin(pos.y * 2.0 + uTime * 0.8) * 0.2;
        
        pos.z = elevation;
        vElevation = elevation;
        
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
`;

const fShader = `
    varying float vElevation;
    void main() {
        vec3 deepColor = vec3(0.0, 0.2, 0.5); // 深い青
        vec3 surfaceColor = vec3(0.4, 0.8, 1.0); // 水色
        
        // 高さに応じて色を混ぜる
        // vElevationは -0.4〜0.4 くらいなので、0〜1に正規化して使う
        float mixStrength = (vElevation + 0.4) * 1.25;
        vec3 color = mix(deepColor, surfaceColor, mixStrength);
        
        gl_FragColor = vec4(color, 0.8);
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  uniforms: { uTime: { value: 0 } },
  transparent: true,
  side: THREE.DoubleSide,
});

const plane = new THREE.Mesh(new THREE.PlaneGeometry(5, 5, 64, 64), material);
plane.rotation.x = -Math.PI / 2;
scene.add(plane);

camera.position.set(0, 4, 4);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  material.uniforms.uTime.value += 0.05;
  renderer.render(scene, camera);
}
animate();
```
