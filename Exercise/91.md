## 1. 問題タイトル

91 本目：物理演算の統合（Cannon.js / Ammo.js）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 物理エンジン（Cannon.js など）の導入
- Three.js のメッシュと物理ボディの同期
- 重力と衝突によるリアルな挙動

## 3. 新しい概念の解説

**Physics Engine Integration (物理エンジンの統合)**
Three.js 自体には物理演算（重力、衝突、摩擦など）の機能はありません。
リアルな挙動を実現するには、`Cannon.js` (または `cannon-es`)、`Ammo.js`、`Rapier` などの外部物理エンジンを導入し、Three.js のメッシュ（見た目）と物理エンジンのボディ（計算上の物体）の位置・回転を毎フレーム同期させる必要があります。

```javascript
import * as CANNON from 'cannon-es';

// 1. 物理ワールドの作成
const world = new CANNON.World();
world.gravity.set(0, -9.82, 0);

// 2. 剛体（Body）の作成
const shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)); // 半分のサイズを指定
const body = new CANNON.Body({ mass: 1, shape: shape });
world.addBody(body);

// 3. アニメーションループで同期
function animate() {
  world.step(1 / 60); // 物理演算を1ステップ進める
  
  // 物理ボディの位置・回転をメッシュにコピー
  mesh.position.copy(body.position);
  mesh.quaternion.copy(body.quaternion);
  
  renderer.render(scene, camera);
}
```

## 4. 課題の説明

物理エンジンを使って、箱を積み上げ、ボールをぶつけて崩すシミュレーションを作成してください。
Three.js 単体では面倒な「衝突応答」や「回転」を物理エンジンに任せます。
今回は軽量で扱いやすい `cannon-es` を想定しますが、概念は他のエンジンでも同じです。

## 5. 必須要件

以下の機能を実装してください。

- **物理ワールドの設定**:
  `new CANNON.World()` を作成し、`world.gravity.set(0, -9.82, 0)` で地球と同じ重力を設定します。

- **静的な地面の作成**:
  1. Three.js: `PlaneGeometry(10, 10)` を作成し、`rotation.x = -Math.PI / 2` で水平にします。
  2. Cannon.js: `new CANNON.Body({ mass: 0 })`（質量0＝動かない）を作成し、`new CANNON.Plane()` 形状を追加します。クォータニオンも `-Math.PI / 2` 回転させて同期させます（`body.quaternion.setFromEuler(...)`）。
  3. 両方をそれぞれのワールドに追加します。

- **動的な箱の作成**:
  1. Three.js: `BoxGeometry(1, 1, 1)` のメッシュを作成します。
  2. Cannon.js: `new CANNON.Body({ mass: 1 })`（質量1＝動く）を作成します。形状は `new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5))` です（Three.js のサイズの半分を指定する点に注意）。
  3. 位置を上空（y=5など）に設定し、ワールドに追加します。
  4. メッシュとボディのペアを配列 `objects` などに保存します。

- **シミュレーションループ**:
  アニメーションループ内で以下の処理を行います。
  1. `world.step(1 / 60)` を呼び出し、物理時間を進める。
  2. `objects` 配列をループし、`mesh.position.copy(body.position)` と `mesh.quaternion.copy(body.quaternion)` を実行して、物理演算の結果を画面上のメッシュに反映させる。

## 6. ヒント

- **ヒント 1（ライブラリの選択）**:
  軽くてモダンな `cannon-es` が推奨されます。
  CDN: `https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js`
- **ヒント 2（形状の注意点）**:
  Three.js の `BoxGeometry(width, height, depth)` は全幅を指定しますが、Cannon.js の `Box(new Vec3(x, y, z))` は「中心からの距離（半幅）」を指定します。
  つまり、Cannon 側には Three.js のサイズの「半分」の値を渡す必要があります。これがズレると見た目と当たり判定が一致しません。
- **ヒント 3（同期処理）**:
  アニメーションループ内で `world.step(1/60)` を呼んだ直後に、全ての動的オブジェクトについて `mesh.position.copy(body.position)` と `mesh.quaternion.copy(body.quaternion)` を行います。
- **ヒント 4（静的オブジェクト）**:
  地面などは動かないので、`mass: 0` に設定します。これで重力の影響を受けず、衝突しても動きません。
- **ヒント 5（タイムステップ）**:
  `1/60` は 60FPS を想定した固定ステップです。より厳密にするなら `clock.getDelta()` を使いますが、まずは固定値で動かすのが簡単です。

## 7. スターターコード

```javascript
import * as THREE from "three";
// import * as CANNON from '...';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 物理ワールド
// const world = new CANNON.World();
// world.gravity.set(0, -9.82, 0);

// 地面（Three.js）
const floorMesh = new THREE.Mesh(
  new THREE.PlaneGeometry(10, 10),
  new THREE.MeshNormalMaterial()
);
floorMesh.rotation.x = -Math.PI / 2;
scene.add(floorMesh);

// 地面（Physics）
// const floorBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
// floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
// world.addBody(floorBody);

// 箱（Three.js & Physics）
// ...

camera.position.set(0, 5, 10);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  // world.step(1 / 60);
  // mesh.position.copy(body.position);
  // mesh.quaternion.copy(body.quaternion);

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import * as CANNON from "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 1. 物理ワールド設定
const world = new CANNON.World();
world.gravity.set(0, -9.82, 0);

// 2. 地面
const floorGeo = new THREE.PlaneGeometry(10, 10);
const floorMat = new THREE.MeshNormalMaterial();
const floorMesh = new THREE.Mesh(floorGeo, floorMat);
scene.add(floorMesh);

const floorBody = new CANNON.Body({
  mass: 0, // 質量0は静的オブジェクト
  shape: new CANNON.Plane(),
});
floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
world.addBody(floorBody);

// メッシュとボディのペアを管理する配列
const objects = [];

function createBox(x, y, z) {
  const width = 1;
  const height = 1;
  const depth = 1;

  // Three.js
  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(width, height, depth),
    new THREE.MeshNormalMaterial()
  );
  scene.add(mesh);

  // Cannon.js
  const shape = new CANNON.Box(
    new CANNON.Vec3(width / 2, height / 2, depth / 2)
  );
  const body = new CANNON.Body({
    mass: 1,
    position: new CANNON.Vec3(x, y, z),
    shape: shape,
  });
  world.addBody(body);

  objects.push({ mesh, body });
}

// 箱を積み上げる
createBox(0, 5, 0);
createBox(0.5, 8, 0);
createBox(-0.5, 12, 0);

camera.position.set(0, 5, 10);
camera.lookAt(0, 2, 0);

function animate() {
  requestAnimationFrame(animate);

  // 物理ステップを進める
  world.step(1 / 60);

  // 位置同期
  objects.forEach((obj) => {
    obj.mesh.position.copy(obj.body.position);
    obj.mesh.quaternion.copy(obj.body.quaternion);
  });

  // 地面メッシュも同期（回転しているので）
  floorMesh.position.copy(floorBody.position);
  floorMesh.quaternion.copy(floorBody.quaternion);

  renderer.render(scene, camera);
}
animate();
```
