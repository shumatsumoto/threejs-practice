## 1. 問題タイトル

88 本目：キャラクター移動システム（滑らかな回転）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- キャラクターの向き（Rotation）の制御
- `Math.atan2` を使った進行方向の計算
- クォータニオンによるスムーズな回転

## 3. 新しい概念の解説

**Smooth Rotation (滑らかな回転)**
キャラクターが進む方向に向きを変える際、`Math.atan2(z, x)` を使って「移動ベクトルの角度」を計算します。
さらに、現在の向きから目標の向きへ瞬時に切り替えるのではなく、クォータニオンの球面線形補間（`slerp`）を使うことで、自然で滑らかな旋回アニメーションを実現できます。

```javascript
/*
  移動ベクトル(dx, dz)から目標角度を計算
  Math.atan2(x, z) で前方(Z+)を基準とした角度が得られる
*/
const targetAngle = Math.atan2(dx, dz);

// 目標角度をクォータニオンに変換
const targetQuaternion = new THREE.Quaternion();
targetQuaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);

// 現在の向きから目標へ、10%ずつ近づける（スムーズ回転）
player.quaternion.slerp(targetQuaternion, 0.1);
```

## 4. 課題の説明

キーボード入力（WASD）でキャラクターを移動させる際、移動する方向に滑らかに体の向きを変えるシステムを作成してください。
いきなりパッと向きが変わるのではなく、徐々に旋回するようにします。

## 5. 必須要件

以下の機能を実装してください。

- **プレイヤー作成**:
  向きが分かる形状（例：顔のある箱）を作成します。

- **移動処理**:
  WASD キー入力に基づいて、X 方向（`dx`）と Z 方向（`dz`）の移動量を決定し、`player.position` を更新します。

- **スムーズな回転（Slerp）**:
  移動している場合（`dx !== 0 || dz !== 0`）：
  1. `Math.atan2(dx, dz)` で進行方向の角度を計算します（Three.js の座標系に合わせて引数の順序を調整してください）。
  2. `targetQuaternion.setFromAxisAngle(axis, angle)` で目標の回転を作成します。
  3. `player.quaternion.slerp(targetQuaternion, 0.1)` を実行し、現在の向きから目標の向きへ 10% だけ近づけます。これにより滑らかな旋回になります。

## 6. ヒント

- **ヒント 1（角度の計算）**:
  `Math.atan2(x, z)` は Z 軸を基準とした角度を返します（Three.js の座標系の場合）。
  モデルの向きが合わない場合はオフセット（例えば `+ Math.PI`）を足して調整します。
- **ヒント 2（スムーズ回転の仕組み）**:
  `mesh.rotation.y` を直接書き換えると、359度→0度の境目でグルっと逆回転してしまう問題が起きます。
  `Quaternion.slerp`（球面線形補間）を使うことで、最短ルートでスムーズに回転できます。
- **ヒント 3（実装手順）**:
  1. 移動ベクトルから目標角度を計算。
  2. 目標角度から `targetQuaternion` を作成。
  3. `currentQuaternion.slerp(targetQuaternion, 0.1)` で少し近づける。
- **ヒント 4（停止時の処理）**:
  キー入力がない（移動ベクトルが 0 の）時は、回転処理を行わないようにします。そうしないと角度が不定になりガタつきます。
- **ヒント 5（カメラとの連動）**:
  もしカメラの向きを考慮して移動させたい場合（カメラ前方へ進むなど）、カメラの回転角も計算に加える必要があります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const player = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
// 正面がわかるように突起をつける
const nose = new THREE.Mesh(
  new THREE.BoxGeometry(0.2, 0.2, 0.5),
  new THREE.MeshBasicMaterial({ color: 0x000000 })
);
nose.position.z = 0.5;
player.add(nose);
scene.add(player);

const keys = {};
document.addEventListener("keydown", (e) => (keys[e.code] = true));
document.addEventListener("keyup", (e) => (keys[e.code] = false));

camera.position.set(0, 5, 10);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  // --- 移動と回転ロジック ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 床
scene.add(new THREE.GridHelper(20, 20));

// プレイヤー
const player = new THREE.Group();
const body = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
const nose = new THREE.Mesh(
  new THREE.BoxGeometry(0.2, 0.2, 0.5),
  new THREE.MeshBasicMaterial({ color: 0x000000 })
);
nose.position.set(0, 0, 0.6); // Z軸プラス方向を正面とする
player.add(body);
player.add(nose);
scene.add(player);

const keys = {};
document.addEventListener("keydown", (e) => (keys[e.code] = true));
document.addEventListener("keyup", (e) => (keys[e.code] = false));

camera.position.set(0, 10, 10);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  let dx = 0;
  let dz = 0;

  if (keys["ArrowUp"] || keys["KeyW"]) dz = -1; // 奥へ（Zマイナス）
  if (keys["ArrowDown"] || keys["KeyS"]) dz = 1;
  if (keys["ArrowLeft"] || keys["KeyA"]) dx = -1;
  if (keys["ArrowRight"] || keys["KeyD"]) dx = 1;

  if (dx !== 0 || dz !== 0) {
    // 移動
    const speed = 0.1;
    player.position.x += dx * speed;
    player.position.z += dz * speed;

    // 目標角度（Math.atan2は(y, x)だが、3DのXZ平面では(x, z)の順序に注意）
    // ここではZ軸プラスが正面(0度)としたい場合などの調整が必要
    // Math.atan2(dx, dz) でベクトル(dx, dz)の角度が得られる
    const targetAngle = Math.atan2(dx, dz);

    // クォータニオンでスムーズ回転
    const targetQuaternion = new THREE.Quaternion();
    targetQuaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);

    player.quaternion.slerp(targetQuaternion, 0.1);
  }

  // カメラ追従
  camera.position.x = player.position.x;
  camera.position.z = player.position.z + 10;

  renderer.render(scene, camera);
}
animate();
```
