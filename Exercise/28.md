## 1. 問題タイトル

28 本目：カメラの移動アニメーション

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- カメラ座標の動的な制御
- 三角関数（Sin/Cos）を使った円運動
- `camera.lookAt` による注視点の固定

## 3. 新しい概念の解説

**Camera Animation（カメラアニメーション）**
物体を動かすのではなく、「視点」を動かすことでダイナミックな映像を作れます。
`camera.lookAt(target)` を毎フレーム呼ぶことで、移動しながら常に同じ場所を見続けることができます。

**Circular Motion（円運動）**
`Math.sin(角度)` と `Math.cos(角度)` を組み合わせることで、円を描く動きを作れます。
- X = 半径 × sin(θ)
- Z = 半径 × cos(θ)
この公式はゲーム開発で非常によく使われます。

```javascript
const radius = 10;
const angle = Date.now() * 0.001; // 時間経過で角度を変える

camera.position.x = radius * Math.sin(angle);
camera.position.z = radius * Math.cos(angle);
camera.lookAt(0, 0, 0); // 原点を見続ける
```

## 4. 課題の説明

シーンの中央にあるキューブの周りを、カメラが自動的に周回するアニメーションを作成してください。
まるでドローンで空撮しているような映像を作ります。

## 5. 必須要件

以下の機能を実装してください。

- **シーンのセットアップ**:
  中央にターゲットとなるキューブを配置します。
  位置関係が把握しやすいよう `GridHelper` を床に追加します。

- **円運動の実装**:
  `animate` 関数内で時間（`Date.now()` またはカウンタ）に応じた角度 `angle` を計算します。
  `camera.position.x = Math.sin(angle) * 半径`
  `camera.position.z = Math.cos(angle) * 半径`
  でカメラを円軌道上で動かします。

- **注視点の固定**:
  カメラ位置を更新した**直後に** `camera.lookAt(0, 0, 0)` を呼び出し、常に原点のキューブを見続けるようにします。

- **動作確認**:
  キューブを中心に、カメラが周囲をグルグル回る映像になっていることを確認します。

## 6. ヒント

- **ヒント 1（円運動の数学）**:
  `x = cos(角度) * 半径`
  `z = sin(角度) * 半径`
  （sin と cos はどちらを X/Z に使っても円になりますが、開始位置が変わるだけです）
- **ヒント 2（LookAt）**:
  カメラの位置を動かした **後** に、必ず `camera.lookAt(0, 0, 0)` を実行してください。
  そうしないと、カメラは明後日の方向を向いたまま移動してしまいます。
- **ヒント 3（角度の更新）**:
  変数 `angle` を用意し、アニメーションループ内で `angle += 0.01` のように増やしていきます。これが回転速度になります。
- **ヒント 4（高さ）**:
  Y 座標を固定（例: `y = 5`）にしておけば、少し見下ろすようなアングルで周回できます。
- **ヒント 5（半径）**:
  半径を大きくすれば引きの映像、小さくすれば寄りの映像になります。動的に半径を変えれば螺旋（スパイラル）移動も可能です。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true })
);
scene.add(cube);

// グリッドの追加（カメラの移動をわかりやすくするため）
const gridHelper = new THREE.GridHelper(20, 20);
scene.add(gridHelper);

let angle = 0;
const radius = 5;

function animate() {
  requestAnimationFrame(animate);

  // --- ここでカメラ位置を更新 ---

  // --- ここでカメラの向きを更新 ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true })
);
scene.add(cube);

// グリッドの追加（カメラの移動をわかりやすくするため）
const gridHelper = new THREE.GridHelper(20, 20);
scene.add(gridHelper);

let angle = 0;
const radius = 5;

function animate() {
  requestAnimationFrame(animate);

  // 角度を少しずつ増やす
  angle += 0.01;

  // 円運動の計算
  camera.position.x = radius * Math.sin(angle);
  camera.position.z = radius * Math.cos(angle);
  camera.position.y = 2; // 少し高い位置から

  // 常に原点（キューブの位置）を見る
  camera.lookAt(0, 0, 0);

  renderer.render(scene, camera);
}
animate();
```
