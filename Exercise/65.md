## 1. 問題タイトル

65 本目：RGB シフト（色収差）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `ShaderPass` と `RGBShiftShader` の使用
- 色のチャンネルをずらす視覚効果
- レトロな映像表現やダメージ表現

## 3. 新しい概念の解説

**RGB Shift / Chromatic Aberration（RGBシフト・色収差）**
レンズの特性で色がずれて見える現象（色収差）を意図的に強調したエフェクトです。
R（赤）、G（緑）、B（青）の表示位置を微妙にずらすことで、VHS ビデオのようなレトロ感や、衝撃を受けたような激しい印象を与えることができます。

```javascript
import { RGBShiftShader } from 'three/examples/jsm/shaders/RGBShiftShader';

const rgbShiftPass = new ShaderPass(RGBShiftShader);
rgbShiftPass.uniforms['amount'].value = 0.005; // ずらし量
composer.addPass(rgbShiftPass);
```

## 4. 課題の説明

画面の R（赤）、G（緑）、B（青）の成分を少しずらして表示する「RGB シフト（色収差）」エフェクトを追加してください。
VHS ビデオのようなレトロな雰囲気や、衝撃を受けた時の表現に使えます。

## 5. 必須要件

以下の機能を実装してください。

- **RGBShiftShader の利用**:
  `three/examples/jsm/shaders/RGBShiftShader` をインポートします。
  `ShaderPass(RGBShiftShader)` を作成して Composer に追加します。

- **パラメータ調整**:
  パスの `uniforms['amount'].value` を `0.005` 程度に設定し、色のズレ（色収差）を確認します。
  アニメーションループ内でこの値を `Math.sin` などで変動させ、画面が揺れるようなエフェクトを作ります。

## 6. ヒント

- **ヒント 1（必要なクラスのインポート）**:
  `ShaderPass` と `RGBShiftShader` が必要です。
  `three/examples/jsm/postprocessing/ShaderPass`
  `three/examples/jsm/shaders/RGBShiftShader`
- **ヒント 2（ShaderPassの利用）**:
  `const pass = new ShaderPass(RGBShiftShader);` のように、シェーダー定義を渡してパスを作成します。
  これが `ShaderPass` の基本的な使い方です。
- **ヒント 3（パラメータアクセス）**:
  `pass.uniforms['amount'].value` でズレの量を制御できます。
  `pass.uniforms['angle'].value` でズレる方向（角度）も変えられます。
- **ヒント 4（アニメーション）**:
  `animate` ループ内で `pass.uniforms['amount'].value = Math.sin(Date.now()) * 0.01` のように値を変動させると、画面が揺れるような演出が作れます。
- **ヒント 5（組み合わせ）**:
  他のパス（BloomPassなど）と組み合わせる場合、パスを追加する順番で結果が変わることがあります。
  通常は色調補正系を最後の方に持ってきます。

## 7. スターターコード

```javascript
import * as THREE from "three";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass";
import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass";
// import { RGBShiftShader } ...

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshNormalMaterial()
);
scene.add(cube);

// --- ComposerとRGBShift ---

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
  // composer.render();
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass";
import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass";
import { RGBShiftShader } from "three/examples/jsm/shaders/RGBShiftShader";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshNormalMaterial()
);
scene.add(cube);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

// RGBシフトパス
const rgbShiftPass = new ShaderPass(RGBShiftShader);
rgbShiftPass.uniforms["amount"].value = 0.005; // ずらす量
composer.addPass(rgbShiftPass);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;

  // 時間経過でずらす量を変える演出も面白い
  rgbShiftPass.uniforms["amount"].value =
    0.005 + Math.sin(Date.now() * 0.01) * 0.002;

  composer.render();
}
animate();
```
