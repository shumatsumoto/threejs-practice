## 1. 問題タイトル

62 本目：爆発エフェクト（全方向への拡散）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 球面状に広がるパーティクルの計算
- 減速処理（摩擦）の実装
- ワンショットエフェクトの制御

## 3. 新しい概念の解説

**Spherical Distribution（球面配置）**
パーティクルを「爆発」させるには、中心点から全方向へ均等に飛ばす必要があります。
ランダムに XYZ を決めるだけでは立方体状に偏ってしまうため、三角関数を使って球面上に配置するか、ベクトルを正規化（`normalize`）して向きを整えます。 また、空気抵抗による「減速（Friction）」を加えることで、爆発の勢いが衰えるリアルな表現になります。

```javascript
// ランダムな方向ベクトル（球面均等ではない簡易版だが、正規化で球状になる）
const velocity = new THREE.Vector3(
  Math.random() - 0.5,
  Math.random() - 0.5,
  Math.random() - 0.5
).normalize().multiplyScalar(0.5); // 速度調整

// 減速処理（毎フレーム掛ける）
velocity.multiplyScalar(0.95);
```

## 4. 課題の説明

クリックした地点（または画面中央）で爆発が起きるエフェクトを作成してください。
多数のパーティクルが中心から全方向に飛び散り、徐々に減速して消えていきます。

## 5. 必須要件

以下の機能を実装してください。

- **プール方式**:
  パーティクル用メッシュを200個程度事前に作成し、`visible = false` にしておきます。

- **爆発トリガー**:
  クリックイベント時に、全てのパーティクルに対して以下を行います。
  1. `visible = true` にする。
  2. 位置を原点（爆発中心）にリセット。
  3. 速度ベクトルを計算：`random() - 0.5` をXYZに適用して正規化（`normalize`）し、ランダムな強さを掛け算して「球状」に飛び散るようにする。

- **物理更新**:
  ループ内で各パーティクルを移動させます。
  1. `position += velocity`
  2. `velocity *= 0.95` （摩擦で減速）
  3. 完全に止まるか透明になったら `visible = false` に戻す。

## 6. ヒント

- **ヒント 1（オブジェクトプール）**:
  爆発の瞬間に `new Mesh` すると重くなるため、あらかじめ `visible = false` でシーンに追加しておき、使う時だけ `visible = true` にするのが定石です。
- **ヒント 2（球面上への配置）**:
  `Math.random() - 0.5` を XYZ それぞれに適用したベクトルを作り、`.normalize()`（正規化）すると、長さ 1 の球面上に配置できます。
  それにランダムな数値を掛ければ速度にばらつきが出ます。
- **ヒント 3（物理挙動・摩擦）**:
  アニメーションループ内で `velocity.multiplyScalar(0.95)` のように 1 未満の値を掛けると、徐々に減速する（空気抵抗のような）動きになります。
- **ヒント 4（寿命管理）**:
  各パーティクルに `life` を持たせ、0 になったら `visible = false` にして隠します。
  配列をループして全パーティクルを更新しましょう。
- **ヒント 5（回転）**:
  飛び散る際に `mesh.rotation.x += ...` で回転も加えると、破片が舞っているようなリアリティが出ます。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- 爆発用パーティクル管理 ---
const particles = [];

function explode() {
  // ここでパーティクルを初期化
}

// クリックで爆発
window.addEventListener("click", explode);

camera.position.z = 10;

function animate() {
  requestAnimationFrame(animate);

  // --- ここでパーティクル更新 ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const material = new THREE.MeshBasicMaterial({ color: 0xff5500 });
const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);

const particles = [];
const particleCount = 200;

// プールしておく
for (let i = 0; i < particleCount; i++) {
  const mesh = new THREE.Mesh(geometry, material);
  mesh.visible = false;
  scene.add(mesh);
  particles.push({
    mesh: mesh,
    velocity: new THREE.Vector3(),
    life: 0,
  });
}

function explode() {
  particles.forEach((p) => {
    p.mesh.visible = true;
    p.mesh.position.set(0, 0, 0);

    // ランダムな方向
    p.velocity
      .set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5)
      .normalize()
      .multiplyScalar(Math.random() * 0.5); // 速さもランダム

    p.life = 1.0;
  });
}

window.addEventListener("click", explode);
// 最初の一回
setTimeout(explode, 1000);

camera.position.z = 10;

function animate() {
  requestAnimationFrame(animate);

  particles.forEach((p) => {
    if (p.life > 0) {
      p.mesh.position.add(p.velocity);
      p.velocity.multiplyScalar(0.95); // 減速（摩擦）
      p.life -= 0.02;

      p.mesh.scale.setScalar(p.life); // 小さくする
      p.mesh.rotation.x += 0.1;

      if (p.life <= 0) p.mesh.visible = false;
    }
  });

  renderer.render(scene, camera);
}
animate();
```
