## 1. 問題タイトル

100 本目：銀河シミュレーション（総合制作）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `BufferGeometry` を使った大量のパーティクル制御（5 万個以上）
- 数学的な螺旋形状の生成アルゴリズム
- `AdditiveBlending` とポストプロセスによる発光表現
- 頂点カラーによるグラデーション

## 3. 新しい概念の解説

**Generative Art & Post-processing (ジェネラティブアートとポストプロセス)**
これまで学んだ技術の集大成です。
手動で配置するのではなく、数学的アルゴリズム（螺旋の数式など）に基づいて数万個の頂点座標と色をプログラムで生成します。
さらに、`UnrealBloomPass` などのポストプロセスを組み合わせることで、ただの点の集まりを、光り輝く美しい「銀河」へと昇華させます。
技術力と表現力を組み合わせる、クリエイティブコーディングの醍醐味です。

```javascript
// 銀河の座標計算例
const spinAngle = radius * spin; // 外周ほど強く回す
const branchAngle = ((i % branches) / branches) * Math.PI * 2; // 枝の角度

const x = Math.cos(branchAngle + spinAngle) * radius + randomX;
const y = randomY;
const z = Math.sin(branchAngle + spinAngle) * radius + randomZ;

// ポストプロセス（Bloom）
const renderPass = new RenderPass(scene, camera);
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(width, height),
  1.5,  // 強度
  0.4,  // 半径
  0.85  // 閾値
);
const composer = new EffectComposer(renderer);
composer.addPass(renderPass);
composer.addPass(bloomPass);
```

## 4. 課題の説明

数万個のパーティクルを使って、美しく輝く「渦巻き銀河」を生成してください。
ただランダムに配置するのではなく、数学的な計算（三角関数）を用いて螺旋状のアームを作り、中心から外側にかけて色が変化するようにします。
さらに、ポストプロセス（Bloom）を使って、星々が輝いているように見せてください。

## 5. 必須要件

以下の機能を実装してください。

- **銀河のパラメータ設定**:
  以下のプロパティを持つ `parameters` オブジェクトを作成してください。
  - `count`: 100000（星の数）
  - `size`: 0.01（星のサイズ）
  - `radius`: 5（銀河の半径）
  - `branches`: 3（腕の数）
  - `spin`: 1（スピンの強さ）
  - `randomness`: 0.2（散らばり具合）
  - `randomnessPower`: 3（中心への集中度）
  - `insideColor`: "#ff6030"（中心の色）
  - `outsideColor`: "#1b3984"（外側の色）

- **BufferGeometry の作成**:
  `new THREE.BufferGeometry()` を作成し、`position`（xyz座標）と `color`（RGB値）を格納するための `Float32Array` を用意します（サイズは `count * 3`）。

- **頂点座標の計算（ループ処理）**:
  `for` ループで `i` を 0 から `count` まで回し、以下の手順で座標を計算して配列に格納します。
  1. **半径**: `Math.random() * parameters.radius` でランダムな距離を決める。
  2. **スピン角度**: `radius * parameters.spin` で、外側ほど回転させる。
  3. **枝の角度**: `((i % parameters.branches) / parameters.branches) * Math.PI * 2` で、星を 3 方向（120度ごと）に振り分ける。
  4. **基本座標**: `x = Math.cos(branchAngle + spinAngle) * radius`, `z = Math.sin(...) * radius` で渦巻き状に配置。
  5. **ランダムな散らばり**: `Math.pow(Math.random(), parameters.randomnessPower)` を使って、中心に集まるような乱数を生成し、x, y, z に加算して厚みと自然な広がりを持たせる。

- **色の計算**:
  `insideColor` と `outsideColor` を `THREE.Color` オブジェクトとして作成し、`color.lerp(outsideColor, radius / parameters.radius)` を使って中心から外側へのグラデーションを計算し、`color` 配列に RGB 値を格納します。

- **マテリアルとメッシュ**:
  `THREE.PointsMaterial` を作成し、以下を設定します。
  - `size`: `parameters.size`
  - `sizeAttenuation`: `true`（遠近感あり）
  - `depthWrite`: `false`
  - `blending`: `THREE.AdditiveBlending`（加算合成）
  - `vertexColors`: `true`（頂点カラー有効）
  
  これらを使って `THREE.Points` メッシュを作成し、シーンに追加します。

- **ポストプロセス（発光）**:
  `EffectComposer` を設定し、`RenderPass` と `UnrealBloomPass` を追加して、銀河全体を発光させます。
  Bloom のパラメータ目安: `strength: 1.5`, `radius: 0.4`, `threshold: 0`。

- **アニメーション**:
  `requestAnimationFrame` 内で `points.rotation.y` を少しずつ増やし、銀河全体を回転させます。

## 6. ヒント

- **ヒント 1（分布の偏り）**:
  `Math.random()` は均一な乱数ですが、`Math.pow(Math.random(), n)` のように累乗すると、0 付近（中心）に集まる偏った乱数を作れます。これで銀河の中心核を表現できます。
- **ヒント 2（螺旋の数式）**:
  基本的な円の方程式 `x = cos(t), z = sin(t)` に、「中心からの距離に応じた追加の回転（半径 * spin）」を加えることで、渦巻き状の形状になります。
- **ヒント 3（色の補間）**:
  `color.lerp(targetColor, ratio)` を使うと、2 つの色の中間色を簡単に作れます。
  中心からの距離を 0〜1 に正規化して `ratio` に使います。
- **ヒント 4（Bloomの設定）**:
  `UnrealBloomPass` の `threshold`（閾値）を調整し、銀河の星だけが光るようにします。また、背景を真っ黒（`0x000000`）にするのも発光を目立たせるコツです。
- **ヒント 5（頂点カラーの有効化）**:
  `PointsMaterial` で `vertexColors: true` に設定しないと、`geometry.attributes.color` にデータを入れても無視されるので注意してください。

## 7. スターターコード

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

// --- ここで銀河生成ロジック ---
// const geometry = new THREE.BufferGeometry();
// ...

camera.position.set(0, 3, 5);

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass";
import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass";

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 20, 40);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// --- 銀河のパラメータ ---
const parameters = {
  count: 100000, // 星の数
  size: 0.02, // 星の大きさ
  radius: 20, // 銀河の半径
  branches: 3, // 枝の数
  spin: 1, // 巻き具合
  randomness: 0.2, // 散らばり
  randomnessPower: 3, // 散らばりの指数（中心に集める）
  insideColor: "#ff6030", // 中心の色
  outsideColor: "#1b3984", // 外側の色
};

let geometry = null;
let material = null;
let points = null;

const generateGalaxy = () => {
  // 古いものを削除
  if (points !== null) {
    geometry.dispose();
    material.dispose();
    scene.remove(points);
  }

  geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(parameters.count * 3);
  const colors = new Float32Array(parameters.count * 3);

  const colorInside = new THREE.Color(parameters.insideColor);
  const colorOutside = new THREE.Color(parameters.outsideColor);

  for (let i = 0; i < parameters.count; i++) {
    const i3 = i * 3;

    // 半径（0〜radius）
    const radius = Math.random() * parameters.radius;

    // 角度（スピン + 枝分かれ）
    const spinAngle = radius * parameters.spin;
    const branchAngle =
      ((i % parameters.branches) / parameters.branches) * Math.PI * 2;

    // ランダムな散らばり（X, Y, Z）
    const randomX =
      Math.pow(Math.random(), parameters.randomnessPower) *
      (Math.random() < 0.5 ? 1 : -1) *
      parameters.randomness *
      radius;
    const randomY =
      Math.pow(Math.random(), parameters.randomnessPower) *
      (Math.random() < 0.5 ? 1 : -1) *
      parameters.randomness *
      radius;
    const randomZ =
      Math.pow(Math.random(), parameters.randomnessPower) *
      (Math.random() < 0.5 ? 1 : -1) *
      parameters.randomness *
      radius;

    positions[i3] = Math.cos(branchAngle + spinAngle) * radius + randomX;
    positions[i3 + 1] = randomY; // 厚み
    positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ;

    // 色（中心から外側へのグラデーション）
    const mixedColor = colorInside.clone();
    mixedColor.lerp(colorOutside, radius / parameters.radius);

    colors[i3] = mixedColor.r;
    colors[i3 + 1] = mixedColor.g;
    colors[i3 + 2] = mixedColor.b;
  }

  geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

  material = new THREE.PointsMaterial({
    size: parameters.size,
    sizeAttenuation: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    vertexColors: true,
  });

  points = new THREE.Points(geometry, material);
  scene.add(points);
};

generateGalaxy();

// --- ポストプロセス（輝き） ---
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.5,
  0.4,
  0.85
);
bloomPass.threshold = 0;
bloomPass.strength = 1.5;
bloomPass.radius = 0;
composer.addPass(bloomPass);

// --- アニメーション ---
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);

  const elapsedTime = clock.getElapsedTime();

  // 銀河全体をゆっくり回転
  points.rotation.y = elapsedTime * 0.05;

  controls.update();
  composer.render();
}
animate();
```
