## 1. 問題タイトル

59 本目：ディゾルブ効果（消滅エフェクト）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- ノイズテクスチャを使ったしきい値処理
- `discard` によるピクセルの破棄
- オブジェクトが徐々に消えていく演出

## 3. 新しい概念の解説

**Dissolve Effect（ディゾルブエフェクト）**
テレポートや死亡エフェクトなどで見られる、物体が徐々に消滅する表現です。
ノイズ画像の白黒（0.0〜1.0）を「消える順番」として利用します。
シェーダー内の `discard` 命令を使うと、特定の条件（例：進行度がノイズ値を超えた）を満たすピクセルを「描画しない（穴を開ける）」ことができます。

```javascript
const fShader = `
  uniform sampler2D uNoiseMap;
  uniform float uProgress; // 0.0 〜 1.0
  varying vec2 vUv;
  
  void main() {
      float noise = texture2D(uNoiseMap, vUv).r;
      
      // ノイズの値が進行度より小さくなったら描画しない
      if (noise < uProgress) discard;
      
      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
  }
`;
```

## 4. 課題の説明

ノイズ画像を使って、オブジェクトが燃え尽きるように（または溶けるように）消えていくディゾルブエフェクトを作成してください。
`uProgress`（0〜1）の値を変化させると、ノイズの白い部分から順に穴が空いていき、最後には完全に消滅させます。

## 5. 必須要件

以下の機能を実装してください。

- **ノイズテクスチャ利用**:
  パーリンノイズなどの画像を `uniform sampler2D` として読み込みます。
  フラグメントシェーダーで `texture2D` を使って値（0〜1）を取得します。

- **消滅ロジック**:
  `uProgress`（0〜1）とノイズ値を比較し、`noise < uProgress` なら `discard` してピクセルを描画しないようにします。

- **エッジ発光**:
  消える境界線（`noise` が `uProgress` に近い領域）だけ色を変え（例：オレンジ色）、燃えながら消えるような演出を加えます。
  JS側で `uProgress` をアニメーションさせます。

## 6. ヒント

- **ヒント 1（ノイズテクスチャ）**:
  雲模様（Perlin Noise）のような画像を使うのがベストです。今回は JS で簡易生成しましたが、Photoshop などで作った画像を読み込んでも OK です。
- **ヒント 2（閾値処理）**:
  `float noise = texture2D(uNoiseMap, vUv).r;`
  この `noise` 値（0.0〜1.0）が、そのピクセルの「消えにくさ（HP）」を表します。
  `uProgress`（ダメージ）が `noise` を上回ったら `discard`（死亡）させます。
- **ヒント 3（エッジの検出）**:
  「消えた直後の部分」＝「`noise` が `uProgress` より少しだけ大きい部分」です。
  `if (noise < uProgress + 0.05)` のような条件で検出して色を変えると、燃える境界線になります。
- **ヒント 4（DoubleSide）**:
  穴が空くと物体の裏側が見えるので、マテリアル設定で `side: THREE.DoubleSide` にしておくと、立体感が保たれます。
- **ヒント 5（アニメーション）**:
  `uProgress` を 0.0 から 1.0 にアニメーションさせると消滅、1.0 から 0.0 にすると出現エフェクトになります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ノイズテクスチャを生成
const size = 128;
const data = new Uint8Array(size * size * 4);
for (let i = 0; i < size * size * 4; i += 4) {
  const val = Math.floor(Math.random() * 255);
  data[i] = val;
  data[i + 1] = val;
  data[i + 2] = val;
  data[i + 3] = 255;
}
const noiseTexture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
noiseTexture.needsUpdate = true;

const vShader = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

const fShader = `
    uniform sampler2D uNoiseMap;
    uniform float uProgress;
    varying vec2 vUv;
    
    void main() {
        float noise = texture2D(uNoiseMap, vUv).r;
        
        // --- ここでdiscard処理 ---
        
        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  uniforms: {
    uNoiseMap: { value: noiseTexture },
    uProgress: { value: 0.0 },
  },
  side: THREE.DoubleSide,
});

const mesh = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), material);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // 進行度をループ
  material.uniforms.uProgress.value =
    (Math.sin(Date.now() * 0.001) + 1.0) * 0.5;

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ノイズテクスチャを生成（画像読み込みエラー回避のため生成）
const size = 128;
const data = new Uint8Array(size * size * 4);
for (let i = 0; i < size * size * 4; i += 4) {
  const val = Math.floor(Math.random() * 255);
  data[i] = val; // R
  data[i + 1] = val; // G
  data[i + 2] = val; // B
  data[i + 3] = 255; // A
}
const noiseTexture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
noiseTexture.needsUpdate = true;

const vShader = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

const fShader = `
    uniform sampler2D uNoiseMap;
    uniform float uProgress;
    varying vec2 vUv;
    
    void main() {
        float noise = texture2D(uNoiseMap, vUv).r;
        
        // ノイズ値が進行度より小さければ描画しない
        if (noise < uProgress) {
            discard;
        }
        
        // 境界線（燃えているエッジ）
        // 進行度より少しだけ大きい部分をオレンジにする
        if (noise < uProgress + 0.05) {
            gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0); // オレンジ
        } else {
            gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0); // 青（ベース色）
        }
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  uniforms: {
    uNoiseMap: { value: noiseTexture },
    uProgress: { value: 0.0 },
  },
  side: THREE.DoubleSide,
});

const mesh = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), material);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // 0〜1の間を行ったり来たり
  material.uniforms.uProgress.value =
    (Math.sin(Date.now() * 0.001) + 1.0) * 0.5;

  renderer.render(scene, camera);
}
animate();
```
