## 1. 問題タイトル

61 本目：炎のエフェクト（パーティクル）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 加算合成（Additive Blending）による発光表現
- パーティクルのライフタイム管理
- 上昇しながら消えていく動きの実装

## 3. 新しい概念の解説

**Particle System（パーティクルシステム）**
炎、煙、爆発、雨、魔法のエフェクトなど、不定形な現象を表現するために「多数の小さな画像（パーティクル）」を用いる手法です。
個々のパーティクルに寿命（Life）や速度（Velocity）を持たせ、アニメーションループ内で更新・リサイクルすることで、ダイナミックな動きを作ります。

```javascript
/*
  パーティクルの更新ロジックの例
  1. 位置を速度分だけ移動
  2. 寿命を減らす
  3. 寿命が尽きたらリセット
*/
function updateParticles() {
  particles.forEach(p => {
    // 上昇
    p.position.add(p.userData.velocity);
    
    // 寿命を減らして透明にする
    p.userData.life -= 0.02;
    p.material.opacity = p.userData.life;
    
    // リセット処理
    if (p.userData.life <= 0) {
      p.position.set(0, 0, 0);
      p.userData.life = 1.0;
    }
  });
}
```

## 4. 課題の説明

燃え上がる炎をパーティクルシステムで表現してください。
複数のパーティクルを発生させ、上に移動させながら透明度を下げ、サイズを変化させることで、リアルな炎のような動きを作ります。

## 5. 必須要件

以下の機能を実装してください。

- **パーティクルの生成**:
  `SpriteMaterial`（加算合成 `blending: THREE.AdditiveBlending`）を作成し、100個程度の `Sprite` を生成してシーンに追加します。
  配列 `particles` に格納し、各スプライトの `userData` に以下を持たせます。
  - `velocity`: 上昇するランダムなベクトル
  - `life`: 1.0〜0.0 の寿命（初期値はランダム）

- **アニメーションループ処理**:
  `particles` 配列をループし、以下の更新を行います。
  1. 位置を速度分だけ移動（上昇）。
  2. 寿命 `life` を減らす。
  3. `life` に応じて透明度（`opacity`）やスケールを変化させる。
  4. 寿命が尽きたら（`life <= 0`）、位置を原点付近に戻し、寿命をリセットしてリサイクルする。

## 6. ヒント

- **ヒント 1（テクスチャロード）**:
  `new THREE.TextureLoader().load('URL')` で画像を読み込みます。
  パーティクル用の画像（中心が明るく周囲が暗いもの）を使うと綺麗に見えます。
- **ヒント 2（マテリアル設定）**:
  `blending: THREE.AdditiveBlending` にすると、重なった部分が発光して見えます。
  `transparent: true` と `depthWrite: false` も設定すると、透過バグを防げます。
- **ヒント 3（データ管理）**:
  各パーティクル（Sprite）の `userData` プロパティに `velocity`（速度ベクトル）や `life`（寿命）を保存しておくと便利です。
- **ヒント 4（リセット処理）**:
  `life` が 0 以下になったら、`position` を原点（0,0,0）に戻し、`life` を 1.0 にリセットすることで、限られた数のパーティクルを循環利用できます。
- **ヒント 5（演出の工夫）**:
  寿命が減るにつれて `scale` を小さくしたり、`opacity` を下げたり、上にいくほど赤くしたりすると、より炎らしくなります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const texture = new THREE.TextureLoader().load(
  "https://threejs.org/examples/textures/sprites/spark1.png"
);

// --- ここでパーティクルシステムを作成 ---
// 配列などで管理するのが簡単

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // --- ここでパーティクルを更新 ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const texture = new THREE.TextureLoader().load(
  "https://threejs.org/examples/textures/sprites/spark1.png"
);

const material = new THREE.SpriteMaterial({
  map: texture,
  color: 0xffaa00,
  blending: THREE.AdditiveBlending,
  transparent: true,
});

const particles = [];
const count = 100;

for (let i = 0; i < count; i++) {
  const sprite = new THREE.Sprite(material);
  // 初期化
  resetParticle(sprite);
  // ランダムなタイミングで開始させるため寿命をばらつかせる
  sprite.userData.life = Math.random();

  scene.add(sprite);
  particles.push(sprite);
}

function resetParticle(p) {
  p.position.set(
    (Math.random() - 0.5) * 0.5, // 中心付近から
    0,
    (Math.random() - 0.5) * 0.5
  );
  p.userData.life = 1.0;
  p.userData.velocity = new THREE.Vector3(
    (Math.random() - 0.5) * 0.02,
    Math.random() * 0.05 + 0.02, // 上昇
    (Math.random() - 0.5) * 0.02
  );
  p.scale.setScalar(1.0); // サイズリセット
}

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  particles.forEach((p) => {
    p.userData.life -= 0.02; // 寿命を減らす

    if (p.userData.life <= 0) {
      resetParticle(p);
    } else {
      p.position.add(p.userData.velocity);
      p.scale.setScalar(p.userData.life * 2); // 消えるにつれて小さく
      p.material.opacity = p.userData.life;
    }
  });

  renderer.render(scene, camera);
}
animate();
```
