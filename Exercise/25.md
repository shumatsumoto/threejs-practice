## 1. 問題タイトル

25 本目：アニメーションカーブ（Tween.js 風）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 線形補間（Lerp）による滑らかな移動
- 目標値に向かって徐々に近づくアニメーション
- 減速する動き（イージング）の実装

## 3. 新しい概念の解説

**Linear Interpolation（線形補間：Lerp）**
2つの値の間（A地点とB地点の間）を計算する数学的な手法です。
「現在の値」を「目標の値」に少しずつ近づける処理（`current.lerp(target, 0.1)`）を毎フレーム繰り返すことで、最初は速く、近づくとゆっくりになる自然な減速アニメーション（イージング）を簡単に作れます。

```javascript
// 現在位置から目標位置へ、毎フレーム5%ずつ近づく
// ベクトルの場合
cube.position.lerp(targetPosition, 0.05);

// 数値の場合 (Three.jsのMathUtilsを使用)
// currentVal = THREE.MathUtils.lerp(currentVal, targetVal, 0.05);
```

## 4. 課題の説明

クリックした場所にキューブが「滑らかに」移動するようにしてください。
瞬時にワープするのではなく、少しずつ近づく（減速しながら止まる）動きを実装します。
外部ライブラリ（GSAP や Tween.js）は使わず、Three.js の機能と計算だけで実現してください。

## 5. 必須要件

以下の機能を実装してください。

- **クリック位置の取得**:
  画面全体に見えない床（透明な Plane など）を配置し、Raycaster で床との交差点（`point`）を取得します。
  その座標を「目標地点（`targetPosition`）」として変数に保存します。

- **Lerpアニメーション**:
  `animate` ループの中で、キューブの現在位置を目標地点に近づけます。
  `cube.position.lerp(targetPosition, 0.05)`
  `0.05` は近づく割合（5%）です。

- **動作確認**:
  クリックした場所にキューブが滑らかに減速しながら移動することを確認します。

## 6. ヒント

- **ヒント 1（Lerpとは）**:
  Linear Interpolation（線形補間）の略です。
  「今の場所」と「行きたい場所」の間を、割合（0.0 〜 1.0）で指定して新しい場所を求めます。
- **ヒント 2（イージングの仕組み）**:
  「残りの距離の 10% 進む」を繰り返すと、最初は大きく進み、ゴールに近づくにつれて進む距離が短くなるため、自然に減速して止まる動きになります。
- **ヒント 3（Vector3.lerp）**:
  Three.js の Vector3 クラスには `lerp` メソッドが組み込まれています。
  `cube.position.lerp(target, 0.05)` と書くだけで、`cube.position` の値が書き換わります。
- **ヒント 4（クリック位置の特定）**:
  3D 空間の「虚空」をクリックしても座標は取れません。
  必ず「見えない巨大な床（Plane）」を配置し、それとの交差判定でクリック座標（point）を取得します。
- **ヒント 5（変数のスコープ）**:
  `targetPosition` はイベントの外（グローバルに近いスコープ）で定義し、常に保持し続ける必要があります。
  イベント内で宣言してしまうと、クリックの瞬間に消えてしまいます。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// クリック判定用の透明な床
const plane = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.MeshBasicMaterial({ visible: false }) // 見えない床
);
scene.add(plane);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshBasicMaterial({ color: 0x00ff00 })
);
scene.add(cube);

camera.position.z = 10;

const targetPosition = new THREE.Vector3(); // 目標位置
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("click", (event) => {
  // --- ここでクリック位置を取得し、targetPositionを更新 ---
});

function animate() {
  requestAnimationFrame(animate);

  // --- ここでlerpを使って移動 ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// クリック判定用の透明な床
const plane = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.MeshBasicMaterial({ visible: false })
);
scene.add(plane);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshBasicMaterial({ color: 0x00ff00 })
);
scene.add(cube);

camera.position.z = 10;

const targetPosition = new THREE.Vector3(0, 0, 0);
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("click", (event) => {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(plane);

  if (intersects.length > 0) {
    // クリックした3D座標を目標にする
    targetPosition.copy(intersects[0].point);
    // Z軸は固定したい場合（床の上を滑るなら）
    targetPosition.z = 0;
  }
});

function animate() {
  requestAnimationFrame(animate);

  // 現在位置から目標位置へ、毎フレーム5%ずつ近づく
  // これにより、最初は速く、近づくと遅くなる滑らかな動きになる
  cube.position.lerp(targetPosition, 0.05);

  renderer.render(scene, camera);
}
animate();
```
