## 1. 問題タイトル

67 本目：モーションブラー（残像）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `AfterimagePass` の使用方法
- 前のフレームの残像を残す表現
- スピード感の演出

## 3. 新しい概念の解説

**Motion Blur / Afterimage（モーションブラー・残像）**
物体が素早く動いたときに生じる「ブレ」のことです。
Three.js の `AfterimagePass` は、前のフレームのレンダリング結果を保持し、現在のフレームと合成（減衰させながら重ね合わせ）することで、擬似的な残像効果を作り出します。
スピード感や滑らかな動きを表現するのに適しています。

```javascript
import { AfterimagePass } from 'three/examples/jsm/postprocessing/AfterimagePass';

const afterimagePass = new AfterimagePass();

// 残像の減衰率 (0.0〜1.0)。値が高いほど残像が長く残る。
afterimagePass.uniforms['damp'].value = 0.96;

composer.addPass(afterimagePass);
```

## 4. 課題の説明

高速で移動または回転するオブジェクトに「残像（モーションブラー）」を追加してください。
`AfterimagePass` を使うと、前のフレームの映像を少しだけ残しながら描画することで、簡単に残像効果を作れます。

## 5. 必須要件

以下の機能を実装してください。

- **対象オブジェクト**:
  高速で移動または回転する物体（例：`cube.rotation.x += 0.5` など、かなり速く）を用意します。

- **AfterimagePass 設定**:
  `three/examples/jsm/postprocessing/AfterimagePass` をインポートしてComposerに追加します。
  `afterimagePass.uniforms['damp'].value` を `0.96` 程度に設定します。

- **効果確認**:
  物体が動いた軌跡に「残像」が表示されることを確認します。
  `damp` 値を下げると残像が短く、上げると長く残ることをテストします。

## 6. ヒント

- **ヒント 1（必要なクラスのインポート）**:
  `AfterimagePass` を使用します。
  `three/examples/jsm/postprocessing/AfterimagePass`
- **ヒント 2（パスの追加）**:
  コンストラクタには特に必須の引数はありません。
  `const pass = new AfterimagePass();`
  `composer.addPass(pass);` で追加できます。
- **ヒント 3（減衰率の調整）**:
  `pass.uniforms['damp'].value` で残像の強さを設定します。
  `0.96` くらいが綺麗に残ります。`1.0` にすると永久に残って画面が真っ白になるので注意してください。
- **ヒント 4（効果的な動き）**:
  ゆっくり動く物体より、高速で回転・移動する物体の方が効果がわかりやすいです。
  `rotation` や `position` を大きく変化させてみましょう。
- **ヒント 5（カメラの影響）**:
  このエフェクトは画面全体に適用されるため、カメラ自体を動かすと背景も含めた全画面がブレます。
  「酔い」を誘発しやすいので、カメラ移動時の使用には注意が必要です。

## 7. スターターコード

```javascript
import * as THREE from "three";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass";
// import { AfterimagePass } ...

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
);
scene.add(cube);

// --- ComposerとAfterimagePass ---

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // 高速回転
  cube.rotation.x += 0.1;
  cube.rotation.y += 0.1;

  // composer.render();
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass";
import { AfterimagePass } from "three/examples/jsm/postprocessing/AfterimagePass";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true })
);
scene.add(cube);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

// 残像パス
const afterimagePass = new AfterimagePass();
afterimagePass.uniforms["damp"].value = 0.96; // 残像の残り具合
composer.addPass(afterimagePass);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // 激しく動かす
  cube.rotation.x += 0.05;
  cube.rotation.y += 0.05;
  cube.position.x = Math.sin(Date.now() * 0.005) * 3;

  composer.render();
}
animate();
```
