## 1. 問題タイトル

29 本目：平行投影カメラ（OrthographicCamera）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `PerspectiveCamera`（透視投影）と `OrthographicCamera`（平行投影）の違い
- 平行投影カメラのパラメータ設定（left, right, top, bottom）
- 2D 的な表現やアイソメトリック（等角投影）ビューの作成

## 3. 新しい概念の解説

**OrthographicCamera（平行投影カメラ）**
「遠くのものが小さくならない」カメラです。
設計図、2D ゲーム、アイソメトリック（斜投影）ビューなどに使われます。
画角（FOV）の代わりに、上下左右の「撮影範囲」を指定します。

```javascript
// Left, Right, Top, Bottom, Near, Far
const camera = new THREE.OrthographicCamera(-5, 5, 5, -5, 1, 100);
```

**Perspective vs Orthographic**
- Perspective: 人間の目に近いリアリティ（遠近感あり）
- Orthographic: 正確な寸法や配置を見るためのテクニカルな視点（遠近感なし）

## 4. 課題の説明

これまでは遠くのものが小さく見える「透視投影（Perspective）」を使ってきましたが、図面や 2D ゲームのように遠近感のない「平行投影（Orthographic）」を使ってみましょう。
同じ大きさのキューブを奥に向かって並べ、それらが全て同じ大きさに見えることを確認してください。

## 5. 必須要件

以下の機能を実装してください。

- **OrthographicCameraの作成**:
  `PerspectiveCamera` の代わりに `THREE.OrthographicCamera` を使用します。
  引数は `left, right, top, bottom, near, far` です。
  画面アスペクト比を維持するため、幅の計算式 `d * aspect` を使用してください。

- **オブジェクトの配置**:
  大きさの比較ができるよう、同じサイズのキューブを奥（Z軸マイナス方向）に向かって等間隔に配置します。

- **視点の設定**:
  カメラを少し斜め上の位置（例: (5, 5, 5)）に置き、`lookAt(0, 0, 0)` させます。

- **描画確認**:
  透視投影とは異なり、一番奥にあるキューブと手前にあるキューブが、画面上で全く同じ大きさで描画される（遠近感がない）ことを確認します。

## 6. ヒント

- **ヒント 1（アスペクト比の維持）**:
  透視投影（Perspective）と違い、平行投影（Orthographic）では「映す範囲の縦横比」をウィンドウに手動で合わせる必要があります。
  `left = -d * aspect`, `right = d * aspect` のように幅を補正します。
- **ヒント 2（ズーム倍率）**:
  パラメータの数値（例：-5 〜 5）がそのまま「ワールド座標の何メートル分を映すか」になります。
  この値を小さくするとズームイン（拡大）、大きくするとズームアウト（縮小）になります。
- **ヒント 3（遠近感の欠如）**:
  平行投影では、どんなに遠くにあっても大きさは変わりません。
  そのため、Z 座標の違いは「前後関係（重なり順）」にのみ影響します。
- **ヒント 4（アイソメトリック）**:
  カメラを `(1, 1, 1)` などの等しい位置に置き、原点を見ると、いわゆる「クォータービュー（斜め見下ろし）」になります。シミュレーションゲームでよく見る視点です。
- **ヒント 5（クリッピング）**:
  `near` と `far` の設定も Perspective と同様に必要です。オブジェクトが消える場合は、これらの範囲内に入っているか確認してください。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();

// --- ここでOrthographicCameraを作成してください ---
// const aspect = window.innerWidth / window.innerHeight;
// const d = 5;
// const camera = ...

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// キューブを並べる
const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshBasicMaterial({
  color: 0x00ff00,
  wireframe: true,
});

for (let i = 0; i < 5; i++) {
  const cube = new THREE.Mesh(geometry, material);
  cube.position.z = -i * 2; // 奥へ
  cube.position.x = i * 0.5; // 少しずらす
  scene.add(cube);
}

// グリッド
const gridHelper = new THREE.GridHelper(20, 20);
scene.add(gridHelper);

// カメラ位置設定
camera.position.set(5, 5, 5);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();

// 1. 平行投影カメラの作成
const aspect = window.innerWidth / window.innerHeight;
const d = 5; // 表示範囲の広さ（ズーム倍率のようなもの）

// left, right, top, bottom, near, far
const camera = new THREE.OrthographicCamera(
  -d * aspect, // left
  d * aspect, // right
  d, // top
  -d, // bottom
  1, // near
  1000 // far
);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 2. キューブを並べる
const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshBasicMaterial({
  color: 0x00ff00,
  wireframe: true,
});

for (let i = 0; i < 5; i++) {
  const cube = new THREE.Mesh(geometry, material);
  cube.position.z = -i * 2; // 奥へ配置
  cube.position.x = i * 0.5;
  scene.add(cube);
}

// グリッド
const gridHelper = new THREE.GridHelper(20, 20);
scene.add(gridHelper);

// 3. カメラ位置設定（アイソメトリック視点）
camera.position.set(5, 5, 5);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```
