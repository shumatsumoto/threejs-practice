## 1. 問題タイトル

53 本目：フラグメントシェーダーでグラデーション

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `varying` 変数の使用（頂点からフラグメントへのデータ受け渡し）
- UV 座標（`uv`）を利用した色計算
- GLSL での `mix` 関数の使用

## 3. 新しい概念の解説

**Varying variables（ヴァリューイング変数）**
Vertex Shader から Fragment Shader へデータを渡すための変数です。
Vertex Shader で頂点ごとの値をセットすると、Fragment Shader に届くまでにピクセル間で自動的に「補間（ブレンド）」されます。
これを利用して、滑らかなグラデーションを作ることができます。

```javascript
// 頂点シェーダー
const vShader = `
  varying vec2 vUv; // フラグメントシェーダーへ送る箱
  void main() {
    vUv = uv; // UV座標を代入
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

// フラグメントシェーダー
const fShader = `
  varying vec2 vUv; // 受け取る箱
  void main() {
    // UV座標をそのまま色として出力 (X=Red, Y=Green)
    gl_FragColor = vec4(vUv.x, vUv.y, 0.0, 1.0);
  }
`;
```

## 4. 課題の説明

平面に、上から下へ（または左から右へ）色が変化するグラデーションを描画してください。
頂点シェーダーから UV 座標をフラグメントシェーダーに渡し、その Y 座標の値（0.0〜1.0）を使って 2 つの色をブレンドします。

## 5. 必須要件

以下の機能を実装してください。

- **Varying の使用**:
  頂点シェーダーで `varying vec2 vUv;` を定義し、`vUv = uv;` を代入します。
  フラグメントシェーダーでも同じ名前で受け取ります。

- **色のブレンド**:
  フラグメントシェーダーで 2 つの色（例：赤と青）を定義し、`mix(colorA, colorB, vUv.y)` でブレンドします。
  `gl_FragColor` に出力して平滑なグラデーションになることを確認します。

## 6. ヒント

- **ヒント 1（Varyingの仕組み）**:
  `varying` 変数はバケツリレーのようなものです。
  Vertex Shader で値を入れ（`vUv = uv`）、Fragment Shader で受け取ります。
  この間、三角形の内部では値が自動的に補間（ブレンド）されるため、滑らかな階調が生まれます。
- **ヒント 2（UV座標）**:
  `(0, 0)` が左下、`(1, 1)` が右上を表すテクスチャ座標です。
  今回はテクスチャ画像を使いませんが、便利な「0〜1の座標データ」としてグラデーション作成に利用します。
- **ヒント 3（mix関数）**:
  `mix(color1, color2, ratio)`
  ratio が 0.0 なら color1、1.0 なら color2、0.5 なら中間の色になります。
- **ヒント 4（方向）**:
  縦グラデーションなら `vUv.y` を ratio に使い、横グラデーションなら `vUv.x` を使います。
- **ヒント 5（vec3）**:
  色は `vec3(R, G, B)` で扱います。
  `vec3 red = vec3(1.0, 0.0, 0.0);` のように定義して mix に渡しましょう。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

const fShader = `
    varying vec2 vUv;
    void main() {
        // --- ここでグラデーションを作成 ---
        // vec3 color = mix(..., ..., vUv.y);
        
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
});

const plane = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), material);
scene.add(plane);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

const fShader = `
    varying vec2 vUv;
    void main() {
        vec3 colorA = vec3(1.0, 0.0, 0.0); // 赤
        vec3 colorB = vec3(0.0, 0.0, 1.0); // 青
        
        // Y座標（縦方向）に基づいて色を混ぜる
        vec3 color = mix(colorB, colorA, vUv.y);
        
        gl_FragColor = vec4(color, 1.0);
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  side: THREE.DoubleSide,
});

const plane = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), material);
scene.add(plane);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```
