## 1. 問題タイトル

45 本目：LOD（Level of Detail）の実装

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `THREE.LOD` の使用方法
- カメラとの距離に応じたモデルの切り替え
- パフォーマンス最適化の基礎

## 3. 新しい概念の解説

**LOD (Level of Detail)**
「遠くのものはよく見えないので、粗く描画して処理を軽くする」という技術です。
カメラとの距離に応じて、高精細なモデルと低ポリゴンのモデルを自動的に切り替えます。
広大なオープンワールドゲームなどで必須の最適化テクニックです。

```javascript
const lod = new THREE.LOD();

// 距離0〜: 高精細
lod.addLevel(highDetailMesh, 0);

// 距離10〜: 中程度
lod.addLevel(mediumDetailMesh, 10);

// 距離20〜: 低精細（ローポリ）
lod.addLevel(lowDetailMesh, 20);

scene.add(lod);
```

## 4. 課題の説明

カメラからの距離に応じて、表示するモデルの詳細度（ポリゴン数）を切り替える LOD（Level of Detail）を実装してください。
近くでは高精細な球体、少し離れると粗い球体、遠くでは非常に粗い球体（または立方体）を表示するようにします。

## 5. 必須要件

以下の機能を実装してください。

- **LODオブジェクトの作成**:
  `new THREE.LOD()` でLODコンテナを作成します。

- **詳細度の異なるメッシュ**:
  ポリゴン数の異なる3つのメッシュを用意します。
  例：`IcosahedronGeometry` の `detail` 引数を 2（高）、1（中）、0（低）としたもの。
  分かりやすさのため、ワイヤーフレーム表示にすることを推奨します。

- **レベルの設定**:
  `lod.addLevel(mesh, distance)` を使用して、距離に応じたメッシュを登録します。
  例：距離 0 で高詳細、距離 10 で中詳細、距離 20 で低詳細。

- **動作確認**:
  LODオブジェクトをシーンに追加し、カメラを前後に移動させて、特定の距離でメッシュが切り替わることを確認します。

## 6. ヒント

- **ヒント 1（レベルの設定）**:
  `lod.addLevel(mesh, distance)`
  distance より遠くに離れたら、その mesh に表示が切り替わるという意味です。
  通常は `distance: 0` に最高画質のものを設定します。
- **ヒント 2（メッシュの共有）**:
  各レベルのメッシュは独立しています。同じマテリアルを使い回すことは可能ですが、ジオメトリは詳細度が違うものを用意します。
- **ヒント 3（ワイヤーフレーム）**:
  変化が分かりにくい場合は `material: new THREE.MeshBasicMaterial({ wireframe: true })` にすると、ポリゴン数の増減が一目で分かります。
- **ヒント 4（自動判定）**:
  LOD オブジェクトは毎フレーム、レンダリング時にカメラとの距離を自動計算して表示を切り替えています。特別な更新コードは不要です。
- **ヒント 5（IcosahedronGeometry）**:
  第 2 引数の `detail` を 0, 1, 2 と変えるだけで簡単にポリゴン数の違う球体が作れるので、LOD のテストに最適です。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const lod = new THREE.LOD();

// --- ここで3段階のメッシュを作成し、lodに追加 ---
// lod.addLevel(meshHigh, 0);
// lod.addLevel(meshMed, 10);
// lod.addLevel(meshLow, 20);

scene.add(lod);

camera.position.z = 30;

function animate() {
  requestAnimationFrame(animate);

  // カメラを近づけたり遠ざけたりする
  camera.position.z = 15 + Math.sin(Date.now() * 0.001) * 10;

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const material = new THREE.MeshNormalMaterial({ wireframe: true });
const lod = new THREE.LOD();

// レベル1: 高精細（距離0以上）
const geoHigh = new THREE.IcosahedronGeometry(2, 3);
const meshHigh = new THREE.Mesh(geoHigh, material);
lod.addLevel(meshHigh, 0);

// レベル2: 中程度（距離10以上）
const geoMed = new THREE.IcosahedronGeometry(2, 1);
const meshMed = new THREE.Mesh(geoMed, material);
lod.addLevel(meshMed, 10);

// レベル3: 低精細（距離20以上）
const geoLow = new THREE.IcosahedronGeometry(2, 0);
const meshLow = new THREE.Mesh(geoLow, material);
lod.addLevel(meshLow, 20);

scene.add(lod);

camera.position.z = 30;

function animate() {
  requestAnimationFrame(animate);

  // カメラを自動で前後に移動
  // 距離が変化すると、ポリゴンの細かさが変わるのがわかる
  camera.position.z = 15 + Math.sin(Date.now() * 0.001) * 12;

  renderer.render(scene, camera);
}
animate();
```
