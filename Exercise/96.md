## 1. 問題タイトル

96 本目：HTML 要素との連携（CSS2DRenderer）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `CSS2DRenderer` のセットアップ
- 3D オブジェクトに追従する HTML ラベルの作成
- `CSS2DObject` の使用方法

## 3. 新しい概念の解説

**CSS2D Renderer (CSS2Dレンダラー)**
Three.js の 3D シーンの上に、通常の HTML 要素（`div` や `span`）を重ねて表示するためのレンダラーです。
3D オブジェクトの動きに合わせて HTML 要素のスクリーン座標（`top`, `left`）を自動的に更新してくれるため、3D 空間に追従するリッチなラベルや UI を簡単に実装できます。
WebGL の描画内容と HTML の DOM 要素は別々のレイヤーとして扱われます。

```javascript
import { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer';

// 1. ラベル（Div要素）を作成
const div = document.createElement('div');
div.textContent = 'Earth';
div.className = 'label'; // CSSクラスでスタイル調整
div.style.color = 'white';

// 2. CSS2Dオブジェクトに変換
const label = new CSS2DObject(div);
label.position.set(0, 1.2, 0); // 親オブジェクトからの相対位置

// 3. 親オブジェクト（例：球体）に追加
sphere.add(label);
```

## 4. 課題の説明

3D シーン内のオブジェクトに、HTML で作成した「ラベル（名前や説明）」を追従させてください。
`CSS2DRenderer` を使うと、通常の HTML 要素（`div`など）を 3D 座標に合わせて画面上に配置できます。
これにより、文字がぼやけず、CSS で自由にデザインできる UI を作成できます。

## 5. 必須要件

以下の機能を実装してください。

- **レンダラーの準備**:
  1. `renderer` (WebGL) に加えて、`new CSS2DRenderer()` を作成します。
  2. `labelRenderer` のサイズを画面サイズに合わせます。
  3. `labelRenderer.domElement` の CSS を調整し（`position: absolute; top: 0`）、Web ページ上で重なるように `document.body.appendChild` します。

- **ラベルの作成**:
  1. 通常の HTML 要素を作成します（例：`const div = document.createElement('div')`）。
  2. 文字列（"Earth"など）やスタイル（色、枠線）を設定します。
  3. `new CSS2DObject(div)` コンストラクタにその要素を渡し、CSS オブジェクト化します。
  4. 親となる 3D オブジェクト（Mesh）に `mesh.add(label)` で追加し、`label.position.set(0, 1.2, 0)` などで頭上に配置します。

- **レンダリングとコントロール**:
  1. `OrbitControls` を使用する場合、`labelRenderer.domElement`（手前にある要素）をターゲットにするか、CSS を `pointer-events: none` にしないと操作できなくなるので調整します。
  2. アニメーションループ内で `renderer.render(...)` と `labelRenderer.render(...)` の両方を毎フレーム呼び出します。

## 6. ヒント

- **ヒント 1（二つのレンダラー）**:
  `WebGLRenderer`（3D描画）と `CSS2DRenderer`（HTML配置）の両方を用意し、それぞれ render ループ内で `render` メソッドを呼ぶ必要があります。
- **ヒント 2（HTML側の設定）**:
  `labelRenderer.domElement` は `position: absolute; top: 0; pointer-events: none;` に設定して、Canvas の上にぴったり重ね、かつマウス操作を妨げないようにします。
- **ヒント 3（親子関係）**:
  `CSS2DObject` を `scene` に直接置くのではなく、追従させたい 3D オブジェクト（`mesh`）の子要素（`add`）にすると、親の動きに合わせて自動的に位置が更新されます。
- **ヒント 4（表示順序）**:
  HTML は常に WebGL キャンバスの手前（または奥）の別レイヤーとして描画されます。
  「3D オブジェクトの後ろに隠れる」表現は、デフォルトではできません（不透明度判定などの工夫が必要です）。
- **ヒント 5（操作の競合）**:
  OrbitControls を使う場合、`controls = new OrbitControls(camera, labelRenderer.domElement)` のように、一番手前にある要素（CSS レンダラー）にイベントを割り当てないと、マウス操作が効かないことがあります。

## 7. スターターコード

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
// import { CSS2DRenderer, CSS2DObject } ...

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- ここでCSS2DRendererを作成 ---
// const labelRenderer = ...

const controls = new OrbitControls(camera, renderer.domElement);
// controlsはlabelRendererのdomElementに設定する必要がある場合もあります

const geometry = new THREE.SphereGeometry(1, 32, 32);
const material = new THREE.MeshNormalMaterial();
const sphere = new THREE.Mesh(geometry, material);
scene.add(sphere);

// --- ここでラベル作成 ---
// const div = document.createElement('div');
// div.textContent = 'Earth';
// const label = new CSS2DObject(div);
// sphere.add(label);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
  // labelRenderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import {
  CSS2DRenderer,
  CSS2DObject,
} from "three/examples/jsm/renderers/CSS2DRenderer";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

// WebGLレンダラー
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// CSS2Dレンダラー
const labelRenderer = new CSS2DRenderer();
labelRenderer.setSize(window.innerWidth, window.innerHeight);
labelRenderer.domElement.style.position = "absolute";
labelRenderer.domElement.style.top = "0px";
// マウスイベントを通過させる（必要に応じて）
// labelRenderer.domElement.style.pointerEvents = 'none';
document.body.appendChild(labelRenderer.domElement);

// コントロール（CSSレンダラーの上に重ねる場合、こちらにイベントを貼るか工夫が必要）
// 今回はOrbitControlsをlabelRendererの要素に適用すると操作しやすい
const controls = new OrbitControls(camera, labelRenderer.domElement);

const geometry = new THREE.SphereGeometry(1, 32, 32);
const material = new THREE.MeshNormalMaterial();
const sphere = new THREE.Mesh(geometry, material);
scene.add(sphere);

// ラベル作成
const div = document.createElement("div");
div.className = "label";
div.textContent = "Sphere Object";
div.style.color = "white";
div.style.backgroundColor = "rgba(0, 0, 0, 0.6)";
div.style.padding = "5px";
div.style.borderRadius = "5px";
div.style.marginTop = "-1em"; // 位置調整

const label = new CSS2DObject(div);
label.position.set(0, 1.2, 0); // 球体の少し上
sphere.add(label);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  controls.update();

  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
}
animate();
```
