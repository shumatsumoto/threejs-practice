## 1. 問題タイトル

41 本目：カスタムジオメトリの作成

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `BufferGeometry` の基本構造
- 頂点座標（Position）の定義
- 三角形の面（Face）の構成ルール

## 3. 新しい概念の解説

**Custom Geometry（カスタムジオメトリ）**
`BoxGeometry` などの既製品を使わず、頂点の位置を 1 つずつ指定して自由な形状を作る方法です。
3D グラフィックスのあらゆる形状は、最終的に「三角形」の集合体（ポリゴン）として表現されます。
最小単位である三角形をコード定義することで、3D の仕組みを深く理解できます。

```javascript
/*
  三角形(ポリゴン)の作り方
  1. BufferGeometryを作成
  2. 頂点座標配列(Float32Array)を作成
  3. geometry.setAttributeで登録
*/
const geometry = new THREE.BufferGeometry();
const vertices = new Float32Array([
  -1.0, -1.0,  0.0, // 頂点1
   1.0, -1.0,  0.0, // 頂点2
   0.0,  1.0,  0.0  // 頂点3
]);
// 3つの数字で1つの頂点(x,y,z)とする設定
geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
```

## 4. 課題の説明

既存の `BoxGeometry` や `SphereGeometry` を使わず、自分で頂点座標を指定して「三角形」を 1 つ作成してください。
3D グラフィックスの最小単位である三角形を理解することは、複雑な形状を作るための第一歩です。

## 5. 必須要件

以下の機能を実装してください。

- **BufferGeometryの作成**:
  `new THREE.BufferGeometry()` で空のジオメトリインスタンスを作成します。

- **頂点データの定義**:
  3つの頂点（三角形1つ分）の座標（x, y, z）を持つ `Float32Array` を作成します。
  例: `[ -1, -1, 0, 1, -1, 0, 0, 1, 0 ]`

- **属性の登録**:
  `geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3))` を使用して、頂点データをジオメトリに登録します。

- **メッシュ化と表示**:
  `MeshBasicMaterial`（`side: THREE.DoubleSide` 推奨）を使ってメッシュを作成し、シーンに追加して三角形が表示されることを確認します。

## 6. ヒント

- **ヒント 1（BufferGeometry）**:
  全てのジオメトリの基本クラスです。`BoxGeometry` なども内部ではこれを使っています。
  `new THREE.BufferGeometry()` で空のハコを作ります。
- **ヒント 2（Float32Array）**:
  頂点データは通常の JavaScript 配列（`[]`）ではなく、高速な型付き配列 `Float32Array` を使う必要があります。
- **ヒント 3（データの構造）**:
  3 つの数値で 1 つの頂点（X, Y, Z）を表します。
  三角形を作るには 3 つの頂点が必要なので、合計 9 個の数値が配列に入ります。
- **ヒント 4（属性の設定）**:
  `geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3))`
  第 2 引数の `3` は「配列から 3 個ずつ数値を取り出して 1 頂点とする」という意味です。
- **ヒント 5（頂点の順序）**:
  基本的に「反時計回り」の順序で登録された面が「オモテ」として扱われます。
  `side: THREE.DoubleSide` を使えば裏表関係なく表示されます。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- ここでカスタムジオメトリを作成 ---
// const geometry = new THREE.BufferGeometry();
// const vertices = new Float32Array([ ... ]);
// geometry.setAttribute( ... );

const material = new THREE.MeshBasicMaterial({
  color: 0xff0000,
  side: THREE.DoubleSide,
});
// const triangle = new THREE.Mesh(geometry, material);
// scene.add(triangle);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 1. ジオメトリの作成
const geometry = new THREE.BufferGeometry();

// 2. 頂点データの作成（三角形1つ分 = 頂点3つ）
const vertices = new Float32Array([
  -1.0,
  -1.0,
  0.0, // 左下
  1.0,
  -1.0,
  0.0, // 右下
  0.0,
  1.0,
  0.0, // 上
]);

// 3. 属性として登録
geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));

// 4. メッシュ化
const material = new THREE.MeshBasicMaterial({
  color: 0xff0000,
  side: THREE.DoubleSide,
});
const triangle = new THREE.Mesh(geometry, material);
scene.add(triangle);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // 回転させて立体感を確認
  triangle.rotation.y += 0.01;

  renderer.render(scene, camera);
}
animate();
```
