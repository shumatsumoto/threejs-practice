## 1. 問題タイトル

26 本目：パーティクルシステムの基礎

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `BufferGeometry` を使った頂点データの管理
- `Points` と `PointsMaterial` の使用
- 大量の点を効率的に描画する方法

## 3. 新しい概念の解説

**Points（点描画）**
三角形（Mesh）ではなく、点（Point）として描画するオブジェクトです。
パーティクル（粒子）のような表現に使われます。
大量の数を描画しても処理が軽いため、雨や雪、星空などの表現に適しています。

**BufferAttribute**
頂点データの配列に効率的にアクセスするための仕組みです。
`Float32Array` という型付き配列を使って座標データ（x, y, z）を管理し、GPU に直接転送することで高速な描画を実現します。

```javascript
// 頂点データ (x, y, z の並び)
const vertices = new Float32Array([
  0, 0, 0,  // 点1
  1, 2, 3,  // 点2
  -1, -1, 0 // 点3
]);

const geometry = new THREE.BufferGeometry();
// 3個ずつ読み取る設定で登録
geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

const material = new THREE.PointsMaterial({ size: 0.1, color: 0xffffff });
const points = new THREE.Points(geometry, material);
scene.add(points);
```

## 4. 課題の説明

空間上に 1000 個の白い点をランダムに配置し、雪や星屑のようなエフェクトを作成してください。
Mesh（立方体など）を 1000 個作ると重くなりますが、Points（点）なら軽量に描画できます。

## 5. 必須要件

以下の機能を実装してください。

- **BufferGeometryの作成**:
  `const geometry = new THREE.BufferGeometry()` を作成します。

- **頂点データの生成**:
  1000個の点（つまり3000個の数値）を持つ `Float32Array` を作成します。
  ループを使って、ランダムな座標（例: -10 〜 +10 の範囲）を代入します。

- **属性の登録**:
  `geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3))` でジオメトリに登録します。

- **Pointsの作成**:
  `PointsMaterial`（サイズ0.1、色白）を作成します。
  `new THREE.Points(geometry, material)` でメッシュではなく「点」としてインスタンス化し、シーンに追加します。

- **描画確認**:
  シーン内に白い点が散らばって表示されることを確認します。

## 6. ヒント

- **ヒント 1（ジオメトリの種類）**:
  いつもの `BoxGeometry` ではなく、空の `BufferGeometry` を作って、自分で頂点データを入れる方式を使います。
- **ヒント 2（データ構造）**:
  頂点データは「x, y, z」の繰り返しです。1000 個の点なら 3000 個の数値が入った配列（Float32Array）が必要です。
- **ヒント 3（属性の設定）**:
  `geometry.setAttribute` を使います。名前は必ず `'position'` にしてください。シェーダーがその名前で座標を探すからです。
  第2引数は `new THREE.BufferAttribute(array, 3)` です。「3個ずつ読んでね」という指定です。
- **ヒント 4（パフォーマンス）**:
  `Points` は非常に軽量です。数万個出してもブラウザはサクサク動きます。
  逆に `Mesh`（立方体など）を数万個出すと重くて動きません。これがパーティクルを使う理由です。
- **ヒント 5（減衰）**:
  `PointsMaterial` の `sizeAttenuation: true`（デフォルト）により、遠くの点は小さく、近くの点は大きく描画され、遠近感が生まれます。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- ここでパーティクルを作成してください ---

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  // 回転させると綺麗です
  // particles.rotation.y += 0.002;
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 1. ジオメトリの作成
const geometry = new THREE.BufferGeometry();
const count = 1000;
const positions = new Float32Array(count * 3); // x, y, z で3倍の長さ

// 2. 座標のランダム生成
for (let i = 0; i < count * 3; i++) {
  positions[i] = (Math.random() - 0.5) * 20; // -10 〜 +10 の範囲
}

// 3. 属性の登録
geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

// 4. マテリアルの作成
const material = new THREE.PointsMaterial({
  size: 0.1,
  color: 0xffffff,
});

// 5. Pointsオブジェクトの作成
const particles = new THREE.Points(geometry, material);
scene.add(particles);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // 全体をゆっくり回転
  particles.rotation.y += 0.002;

  renderer.render(scene, camera);
}
animate();
```
