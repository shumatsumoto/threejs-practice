## 1. 問題タイトル

48 本目：パスに沿った移動

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `CatmullRomCurve3` による滑らかな曲線の作成
- `curve.getPoint(t)` を使った座標取得
- オブジェクトを曲線に沿ってアニメーションさせる方法

## 3. 新しい概念の解説

**Path Following（パス追従）**
あらかじめ決めたルート（曲線）に沿ってオブジェクトを移動させる技術です。
Three.js の `Curve` クラスは、0.0（始点）から 1.0（終点）までのパラメータを受け取り、その位置座標を返す `getPoint(t)` という便利なメソッドを持っています。

```javascript
// コースの作成
const curve = new THREE.CatmullRomCurve3([
  new THREE.Vector3(-10, 0, 0),
  new THREE.Vector3(0, 10, 0),
  new THREE.Vector3(10, 0, 0)
]);

// t (0.0 〜 1.0) の位置を取得
const t = 0.5; // 中間地点
const position = curve.getPoint(t);
mesh.position.copy(position);
```

## 4. 課題の説明

3D 空間に滑らかな曲線（パス）を作成し、その上を球体が移動するアニメーションを作成してください。
0.0〜1.0 のパラメータ `t` を変化させ、パス上の座標を取得してオブジェクトの位置に適用します。

## 5. 必須要件

以下の機能を実装してください。

- **パス（曲線）の作成**:
  `THREE.CatmullRomCurve3` を使用し、複数の `Vector3` を通過点として指定して曲線を作成します。
  第2引数を `true` にして閉じたループにします。

- **パスの可視化**:
  `curve.getPoints(50)` などで点群を取得し、`Line` または `TubeGeometry` を使ってコースを画面に表示します。

- **オブジェクトの移動**:
  アニメーションループ内で進行度 `t`（0.0〜1.0）を増加させます（1.0を超えたらリセット）。
  `curve.getPoint(t)` でその時点の座標を取得し、移動させるオブジェクトの `position` に適用します。

- **向きの制御（任意）**:
  進行方向を向かせるために、少し先の座標 `curve.getPoint(t + 0.01)` を見て `lookAt` させるとより自然になります。

## 6. ヒント

- **ヒント 1（カーブの定義）**:
  `CatmullRomCurve3` は指定した複数の点を滑らかに繋ぐスプライン曲線を作ります。
  第 2 引数を `true` にすると、閉じたループ（コース）になります。
- **ヒント 2（位置の取得）**:
  `curve.getPoint(t)` を使います。
  変数 `t` は 0.0（スタート）から 1.0（ゴール）までの値です。
- **ヒント 3（ループ処理）**:
  `t` を毎フレーム少しずつ増やし、1.0 を超えたら 0.0 に戻すことで周回アニメーションになります。
- **ヒント 4（可視化）**:
  線が見えないと動きが分かりにくいので、`curve.getPoints(50)` で座標を取得し、`Line` オブジェクトを作ってコースを表示すると良いでしょう。
- **ヒント 5（向きの制御）**:
  ただ移動するだけでは常に同じ方向を向いてスライド移動しているように見えます。
  自然にするには「少し先の地点」を取得して `mesh.lookAt()` させると、進行方向を向くようになります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- ここでカーブを作成 ---
// const curve = new THREE.CatmullRomCurve3([ ... ]);

// 移動する物体
const sphere = new THREE.Mesh(
  new THREE.SphereGeometry(0.2),
  new THREE.MeshBasicMaterial({ color: 0xff0000 })
);
scene.add(sphere);

let progress = 0;

camera.position.z = 10;
camera.position.y = 5;
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  // --- ここでprogressを増やし、sphereの位置を更新 ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 1. カーブ（パス）の作成
const curve = new THREE.CatmullRomCurve3(
  [
    new THREE.Vector3(-5, 0, 5),
    new THREE.Vector3(-5, 5, -5),
    new THREE.Vector3(5, 0, -5),
    new THREE.Vector3(5, -5, 5),
  ],
  true
); // true = 閉じたループ

// パスの可視化（線を描画）
const points = curve.getPoints(50);
const geometry = new THREE.BufferGeometry().setFromPoints(points);
const material = new THREE.LineBasicMaterial({ color: 0xffffff });
const curveObject = new THREE.Line(geometry, material);
scene.add(curveObject);

// 2. 移動する物体
const sphere = new THREE.Mesh(
  new THREE.SphereGeometry(0.5),
  new THREE.MeshBasicMaterial({ color: 0xff0000 })
);
scene.add(sphere);

let progress = 0;

camera.position.set(0, 10, 15);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);

  // 0から1の間をループさせる
  progress += 0.002;
  if (progress > 1) progress = 0;

  // 3. パス上の位置を取得して適用
  const position = curve.getPoint(progress);
  sphere.position.copy(position);

  renderer.render(scene, camera);
}
animate();
```
