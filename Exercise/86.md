## 1. 問題タイトル

86 本目：パズルゲーム（Raycaster による選択）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `Raycaster` を使ったオブジェクトのクリック判定
- オブジェクトの状態管理（ON/OFF）
- 3D 空間でのインタラクション

## 3. 新しい概念の解説

**Grid Logic & Raycaster (グリッドロジックとレイキャスター)**
グリッド状に並んだオブジェクトを管理する場合、2次元配列（または 1 次元配列からのインデックス計算）を使うと、「右隣」や「上隣」といった位置関係の計算が容易になります。
`Raycaster` で取得したオブジェクトから `userData` に保存しておいたインデックスを取り出すことで、3D 上のクリックと論理的なデータ操作を結びつけます。

```javascript
/*
  クリックされたタイルのインデックスから、
  隣接するタイル（上下左右）のインデックスを計算
*/
const index = intersects[0].object.userData.index;
const x = index % gridSize;
const y = Math.floor(index / gridSize);

// 自分を反転
toggleMesh(index);

// 隣接チェック（範囲外アクセス防止）
if (x > 0) toggleMesh(index - 1);           // 左
if (x < gridSize - 1) toggleMesh(index + 1); // 右
if (y > 0) toggleMesh(index - gridSize);     // 下
if (y < gridSize - 1) toggleMesh(index + gridSize); // 上
```

## 4. 課題の説明

3x3 のグリッド状に並んだタイル（キューブ）をクリックして、全ての色を揃えるパズル（ライツアウト風）を作成してください。
クリックしたタイルとその上下左右のタイルの色が反転（赤 ⇔ 青）するようにします。

## 5. 必須要件

以下の機能を実装してください。

- **グリッドの作成**:
  3x3 のキューブを作成し、1 次元配列 `cubes` に格納します。
  各キューブの `userData` に `{ index: i, active: false }` を設定し、`active` の状態によって色を変えます（初期は赤など）。

- **Raycaster判定**:
  `click` イベントでクリックされたキューブを特定し、そのインデックスを取得します。

- **パズルロジックの実装**:
  関数 `toggle(index)` を作成し、指定されたインデックスのキューブの色と状態を反転させます（範囲チェック必須）。
  クリックされたインデックス `i` から、上下左右のインデックスを計算します。
  - 左: `i - 1` (ただし `i % 3 !== 0` の時のみ)
  - 右: `i + 1` (ただし `i % 3 !== 2` の時のみ)
  - 上: `i - 3`
  - 下: `i + 3`
  これらを全て `toggle` します。

- **クリア判定**:
  全てのキューブが青（active）になったら「Clear!」とログ出力します。

## 6. ヒント

- **ヒント 1（座標変換）**:
  クリックされたタイルの index から `x = index % 3`, `y = Math.floor(index / 3)` でグリッド座標を求めます。
  逆にグリッド座標からインデックスに戻すには `index = y * 3 + x` です。
- **ヒント 2（安全な切り替え）**:
  `toggle(x, y)` 関数を作り、その中で `if (x >= 0 && x < 3)` のように範囲チェックを行うと、端のタイルをクリックした時のエラーを防げます。
- **ヒント 3（Raycasterの対象）**:
  `intersectObjects(cubes)` のように、対象の配列だけを渡すと、背景などをクリックした時の無駄な判定を省けます。
- **ヒント 4（ゲーム終了判定）**:
  切り替え処理の最後に、`cubes.every(c => c.userData.active)`（または全て false）などをチェックしてクリア判定を行います。
- **ヒント 5（データの保持）**:
  `mesh.userData` は自由なオブジェクトを入れられるので、ここに `active: boolean` や `gridX, gridY` を持たせておくと管理が楽です。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// 3x3のキューブを作成
const cubes = [];
// ...

window.addEventListener("click", (event) => {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  // const intersects = raycaster.intersectObjects(scene.children);
  // ...
});

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

const gridSize = 3;
const cubes = []; // 1次元配列で管理して、インデックス計算で隣接を求める

// 初期化
for (let i = 0; i < gridSize * gridSize; i++) {
  const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.1);
  const material = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // 赤
  const mesh = new THREE.Mesh(geometry, material);

  const x = (i % gridSize) - 1;
  const y = Math.floor(i / gridSize) - 1;

  mesh.position.set(x, y, 0);
  mesh.userData = { index: i, active: false }; // 状態を持たせる

  scene.add(mesh);
  cubes.push(mesh);
}

function toggle(index) {
  if (index < 0 || index >= cubes.length) return;

  const mesh = cubes[index];
  mesh.userData.active = !mesh.userData.active;
  mesh.material.color.set(mesh.userData.active ? 0x0000ff : 0xff0000);
}

window.addEventListener("click", (event) => {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(cubes);

  if (intersects.length > 0) {
    const index = intersects[0].object.userData.index;
    const x = index % gridSize;
    const y = Math.floor(index / gridSize);

    toggle(index); // 自分
    if (x > 0) toggle(index - 1); // 左
    if (x < gridSize - 1) toggle(index + 1); // 右
    if (y > 0) toggle(index - gridSize); // 下
    if (y < gridSize - 1) toggle(index + gridSize); // 上
  }
});

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```
