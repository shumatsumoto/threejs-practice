## 1. 問題タイトル

52 本目：頂点シェーダーで波打つ平面

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `uniforms` 変数の使用（JavaScript からシェーダーへの値渡し）
- 頂点座標の動的な操作
- 時間経過によるアニメーション

## 3. 新しい概念の解説

**Uniform variables（ユニフォーム変数）**
JavaScript（CPU 側）からシェーダー（GPU 側）へデータを渡すための変数です。
「時間（Time）」や「マウス座標」などの変化する値をシェーダーに送ることで、動的なエフェクトを作れます。
シェーダー内では読み取り専用（read-only）として扱われます。

```javascript
// シェーダー定義
const vShader = `
  uniform float uTime;
  void main() {
    vec3 pos = position;
    // サイン波でZ座標を揺らす
    pos.z = sin(pos.x * 5.0 + uTime);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
`;

const uniforms = { uTime: { value: 0.0 } };
const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  uniforms: uniforms
});

// アニメーションループ内で値を更新
function animate() {
  material.uniforms.uTime.value += 0.05;
}
```

## 4. 課題の説明

平面（PlaneGeometry）の頂点を、サイン波を使って波打たせてください。
JavaScript から経過時間（time）をシェーダーに送り、頂点シェーダー内で Z 座標を変化させます。

## 5. 必須要件

以下の機能を実装してください。

- **ジオメトリとユニフォーム**:
  `PlaneGeometry(5, 5, 32, 32)` を作成します（分割数が少ないと波に見えません）。
  ユニフォーム変数 `uniforms = { uTime: { value: 0.0 } }` を用意します。

- **頂点シェーダー**:
  `uniform float uTime;` を受け取ります。
  `vec3 pos = position;` のローカル変数を宣言し、`pos.z = sin(pos.x * 5.0 + uTime) * 0.5` のように操作してから `gl_Position` を計算します。

- **アニメーション**:
  JS のループ内で `material.uniforms.uTime.value += 0.05` のように時間を進め、平面がウネウネと波打つことを確認します。

## 6. ヒント

- **ヒント 1（Uniform変数の定義）**:
  Javascript 側: `uniforms: { uTime: { value: 0 } }`
  GLSL 側: `uniform float uTime;`
  名前が一致している必要があります。
- **ヒント 2（アニメーション更新）**:
  JS の `animate` 関数内で `material.uniforms.uTime.value += 0.01` のように値を書き換えることで、シェーダーに時間が伝わります。
- **ヒント 3（頂点操作）**:
  Vertex Shader 内で `attribute` 変数である `position` を直接書き換えることはできません。
  `vec3 pos = position;` のようにコピーを作ってから `pos.z += ...` と加工し、それを `gl_Position` の計算に使います。
- **ヒント 4（ポリゴン分割数）**:
  `PlaneGeometry(幅, 高さ, 横分割数, 縦分割数)` です。
  頂点シェーダーは頂点しか動かせないため、分割数が少ない（1x1など）と、板全体が上下するだけで波打って見えません。32x32 くらい推奨です。
- **ヒント 5（波の式）**:
  `sin(pos.x + uTime)` だと X 軸方向に進む波になります。
  数値を掛けて `sin(pos.x * 5.0 + uTime)` とすると波が細かくなります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    uniform float uTime;
    void main() {
        vec3 pos = position;
        // --- ここでpos.zを操作 ---
        
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
`;

const fShader = `
    void main() {
        gl_FragColor = vec4(0.0, 0.5, 1.0, 1.0);
    }
`;

const uniforms = {
  uTime: { value: 0.0 },
};

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  uniforms: uniforms,
  wireframe: true, // 動きが見やすいように
});

const plane = new THREE.Mesh(new THREE.PlaneGeometry(5, 5, 32, 32), material);
scene.add(plane);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // --- ここでuTimeを更新 ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const vShader = `
    uniform float uTime;
    void main() {
        vec3 pos = position;
        // X座標に応じてサイン波でZを揺らす
        pos.z = sin(pos.x * 2.0 + uTime) * 0.5;
        
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
`;

const fShader = `
    void main() {
        gl_FragColor = vec4(0.0, 0.8, 1.0, 1.0); // 水色
    }
`;

const uniforms = {
  uTime: { value: 0.0 },
};

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  uniforms: uniforms,
  wireframe: true,
  side: THREE.DoubleSide,
});

const plane = new THREE.Mesh(new THREE.PlaneGeometry(5, 5, 32, 32), material);
plane.rotation.x = 0.5; // 見やすいように傾ける
scene.add(plane);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // 時間を更新
  material.uniforms.uTime.value += 0.05;

  renderer.render(scene, camera);
}
animate();
```
