## 1. 問題タイトル

34 本目：複数マテリアルの使用

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 1 つのメッシュに複数のマテリアルを適用する方法
- マテリアルの配列（Array）の使用
- 面ごとのマテリアル指定（BoxGeometry の特性）

## 3. 新しい概念の解説

**Multiple Materials（複数マテリアル）**
1 つのメッシュに対して、複数のマテリアルを適用するテクニックです。
`BoxGeometry` などの一部のジオメトリは、マテリアルを配列として渡すことで、特定の面（右、左、上、下、前、後）ごとに異なるマテリアルを割り当てることができます。

```javascript
const materials = [
  new THREE.MeshBasicMaterial({ color: 'red' }),    // 右
  new THREE.MeshBasicMaterial({ color: 'green' }),  // 左
  new THREE.MeshBasicMaterial({ color: 'blue' }),   // 上
  new THREE.MeshBasicMaterial({ color: 'yellow' }), // 下
  new THREE.MeshBasicMaterial({ color: 'cyan' }),   // 前
  new THREE.MeshBasicMaterial({ color: 'magenta' }) // 後
];

const cube = new THREE.Mesh(geometry, materials);
```

## 4. 課題の説明

サイコロのようなキューブを作成してください。
6 つの面それぞれに異なる色（またはテクスチャ）のマテリアルを適用します。

## 5. 必須要件

以下の機能を実装してください。

- **マテリアル配列の作成**:
  6種類の異なる色（またはテクスチャ）を持つ `MeshBasicMaterial` を作成し、配列に格納します。
  `const materials = [ mat1, mat2, mat3, mat4, mat5, mat6 ];`

- **メッシュの作成**:
  `BoxGeometry` を作成します。
  `new THREE.Mesh(geometry, materials)` の第2引数に、作成したマテリアル配列を渡します。

- **描画確認**:
  作成したボックスを回転させ、6つの面すべてが指定通りの異なるマテリアルでレンダリングされていることを確認します。

## 6. ヒント

- **ヒント 1（マテリアル配列）**:
  `const materials = [ mat1, mat2, mat3, mat4, mat5, mat6 ];` のように、単純な配列を作るだけです。
- **ヒント 2（面の対応順序）**:
  BoxGeometry の場合、以下の順序で割り当てられます。
  0: 右 (x+)
  1: 左 (x-)
  2: 上 (y+)
  3: 下 (y-)
  4: 前 (z+)
  5: 後 (z-)
- **ヒント 3（グループ化）**:
  この機能はジオメトリの `groups` 属性を利用しています。BoxGeometry はデフォルトで 6 つのグループ（面）を持っていますが、SphereGeometry などはデフォルトでは持っていません。
- **ヒント 4（作成方法）**:
  `new THREE.Mesh(geometry, materials)`
  第 2 引数に、単体のマテリアルではなく配列を渡すところがポイントです。
- **ヒント 5（テクスチャの混在）**:
  ある面は「赤色」、ある面は「画像テクスチャ」のように、異なる設定のマテリアルを混ぜても問題なく動作します。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BoxGeometry(2, 2, 2);

// --- ここで6つのマテリアルを作成し、配列にしてください ---

// --- ここで配列を使ってメッシュを作成 ---

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  // 回転
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BoxGeometry(2, 2, 2);

// 6つのマテリアルを配列で用意
const materials = [
  new THREE.MeshBasicMaterial({ color: 0xff0000 }), // 右: 赤
  new THREE.MeshBasicMaterial({ color: 0x00ff00 }), // 左: 緑
  new THREE.MeshBasicMaterial({ color: 0x0000ff }), // 上: 青
  new THREE.MeshBasicMaterial({ color: 0xffff00 }), // 下: 黄
  new THREE.MeshBasicMaterial({ color: 0x00ffff }), // 前: 水色
  new THREE.MeshBasicMaterial({ color: 0xff00ff }), // 後: 紫
];

// 配列を渡すと、各面に適用される
const cube = new THREE.Mesh(geometry, materials);
scene.add(cube);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;

  renderer.render(scene, camera);
}
animate();
```
