## 1. 問題タイトル

71 本目：PBR マテリアルの使用（物理ベースレンダリング）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `MeshStandardMaterial` の詳細設定
- `metalness`（金属度）と `roughness`（粗さ）の関係
- 環境マップ（Environment Map）の重要性

## 3. 新しい概念の解説

**PBR (Physically Based Rendering / 物理ベースレンダリング)**
光の挙動を物理法則に基づいて計算する手法です。
Three.js の `MeshStandardMaterial` は PBR マテリアルであり、`metalness`（金属っぽさ）と `roughness`（表面のザラつき具合）の2つのパラメータで、プラスチックから金属まであらゆる質感をリアルに表現します。
現実のような反射を再現するには「環境マップ」が必須です。

```javascript
// 環境マップの設定（PBRにはほぼ必須）
new THREE.TextureLoader().load('env.jpg', (texture) => {
  texture.mapping = THREE.EquirectangularReflectionMapping;
  scene.environment = texture; // シーン全体の光源として扱う
});

const material = new THREE.MeshStandardMaterial({
  color: 0xffffff,
  metalness: 1.0, // 1.0で完全な金属
  roughness: 0.2  // 0.0でツルツル、1.0でザラザラ
});
```

## 4. 課題の説明

物理的に正しい光の反射をシミュレートする PBR マテリアルを使って、金属やプラスチックのような質感を表現してください。
PBR マテリアルは環境マップ（周囲の景色）がないと真価を発揮しないため、必ず環境マップを設定します。

## 5. 必須要件

以下の機能を実装してください。

- **環境マップのロード**:
  `TextureLoader` で画像（JPEGなど）を読み込み、コールバック関数内で以下を設定します。
  1. `texture.mapping = THREE.EquirectangularReflectionMapping`
  2. `scene.environment = texture`
  3. `scene.background = texture`（任意ですが確認に便利）

- **PBR マテリアルのテスト**:
  ループを使って複数の球体を作成し、グリッド状に配置します。
  各球体のマテリアル (`MeshStandardMaterial`) の `metalness` と `roughness` を変化させます。
  - X 軸方向: `metalness` を 0.0 から 1.0 へ変化
  - Y 軸方向: `roughness` を 0.0 から 1.0 へ変化
  これにより、25〜100個程度の異なる質感パターンの球体を表示します。

## 6. ヒント

- **ヒント 1（PBRの基本）**:
  `MeshStandardMaterial` は物理法則に基づいたマテリアルです。
  `metalness`（1.0で金属）と `roughness`（0.0でツルツル、1.0でザラザラ）のバランスで質感を決めます。
- **ヒント 2（環境マップの重要性）**:
  金属（`metalness: 1`）は周囲の景色を反射することで金属らしく見えます。
  環境マップ（`scene.environment`）がないと、ただの黒っぽい物体に見えてしまいます。
- **ヒント 3（ロード手順）**:
  `new THREE.TextureLoader().load('url', (tex) => { ... })` のコールバック内で設定します。
  `tex.mapping = THREE.EquirectangularReflectionMapping` を忘れずに設定してください。
- **ヒント 4（トーンマッピング）**:
  `renderer.toneMapping = THREE.ACESFilmicToneMapping` を設定すると、光の表現がより写実的（フォトリアル）になります。
- **ヒント 5（ライト）**:
  環境マップで全体的な明かりは確保できますが、影（Shadow）を落とすためには別途 `DirectionalLight` などを追加するのが一般的です。

## 7. スターターコード

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping; // リアルなトーンマッピング
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

// 環境マップ読み込み（必須）
const loader = new THREE.TextureLoader();
// loader.load('...', (texture) => {
//     texture.mapping = THREE.EquirectangularReflectionMapping;
//     scene.environment = texture;
//     scene.background = texture;
// });

// --- ここで球体を複数配置 ---

camera.position.z = 10;

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

// 環境マップ（これがないと金属が黒くなる）
const loader = new THREE.TextureLoader();
loader.load(
  "https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg",
  (texture) => {
    texture.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = texture;
    scene.background = texture;
  }
);

const geometry = new THREE.SphereGeometry(0.5, 32, 32);

// 縦横に並べる
for (let x = 0; x <= 5; x++) {
  for (let y = 0; y <= 5; y++) {
    const metalness = x / 5;
    const roughness = y / 5;

    const material = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      metalness: metalness,
      roughness: roughness,
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set((x - 2.5) * 1.2, (y - 2.5) * 1.2, 0);
    scene.add(mesh);
  }
}

camera.position.z = 8;

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
```
