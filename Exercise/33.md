## 1. 問題タイトル

33 本目：ノーマルマップの適用

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `normalMap`（法線マップ）の使用
- バンプマップとの違い（より高精細な表現）
- 法線の向きを変えることによる立体表現

## 3. 新しい概念の解説

**Normal Mapping（ノーマルマッピング/法線マッピング）**
バンプマップの進化版です。
バンプマップが「高さ」だけの情報を持つのに対し、ノーマルマップは RGB 各チャンネルに「面の向き（法線ベクトル）」の情報を格納しています（紫色の画像に見えます）。
これにより、より精細で複雑な陰影表現が可能になります。

```javascript
const texture = loader.load('normal.jpg');
const material = new THREE.MeshStandardMaterial({
  normalMap: texture,
  normalScale: new THREE.Vector2(1, 1) // XY方向の強さ
});
```

## 4. 課題の説明

バンプマップよりも高度な「ノーマルマップ（紫色の画像）」を使って、平面に複雑なディテールを追加してください。
光の反射方向をピクセル単位で制御し、非常にリアルな凹凸を表現します。

## 5. 必須要件

以下の機能を実装してください。

- **ノーマルマップの読み込み**:
  `TextureLoader` でノーマルマップ（法線マップ）画像を読み込みます。通常、紫がかった画像です。

- **マテリアル設定**:
  `MeshStandardMaterial` を使用し、`normalMap` プロパティにテクスチャを設定します。

- **ノーマルスケールの調整**:
  `material.normalScale`（`Vector2`型）を設定し、凹凸の強さを調整します。
  例：`new THREE.Vector2(1.0, 1.0)`

- **描画確認**:
  バンプマップよりも精細で立体的な陰影が表示されることを確認します。
  ライトを動かすと、光沢（反射光）が法線に沿って変化します。

## 6. ヒント

- **ヒント 1（画像の特徴）**:
  ノーマルマップは全体的に薄紫色（R:0.5, G:0.5, B:1.0 近辺）をしています。
  この RGB 値がそれぞれ XYZ 軸方向の「面の傾き（法線）」を表しています。
- **ヒント 2（バンプマップとの違い）**:
  バンプマップ（高さ情報のみ）よりも、ノーマルマップ（角度情報）の方がより精細でリアルな陰影表現が可能です。
  現在の 3D ゲームではノーマルマップが主流です。
- **ヒント 3（強さの調整）**:
  `material.normalScale = new THREE.Vector2(1, 1)` で調整します。
  `(2, 2)` にすると凹凸が強調され、`(0.5, 0.5)` にすると控えめになります。
- **ヒント 4（ライトの動き）**:
  静止画だと分かりにくいですが、ライトを動かすと、光沢（スペキュラ）が凹凸に沿ってキラキラと移動するのが確認できます。
- **ヒント 5（読み込み）**:
  通常の `TextureLoader` で読み込み、`material.normalMap` に割り当てるだけです。設定は簡単です。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const loader = new THREE.TextureLoader();
const normalTexture = loader.load(
  "https://threejs.org/examples/textures/water/Water_1_M_Normal.jpg"
);

// --- ここでノーマルマップを適用 ---

const light = new THREE.PointLight(0xffffff, 2);
light.position.set(2, 2, 2);
scene.add(light);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  // ライトを動かすと効果がわかりやすい
  light.position.x = Math.sin(Date.now() * 0.001) * 3;
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const loader = new THREE.TextureLoader();
// 水面のノーマルマップ
const normalTexture = loader.load(
  "https://threejs.org/examples/textures/water/Water_1_M_Normal.jpg"
);

const geometry = new THREE.PlaneGeometry(4, 4);
const material = new THREE.MeshStandardMaterial({
  color: 0x0088ff,
  normalMap: normalTexture, // ノーマルマップ設定
  roughness: 0.1,
});

const plane = new THREE.Mesh(geometry, material);
scene.add(plane);

const light = new THREE.PointLight(0xffffff, 2);
light.position.set(0, 0, 2);
scene.add(light);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // ライトをぐるぐる回して、陰影の変化を確認
  const time = Date.now() * 0.001;
  light.position.x = Math.sin(time) * 3;
  light.position.y = Math.cos(time) * 3;

  renderer.render(scene, camera);
}
animate();
```
