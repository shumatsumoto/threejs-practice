## 1. 問題タイトル

70 本目：フラットシェーディング（ローポリ表現）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `flatShading: true` の効果
- 法線のスムージング無効化
- ローポリゴン（Low Poly）アートスタイルの作成

## 3. 新しい概念の解説

**Flat Shading / Low Poly（フラットシェーディング・ローポリ）**
ポリゴンの継ぎ目を目立たなくする「スムージング」を行わず、面ごとの角度をそのまま生かして陰影をつける手法です。
カクカクした見た目になりますが、レトロゲーム風やモダンなデザインスタイル（ローポリゴンアート）として意図的に使われます。
`flatShading: true` プロパティ一つで有効にできます。

```javascript
const material = new THREE.MeshStandardMaterial({
  color: 0xff4400,
  flatShading: true, // フラットシェーディングを有効化
  roughness: 0.5
});
```

## 4. 課題の説明

球体などの曲面を持つオブジェクトを、カクカクした「ローポリゴン」スタイルで表示してください。
通常、Three.js は頂点間の法線を補間して滑らかに見せますが、フラットシェーディングを有効にすると、面ごとに単一の色で塗られ、ポリゴン感が強調されます。

## 5. 必須要件

以下の機能を実装してください。

- **ジオメトリ**:
  `IcosahedronGeometry(1, 1)`（正二十面体の分割1回）など、頂点数が少なめで三角形が整っているジオメトリを作成します。

- **マテリアル**:
  `MeshStandardMaterial` または `MeshPhongMaterial` を作成し、`flatShading: true` を設定します。
  `color` は明るめの色（オレンジなど）にします。

- **ライティング**:
  `DirectionalLight` を当て、曲面が滑らかにならず、ポリゴンの面ごとにカクカクとした陰影がつく「ローポリゴン」スタイルになることを確認します。

## 6. ヒント

- **ヒント 1（ジオメトリの選択）**:
  `SphereGeometry` はポリゴン配置が極付近で歪むため、均等な三角形で構成される `IcosahedronGeometry`（正二十面体）を使うのがローポリ表現では一般的です。
  第 2 引数（detail）を 1〜2 にすると適度なカクカク感が出ます。
- **ヒント 2（マテリアル設定）**:
  `MeshStandardMaterial` や `MeshPhongMaterial` のコンストラクタで `{ flatShading: true }` を指定します。
  あるいは作成後に `material.flatShading = true; material.needsUpdate = true;` としても有効になります。
- **ヒント 3（法線の仕組み）**:
  通常は頂点ごとに定義された法線を補間して曲面に見せますが、フラットシェーディングでは「面（三角形）ごと」に均一な法線を使用するため、面単位で光の反射が計算されます。
- **ヒント 4（ライトの重要性）**:
  `AmbientLight` だけでは陰影がつかないため、フラットシェーディングの効果がわかりません。
  必ず `DirectionalLight` や `PointLight` を配置して角度による明暗差を作ってください。
- **ヒント 5（ローポリの美学）**:
  影（Shadow）を有効にしたり、パステルカラーを使用したりすると、モダンで可愛らしいローポリゴンアートになります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 5, 5);
scene.add(light);

// --- ここでフラットシェーディングのマテリアルを作成 ---
// const material = new THREE.MeshStandardMaterial({ ... });

const mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(2, 1), material);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  mesh.rotation.x += 0.005;
  mesh.rotation.y += 0.005;
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 5, 5);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

const geometry = new THREE.IcosahedronGeometry(2, 1); // 少し粗めの球体

const material = new THREE.MeshStandardMaterial({
  color: 0xff4400,
  flatShading: true, // これを有効にする
  roughness: 0.5,
});

const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  mesh.rotation.x += 0.005;
  mesh.rotation.y += 0.005;

  renderer.render(scene, camera);
}
animate();
```
