## 1. 問題タイトル

49 本目：カメラパスアニメーション（ジェットコースター）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- カメラ自体をパスに沿って移動させる
- `lookAt` を使って進行方向（少し先）を見る制御
- 没入感のあるカメラワークの実装

## 3. 新しい概念の解説

**Camera Path Animation（カメラパスアニメーション）**
カメラ自体をパスに沿って動かすことで、ジェットコースターや映画のようなダイナミックな視点移動を作れます。
ポイントは「位置（Position）」だけでなく「見る方向（LookAt）」も制御することです。
「現在の位置」から「少し先の未来の位置」を見るように設定すると、進行方向を向いた自然な動きになります。

```javascript
// 1. カメラを曲線上の現在位置に移動
const pos = curve.getPoint(t);
camera.position.copy(pos);

// 2. カメラを「少し先」の位置に向ける
const lookAtPos = curve.getPoint((t + 0.01) % 1);
camera.lookAt(lookAtPos);
```

## 4. 課題の説明

演習 48 の応用です。今度はオブジェクトではなく「カメラ」をパスに沿って移動させてください。
さらに、カメラが常に「少し先の地点」を見るようにして、ジェットコースターに乗っているような視点を作成します。

## 5. 必須要件

以下の機能を実装してください。

- **コースと環境の作成**:
  `CatmullRomCurve3` でコースを作ります。
  カメラの動きが分かりやすいように、周囲に `GridHelper` や複数のキューブなどを配置します。

- **カメラの移動**:
  アニメーションループ内で進行度 `t` を更新し、`curve.getPoint(t)` の座標を `camera.position` に適用します。

- **カメラの向き（視線）**:
  「少し先の地点」を取得するため、`curve.getPoint((t + 0.01) % 1.0)` を計算します。
  `camera.lookAt(targetPoint)` を実行し、常に進行方向を見るようにします。

- **動作確認**:
  ジェットコースターに乗っているような視点でシーン内を移動することを確認します。

## 6. ヒント

- **ヒント 1（カメラ移動）**:
  カメラも `position` プロパティを持つ `Object3D` の一種です。
  `camera.position.copy( curve.getPoint(t) )` で移動できます。
- **ヒント 2（視線制御）**:
  進行方向を向かせるには、少し未来の点 `t + 0.01` を取得します。
  `const lookAtPos = curve.getPoint( (t + 0.01) % 1 );`
  `camera.lookAt(lookAtPos);`
- **ヒント 3（周辺環境）**:
  宇宙空間のような真っ暗な場所だと自分が動いているのか分かりません。`GridHelper` や適当な直方体などを配置して、速度感が出るようにしましょう。
- **ヒント 4（ループ処理）**:
  `(t + 0.01) % 1` のように剰余演算子を使うことで、`t` が 0.99 のときに 1.00 を超えてエラーになる（または変な場所を見る）のを防ぎ、綺麗にループの先頭を見ることができます。
- **ヒント 5（カーブの形状）**:
  急すぎるカーブ（鋭角な折れ曲がり）はカメラが激しくブレて酔いの原因になるので、`CatmullRomCurve3` の良さを活かして点の間隔を広めにとりましょう。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 参照用のグリッド
scene.add(new THREE.GridHelper(50, 50));
scene.add(new THREE.AxesHelper(5));

// --- カーブ作成 ---
// const curve = ...

let progress = 0;

function animate() {
  requestAnimationFrame(animate);

  // --- ここでカメラ位置と向きを更新 ---

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 参照物（これがないと動いているか分からない）
const gridHelper = new THREE.GridHelper(100, 100);
scene.add(gridHelper);

// ランダムな箱を配置
for (let i = 0; i < 50; i++) {
  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(2, 2, 2),
    new THREE.MeshNormalMaterial()
  );
  mesh.position.set(
    (Math.random() - 0.5) * 80,
    (Math.random() - 0.5) * 20 + 10,
    (Math.random() - 0.5) * 80
  );
  scene.add(mesh);
}

// コース作成
const curve = new THREE.CatmullRomCurve3(
  [
    new THREE.Vector3(0, 5, 20),
    new THREE.Vector3(20, 10, 0),
    new THREE.Vector3(0, 20, -20),
    new THREE.Vector3(-20, 5, 0),
  ],
  true
);

// コースの可視化
const points = curve.getPoints(100);
const line = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(points),
  new THREE.LineBasicMaterial({ color: 0xffff00 })
);
scene.add(line);

let progress = 0;

function animate() {
  requestAnimationFrame(animate);

  progress += 0.001;
  if (progress > 1) progress = 0;

  // 1. 現在位置にカメラを置く
  const currentPos = curve.getPoint(progress);
  camera.position.copy(currentPos);

  // 2. 少し先を見る（進行方向を向く）
  const lookAtPos = curve.getPoint((progress + 0.01) % 1);
  camera.lookAt(lookAtPos);

  renderer.render(scene, camera);
}
animate();
```
