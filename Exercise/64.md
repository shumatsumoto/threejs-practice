## 1. 問題タイトル

64 本目：グリッチエフェクト（GlitchPass）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `GlitchPass` の使用方法
- デジタルノイズ表現
- `goWild` プロパティによる激しいグリッチの制御

## 3. 新しい概念の解説

**Glitch Effect（グリッチエフェクト）**
デジタル機器の故障や信号不良によって起こる画面の乱れを再現したエフェクトです。
ブロックノイズ、色の反転、画面のズレなどをランダムに発生させます。
`GlitchPass` を使うだけで簡単に実装でき、サイバーパンクやホラーの演出に効果的です。

```javascript
import { GlitchPass } from 'three/examples/jsm/postprocessing/GlitchPass';

const glitchPass = new GlitchPass();

// trueにすると常に激しく乱れる（通常はランダム）
// glitchPass.goWild = true;

composer.addPass(glitchPass);
```

## 4. 課題の説明

画面が乱れる「グリッチ（故障）」エフェクトを追加してください。
サイバーパンクやホラー表現などで使われる、画面がズレたり色が反転したりする効果です。

## 5. 必須要件

以下の機能を実装してください。

- **EffectComposer 設定**:
  `EffectComposer` と `RenderPass` をセットアップします。

- **GlitchPass 設定**:
  `three/examples/jsm/postprocessing/GlitchPass` をインポートし、Composerに追加します。
  画面がランダムに乱れることを確認します。

- **制御**:
  `glitchPass.goWild = true` に設定すると、常に激しい乱れが発生することを確認します（コメントアウト等で切り替え）。

## 6. ヒント

- **ヒント 1（必要なクラスのインポート）**:
  `EffectComposer`, `RenderPass` に加え、
  `three/examples/jsm/postprocessing/GlitchPass` をインポートします。
- **ヒント 2（Composerのセットアップ）**:
  `const composer = new EffectComposer(renderer);`
  `composer.addPass(new RenderPass(scene, camera));`
  この基本形はどのポストプロセスでも共通です。
- **ヒント 3（GlitchPassの設定）**:
  `const glitchPass = new GlitchPass();`
  `composer.addPass(glitchPass);` だけで適用されます。
  コンストラクタに引数は通常不要です。
- **ヒント 4（激しさの制御）**:
  `glitchPass.goWild = true;` というプロパティを設定すると、ランダムではなく常に激しいグリッチが発生し続けます。
  イベントに合わせて切り替えるのも面白いでしょう。
- **ヒント 5（描画）**:
  `renderer.render(...)` の代わりに `composer.render()` を呼ぶのを忘れないでください。
  これを忘れるとエフェクトが表示されません。

## 7. スターターコード

```javascript
import * as THREE from "three";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass";
// import { GlitchPass } ...

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshNormalMaterial()
);
scene.add(cube);

// --- ComposerとGlitchPass ---

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
  // composer.render();
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass";
import { GlitchPass } from "three/examples/jsm/postprocessing/GlitchPass";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshNormalMaterial()
);
scene.add(cube);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

// グリッチパス
const glitchPass = new GlitchPass();
// glitchPass.goWild = true; // これを有効にすると常に激しくなる
composer.addPass(glitchPass);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;

  composer.render();
}
animate();
```
