## 1. 問題タイトル

51 本目：シンプルなカスタムシェーダー（ShaderMaterial）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `ShaderMaterial` の基本構造
- 頂点シェーダー（Vertex Shader）の役割
- フラグメントシェーダー（Fragment Shader）の役割

## 3. 新しい概念の解説

**Shader Programming（シェーダープログラミング）**
Three.js の標準マテリアル（MeshBasicMaterial など）の裏側で動いている「GPU への命令」を直接書く技術です。
言語は GLSL（OpenGL Shading Language）を使用します。
- `Vertex Shader`: 頂点の位置を決める（形を作る）
- `Fragment Shader`: ピクセルの色を決める（色を塗る）

```javascript
// 1. 頂点シェーダー (形)
const vShader = `
  void main() {
    // 3D座標を2Dスクリーン座標に変換
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

// 2. フラグメントシェーダー (色)
const fShader = `
  void main() {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // 赤色
  }
`;

// 3. マテリアル作成
const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader
});
```

## 4. 課題の説明

Three.js の標準マテリアルを使わず、GLSL（シェーダー言語）を書いて、オブジェクトを単色（赤色など）で塗りつぶしてください。
これがシェーダープログラミングの「Hello World」になります。

## 5. 必須要件

以下の機能を実装してください。

- **頂点シェーダーの定義**:
  Javascript の文字列リテラルで `main() { gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }` を記述します（標準的な位置計算）。

- **フラグメントシェーダーの定義**:
  `main() { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); }` のように、単色（赤など）を出力するコードを記述します。

- **マテリアルとメッシュ作成**:
  `new THREE.ShaderMaterial({ vertexShader, fragmentShader })` を作成し、適当なジオメトリのメッシュに適用して表示します。
  赤く塗りつぶされた形状が表示されることを確認します。

## 6. ヒント

- **ヒント 1（言語仕様）**:
  GLSL（.glsl）という C 言語に似た言語を使います。
  行末のセミコロン `;` が必須だったり、整数 `1` と小数 `1.0` を厳密に区別する必要があるなど、JavaScript よりも厳格です。
- **ヒント 2（gl_Position）**:
  Vertex Shader の必須出力です。
  `projectionMatrix * modelViewMatrix * vec4(position, 1.0);`
  この呪文のような一行が、3D 空間の点を 2D スクリーン上の点に変換しています。
- **ヒント 3（gl_FragColor）**:
  Fragment Shader の必須出力です。
  `vec4(R, G, B, A)` の形式で、そのピクセルの最終的な色を決定します。
- **ヒント 4（エラー確認）**:
  シェーダーに記述ミス（コンパイルエラー）があると、画面には何も表示されず、ブラウザのコンソールに赤いエラーログが出ます。
  真っ黒なときはまずコンソール（F12）を確認しましょう。
- **ヒント 5（main関数）**:
  Vertex も Fragment も `void main() { ... }` 関数の中に処理を書きます。
  関数の外には変数の定義などを書くことができます。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- シェーダー定義 ---
const vShader = `
    void main() {
        // ここで頂点位置を計算
    }
`;

const fShader = `
    void main() {
        // ここで色を出力
    }
`;

// --- マテリアル作成 ---
// const material = new THREE.ShaderMaterial({ ... });

const mesh = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), material);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  mesh.rotation.x += 0.01;
  mesh.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 1. 頂点シェーダー
// 3D空間の座標を2D画面上の座標に変換する
const vShader = `
    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

// 2. フラグメントシェーダー
// ピクセルの色を決める
const fShader = `
    void main() {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // 赤色 (R, G, B, A)
    }
`;

// 3. マテリアル作成
const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
});

const mesh = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), material);
scene.add(mesh);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  mesh.rotation.x += 0.01;
  mesh.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```
