## 1. 問題タイトル

46 本目：スプライトの使用

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `THREE.Sprite` と `THREE.SpriteMaterial` の使用
- 常にカメラを向く 2D オブジェクト（ビルボード）
- テクスチャを使ったアイコンやパーティクルの表現

## 3. 新しい概念の解説

**Sprite（スプライト）**
3D 空間に存在しながら、常にカメラの正面を向き続ける「板」です。
遠景の樹木、パーティクル（火の粉や煙）、キャラクターの頭上の名前表示など、立体である必要がない（または立体にすると重すぎる）オブジェクトの表現に使われます。

```javascript
const map = new THREE.TextureLoader().load('icon.png');
const material = new THREE.SpriteMaterial({ map: map, color: 0xffffff });
const sprite = new THREE.Sprite(material);

// サイズ調整 (x, y, z)
sprite.scale.set(2, 2, 1);
scene.add(sprite);
```

## 4. 課題の説明

3D 空間内に、常にカメラの正面を向く画像（スプライト）を配置してください。
スプライトは、遠くにある木や、キャラクターの頭上の名前表示、UI アイコンなどによく使われます。

## 5. 必須要件

以下の機能を実装してください。

- **テクスチャの読み込み**:
  `TextureLoader` を使用して画像（`icon.png` や円形の画像など）を読み込みます。

- **SpriteMaterial の作成**:
  `new THREE.SpriteMaterial({ map: texture })` でマテリアルを作成します。
  `color` プロパティで色味を変えることも可能です。

- **Sprite の配置**:
  `new THREE.Sprite(material)` でスプライトオブジェクトを作成し、シーンに追加します。
  `scale.set(x, y, 1)` で適切なアスペクト比またはサイズに調整します。

- **動作確認**:
  カメラを回転（OrbitControlsなどで移動）させても、画像が常に正面を向いていることを確認します。

## 6. ヒント

- **ヒント 1（専用マテリアル）**:
  `MeshBasicMaterial` は使えません。必ず `SpriteMaterial` を使います。
- **ヒント 2（形状）**:
  デフォルトでは正方形（1x1）として表示されます。
  画像の縦横比に合わせて `sprite.scale.set(幅, 高さ, 1)` で調整してください。
- **ヒント 3（回転不要）**:
  Sprite は仕様として「常にカメラを向く」ため、`rotation` や `lookAt` を設定する必要はありません（Z 軸回転で傾けることは可能です）。
- **ヒント 4（座標）**:
  3D 空間上の点（XYZ）に存在します。遠近法も適用されるため、遠くに行けば小さくなります。
- **ヒント 5（用途）**:
  球体パーティクル、光のフレア、テキストラベルなどに適しています。床や壁のような「角度が必要なもの」には適していません。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const loader = new THREE.TextureLoader();
// const map = loader.load('...');
// const material = new THREE.SpriteMaterial({ map: map });
// const sprite = new THREE.Sprite(material);

// scene.add(sprite);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);

  // カメラを回して確認
  camera.position.x = Math.sin(Date.now() * 0.001) * 5;
  camera.position.z = Math.cos(Date.now() * 0.001) * 5;
  camera.lookAt(0, 0, 0);

  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const loader = new THREE.TextureLoader();
const map = loader.load("https://threejs.org/examples/textures/sprite0.png");

const material = new THREE.SpriteMaterial({
  map: map,
  color: 0xffffff,
});

const sprite = new THREE.Sprite(material);
sprite.scale.set(2, 2, 1); // サイズ調整
scene.add(sprite);

// 比較用に普通のメッシュも置く
const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
);
cube.position.x = 2;
scene.add(cube);

function animate() {
  requestAnimationFrame(animate);

  // カメラを周囲で回転させる
  const time = Date.now() * 0.001;
  camera.position.x = Math.sin(time) * 5;
  camera.position.z = Math.cos(time) * 5;
  camera.lookAt(0, 0, 0);

  renderer.render(scene, camera);
}
animate();
```
