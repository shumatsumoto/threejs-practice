## 1. 問題タイトル

24 本目：Raycaster で 3D オブジェクトの選択

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 複数のオブジェクトからの特定
- 配列を使ったオブジェクト管理
- 選択状態の可視化（色変更など）

## 3. 新しい概念の解説

**Array of Objects（オブジェクト配列）**
複数のメッシュを一つの変数（配列）でまとめて管理する方法です。
`scene.children` にはライトやカメラなど全てのオブジェクトが含まれてしまいますが、自分で作った `cubes` 配列を使えば、特定のグループだけを対象に判定や操作ができて効率的です。

```javascript
const cubes = [cube1, cube2, cube3];
// cubes配列内のオブジェクトのみと交差判定
const intersects = raycaster.intersectObjects(cubes);
```

**Reset State（状態のリセット）**
「選択されたものだけ赤くする」という処理は、「一度すべてを緑に戻してから、該当するものだけ赤にする」という手順で実装するのが定石です。これにより、前の選択状態を気にせずにシンプルに処理できます。

```javascript
// 1. 全てリセット（元の色に戻す）
cubes.forEach(cube => cube.material.color.set(0x00ff00));

// 2. 選択されたものだけ変更
if (intersects.length > 0) {
    intersects[0].object.material.color.set(0xff0000);
}
```

## 4. 課題の説明

画面上にランダムに配置された 10 個のキューブの中から、クリックしたキューブだけを赤色に変えてください。
それ以外のキューブは元の色（緑）に戻るようにしてください（単一選択モード）。

## 5. 必須要件

以下の機能を実装してください。

- **複数オブジェクトの準備**:
  forループで 10 個のキューブを作成し、シーンに追加すると同時に、作成したキューブを管理用の配列 `cubes` に格納（push）します。
  位置はランダムにばらけさせてください。

- **クリック判定の対象指定**:
  `raycaster.intersectObjects(cubes)` のように、管理配列を渡して判定を行います（シーン全体を判定するより効率的です）。

- **選択処理の実装（単一選択）**:
  判定結果に応じて、以下の手順で色を更新します。
  1. **リセット**: まず `cubes` 配列の**全要素**を緑色（未選択色）に戻します。
  2. **選択**: 交差判定があった場合、その先頭（一番手前）のオブジェクトだけ赤色（選択色）に変更します。

## 6. ヒント

- **ヒント 1（ロジックの順番）**:
  「選択処理」の基本ロジックは、「①全員非選択にする」→「②ターゲットだけ選択にする」の順です。
  これなら「前に何が選ばれていたか」を記憶しておく必要がありません。
- **ヒント 2（配列管理）**:
  `scene.add(cube)` しただけでは、後で「全てのキューブ」をループするのが大変です（ライトなども混ざるため）。
  自分で `const cubes = []` を用意し、作成時に `cubes.push(cube)` しておくのが定石です。
- **ヒント 3（リセット方法）**:
  `cubes.forEach(c => c.material.color.set(0x00ff00))` のように、forEach を使うと簡潔に書けます。
- **ヒント 4（判定対象）**:
  `raycaster.intersectObjects(cubes)` のように配列を渡すことで、そのリストに含まれるオブジェクトだけを判定対象にできます。
- **ヒント 5（何もないところ）**:
  交差判定の結果が 0 個（クリックした場所に何もない）場合、if 文に入らないため「全員緑（非選択）」の状態になります。これも自然な挙動です。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const cubes = [];
// --- ここで10個のキューブをランダム配置してください ---

camera.position.z = 10;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("click", (event) => {
  // --- ここでクリック判定と色変更を行ってください ---
});

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const cubes = [];
const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);

// 10個のキューブをランダム配置
for (let i = 0; i < 10; i++) {
  const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  const cube = new THREE.Mesh(geometry, material);

  cube.position.x = (Math.random() - 0.5) * 10;
  cube.position.y = (Math.random() - 0.5) * 10;
  cube.position.z = (Math.random() - 0.5) * 5;

  scene.add(cube);
  cubes.push(cube);
}

camera.position.z = 10;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("click", (event) => {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  // cubes配列内のオブジェクトのみを対象に判定
  const intersects = raycaster.intersectObjects(cubes);

  if (intersects.length > 0) {
    // 1. まず全て緑に戻す
    cubes.forEach((cube) => cube.material.color.set(0x00ff00));

    // 2. 選択されたものだけ赤にする
    intersects[0].object.material.color.set(0xff0000);
  }
});

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```
