## 1. 問題タイトル

31 本目：環境マッピング

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- `CubeTextureLoader` を使った環境マップの読み込み
- `envMap` プロパティによる映り込み表現
- 金属やガラスのような質感の作成

## 3. 新しい概念の解説

**Environment Map（環境マップ）**
オブジェクトの周囲の景色を表すテクスチャのことです。
金属や鏡のような素材は、周りの景色を反射することでその質感が表現されます。
`CubeTexture`（上下左右前後の 6 枚画像）を使って、完全な映り込みを作ることができます。

**PBR Material（物理ベースマテリアル）**
`MeshStandardMaterial` は物理法則に基づいたレンダリングを行います。
- `metalness`: 金属っぽさ（1.0 で完全な金属）
- `roughness`: 表面の粗さ（0.0 でツルツルの鏡面、1.0 でマットな非光沢）

```javascript
const loader = new THREE.CubeTextureLoader();
const envMap = loader.load([
  'px.jpg', 'nx.jpg',
  'py.jpg', 'ny.jpg',
  'pz.jpg', 'nz.jpg'
]);

// 背景に設定
scene.background = envMap;

// 鏡面マテリアル
const material = new THREE.MeshStandardMaterial({
  envMap: envMap,
  metalness: 1.0,
  roughness: 0.0
});
```

## 4. 課題の説明

周囲の景色が映り込む「鏡面仕上げの球体」を作成してください。
環境マップ（6 枚の画像で構成されるキューブマップ）を使用し、金属のようなリアルな質感を表現します。
※練習用に Three.js 公式サンプルの画像 URL を使用してください。

## 5. 必須要件

以下の機能を実装してください。

- **CubeTextureLoader の作成と読み込み**:
  `new THREE.CubeTextureLoader()` をインスタンス化し、6方向（px, nx, py, ny, pz, nz）の画像パスを指定して `load()` します。
  画像の順序とファイル名（拡張子）に注意してください。

- **シーン背景への適用**:
  読み込んだテクスチャを `scene.background` に代入し、スカイボックスとして表示させます。

- **マテリアル設定**:
  `MeshStandardMaterial` を作成し、`envMap` プロパティに同じキューブテクスチャを設定します。
  `roughness: 0.0`（完全な滑らかさ）、`metalness: 1.0`（完全な金属）に設定します。

- **描画確認**:
  球体の表面にはっきりと背景の景色が映り込んでいることを確認します。

## 6. ヒント

- **ヒント 1（ローダーの違い）**:
  通常の `TextureLoader` ではなく、`CubeTextureLoader` を使います。
  これは 6 枚の画像をまとめて読み込み、1 つのテクスチャ（CubeTexture）として返してくれます。
- **ヒント 2（画像の順序）**:
  `load([ px, nx, py, ny, pz, nz ])` の順序で配列を渡します。
  Right, Left, Top, Bottom, Front, Back の順です。
- **ヒント 3（背景設定）**:
  `scene.background = texture` とすることで、読み込んだ空の画像がシーン全体の背景として表示されます。
- **ヒント 4（マテリアル設定）**:
  鏡面にするには `MeshStandardMaterial` を使い、以下のように設定します。
  `roughness: 0`（ツルツル）、`metalness: 1`（金属）、`envMap: texture`（映り込み画像）。
- **ヒント 5（ライト）**:
  StandardMaterial はライトがないと暗くなりますが、envMap が設定されていれば映り込みによって明るく見えます。
  念のため `AmbientLight` も入れておくと安心です。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- ここでCubeTextureを読み込んでください ---
// const loader = new THREE.CubeTextureLoader();
// const texture = loader.load([ ... ]);

// --- ここでマテリアルと球体を作成してください ---

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 1. 環境マップの読み込み
const loader = new THREE.CubeTextureLoader();
loader.setPath("https://threejs.org/examples/textures/cube/Bridge2/");

const textureCube = loader.load([
  "posx.jpg",
  "negx.jpg",
  "posy.jpg",
  "negy.jpg",
  "posz.jpg",
  "negz.jpg",
]);

// 2. 背景に設定
scene.background = textureCube;

// 3. マテリアルへの適用
const geometry = new THREE.SphereGeometry(1, 32, 16);
const material = new THREE.MeshStandardMaterial({
  color: 0xffffff,
  envMap: textureCube, // 映り込み用テクスチャ
  roughness: 0.0, // ツルツル
  metalness: 1.0, // 金属
});

const sphere = new THREE.Mesh(geometry, material);
scene.add(sphere);

// ライトも必要
const ambientLight = new THREE.AmbientLight(0xffffff);
scene.add(ambientLight);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  sphere.rotation.y += 0.005;
  renderer.render(scene, camera);
}
animate();
```
