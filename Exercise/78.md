## 1. 問題タイトル

78 本目：ボリューメトリックライト（神の光）

## 2. 学習目標

この演習を通じて、以下の技術を習得します。

- 光の筋（ゴッドレイ）の表現
- 円錐形ジオメトリとフェードシェーダーの組み合わせ
- 簡易的なボリュームライトの実装

## 3. 新しい概念の解説

**Fake Volumetric Light（擬似ボリュームライト）**
霧の中のスポットライトのように「光の筋（God Rays）」が見える表現です。
真面目に計算すると非常に重いため、ゲームなどでは「半透明の円錐モデル（コーン）」を配置し、シェーダーで「根元から先端に向かって透明になる」グラデーションを描くことで、光の筋があるように見せかける軽量なテクニックがよく使われます。

```javascript
const vShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;
const fShader = `
  varying vec2 vUv;
  void main() {
    // 高さに応じて透明度を下げる（根元=1.0, 先端=0.0）
    float alpha = pow(vUv.y, 2.0);
    gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * 0.5);
  }
`;
```

## 4. 課題の説明

スポットライトから光の筋が伸びているような「ボリューメトリックライト」を表現してください。
本物のボリュームレンダリングは重いので、円錐形のメッシュを半透明で表示し、根元から先端にかけて透明になっていくシェーダーを使って擬似的に表現します。

## 5. 必須要件

以下の機能を実装してください。

- **スポットライト配置**:
  `SpotLight` を作成し、上空から下を照らすように配置します。`penumbra`（ぼかし）も設定します。

- **ボリューム用コーン作成**:
  1. `ConeGeometry(radius, height, ...)` を作成します。半径はライトの広がり（`angle`）から計算します（`radius = height * tan(angle)`）。
  2. `geometry.translate(0, -height/2, 0)` で頂点を移動し、先端を原点ではなく「円錐の頂点」に合わせます。
  3. `geometry.rotateX(-Math.PI/2)` で下向きにします。

- **フェードシェーダー**:
  `ShaderMaterial` を作成し、以下の処理を行います。
  - `vertexShader`: `uv` 座標を `varying` で渡す。
  - `fragmentShader`: `alpha = pow(vUv.y, 2.0)` のように、高さ（Y）に応じて透明度を変えるグラデーションを作る。
  - `transparent: true`, `depthWrite: false`（重要）, `blending: THREE.AdditiveBlending`（加算合成）, `side: THREE.DoubleSide` を設定する。

- **配置**:
  作成したコーンメッシュを `spotLight` と同じ位置・向きに配置します（`scene.add(cone)`）。

## 6. ヒント

- **ヒント 1（ジオメトリの調整）**:
  `ConeGeometry` は中心が原点なので、`geometry.translate(0, -height/2, 0)` して頂点を原点に合わせておくと、ライトの位置に配置しやすくなります。
  底面（`openEnded: true`）は開けておくと無駄な描画が減ります。
- **ヒント 2（シェーダーのロジック）**:
  バーテックスシェーダーから UV 座標をフラグメントシェーダーに渡し、Y 座標（高さ）に応じて `alpha` を変化させます。
  `float alpha = pow(vUv.y, 2.0);` のように累乗すると、自然な減衰になります。
- **ヒント 3（マテリアル設定）**:
  光の可算合成を行うため、`blending: THREE.AdditiveBlending` が必須です。
  また、`depthWrite: false` にしないと、半透明な部分が後ろの物体を隠して四角い描画順序のバグ（Artifact）が出ることがあります。
- **ヒント 4（両面描画）**:
  見る角度によっては裏側が見えるため、`side: THREE.DoubleSide` にしておくと安心です。
- **ヒント 5（SpotLightとの連動）**:
  本物のライト（`SpotLight`）は物体を照らすために使い、このコーンは「光の筋」を見せるためだけに使います。
  両方の位置と向き（`target`）を同期させる必要があります。

## 7. スターターコード

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// スポットライト
const spotLight = new THREE.SpotLight(0xffffff, 10);
spotLight.position.set(0, 5, 0);
spotLight.angle = Math.PI / 6;
scene.add(spotLight);

// 床
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(10, 10),
  new THREE.MeshStandardMaterial({ color: 0x444444 })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

// --- ここで光の筋（コーン）を作成 ---
// const geometry = new THREE.ConeGeometry(...);
// const material = new THREE.ShaderMaterial(...);

camera.position.set(0, 2, 8);
camera.lookAt(0, 2, 0);

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
```

## 8. 模範解答

```javascript
import * as THREE from "three";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// スポットライト
const spotLight = new THREE.SpotLight(0xffffff, 2);
spotLight.position.set(0, 5, 0);
spotLight.angle = Math.PI / 6;
spotLight.penumbra = 0.5;
scene.add(spotLight);

// 床
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.MeshStandardMaterial({ color: 0x222222 })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

// ボリュームライト用コーン
const height = 5;
const radius = Math.tan(spotLight.angle) * height;
const geometry = new THREE.ConeGeometry(radius, height, 32, 1, true); // 底面なし
geometry.translate(0, -height / 2, 0); // 頂点を原点に
geometry.rotateX(-Math.PI / 2); // スポットライトの向きに合わせる（下向き）

const vShader = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

const fShader = `
    varying vec2 vUv;
    void main() {
        // UVのY座標（高さ方向）を使ってフェードさせる
        // 根元(1.0) -> 先端(0.0)
        float alpha = pow(vUv.y, 2.0); 
        
        // 端の方も少しフェードさせるとより自然
        
        gl_FragColor = vec4(1.0, 1.0, 0.8, alpha * 0.5);
    }
`;

const material = new THREE.ShaderMaterial({
  vertexShader: vShader,
  fragmentShader: fShader,
  transparent: true,
  depthWrite: false, // 奥の物体を隠さない
  blending: THREE.AdditiveBlending,
  side: THREE.DoubleSide,
});

const cone = new THREE.Mesh(geometry, material);
cone.position.copy(spotLight.position);
// スポットライトと同じ向きにする必要があるが、今回は真下なのでそのまま
scene.add(cone);

camera.position.set(0, 2, 10);

function animate() {
  requestAnimationFrame(animate);

  // ライトを揺らす
  spotLight.position.x = Math.sin(Date.now() * 0.001) * 2;
  cone.position.copy(spotLight.position);

  renderer.render(scene, camera);
}
animate();
```
